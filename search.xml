<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>c语言模板</title>
    <url>/2023/03/20/c%E8%AF%AD%E8%A8%80%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<ul>
<li>
<p>本文主要是一些常用的c语言代码模板，包含部分简单算法，提供的代码解释也仅限于代码注释，请读者自行理解使用</p>
<span id="more"></span>
<h1>数据结果模板</h1>
<h2 id="链表">链表</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">element</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line"></span><br><span class="line">&#125; ElemType; <span class="comment">//创建元素类型；</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">link</span>;</span><span class="comment">//自引用指针；</span></span><br><span class="line"></span><br><span class="line">&#125; Node, *Nodeprt; <span class="comment">//创建链表和自引用指针类型；</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Nodeprt <span class="title function_">createList</span><span class="params">(<span class="type">int</span> n)</span>;<span class="comment">//创建n个结点的链表；</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getLength</span><span class="params">(Nodeprt <span class="built_in">list</span>)</span>;<span class="comment">//获得链表长度；</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">destroyList</span><span class="params">(Nodeprt <span class="built_in">list</span>)</span>;<span class="comment">//销毁一个表；</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printList</span><span class="params">(Nodeprt <span class="built_in">list</span>)</span>;<span class="comment">//输出一个表；</span></span><br><span class="line">Nodeprt <span class="title function_">insertFirst</span><span class="params">(Nodeprt <span class="built_in">list</span>, ElemType elem)</span>;<span class="comment">//链表开头插入一个元素；</span></span><br><span class="line">Nodeprt <span class="title function_">insertList_rank</span><span class="params">(Nodeprt <span class="built_in">list</span>, ElemType elem)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//有序链表插入相应结点；</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">insertNode1</span><span class="params">(Nodeprt <span class="built_in">list</span>, <span class="type">int</span> n, ElemType elem)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第n个结点之后插入一个结点</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">insertList</span><span class="params">(Nodeprt <span class="built_in">list</span>, Nodeprt p, ElemType elem)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//链表某一结点后面插入带某个元素的结点；</span></span><br><span class="line">Nodeprt <span class="title function_">searchNode</span><span class="params">(Nodeprt <span class="built_in">list</span>, ElemType elem)</span>; <span class="comment">//链表里查找某个元素，返回地址；</span></span><br><span class="line">Nodeprt <span class="title function_">deleteNode</span><span class="params">(Nodeprt <span class="built_in">list</span>, Nodeprt p)</span>; <span class="comment">//链表里面删除某一元素和结点p；</span></span><br><span class="line">ElemType <span class="title function_">read</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">buildlist</span><span class="params">(<span class="type">int</span> n)</span>;<span class="comment">//构建循环链表； </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//p=p-&gt;link;指向下一个结点；</span></span><br><span class="line">    <span class="comment">/*q-&gt;link=p-&gt;link;</span></span><br><span class="line"><span class="comment">    p-&gt;link=q;</span></span><br><span class="line"><span class="comment">    在p后面插入结点q*/</span></span><br><span class="line">    <span class="comment">/*q=p-&gt;link;</span></span><br><span class="line"><span class="comment">    p-&gt;link=q-&gt;link;</span></span><br><span class="line"><span class="comment">    free(q);</span></span><br><span class="line"><span class="comment">    删除p的下一个结点*/</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Nodeprt <span class="title function_">createList</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    Nodeprt p, q, <span class="built_in">list</span> = <span class="literal">NULL</span>;</span><br><span class="line">    p = (Nodeprt) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node)); <span class="comment">//Node结构大小的指针</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        q = (Nodeprt) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">        q-&gt;data = read(); <span class="comment">//读取一个元素；read自己写</span></span><br><span class="line">        <span class="comment">//根据题目的输入方法自己写合适的输入函数；</span></span><br><span class="line">        q-&gt;link = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">list</span> == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">list</span> = p = q;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            p-&gt;link = q;</span><br><span class="line">        &#125;</span><br><span class="line">        p = q; <span class="comment">//时间复杂度为n</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">getLength</span><span class="params">(Nodeprt <span class="built_in">list</span>)</span> &#123;</span><br><span class="line">    Nodeprt p;<span class="comment">//p为遍历所有结点的指针；</span></span><br><span class="line">    <span class="type">int</span> n = <span class="number">0</span>; <span class="comment">//长度初值；</span></span><br><span class="line">    <span class="keyword">for</span> (p = <span class="built_in">list</span>; p != <span class="literal">NULL</span>; p-&gt;link = p) &#123;</span><br><span class="line">        n++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Nodeprt <span class="title function_">insertFirst</span><span class="params">(Nodeprt <span class="built_in">list</span>, ElemType elem)</span> &#123;</span><br><span class="line">    Nodeprt p = (Nodeprt) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    p-&gt;data = elem; <span class="comment">//读入新的数据结点到开头；</span></span><br><span class="line">    p-&gt;link = <span class="built_in">list</span>;</span><br><span class="line">    <span class="keyword">return</span> p;<span class="comment">//p是新的起点；</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">insertNode</span><span class="params">(Nodeprt <span class="built_in">list</span>, Nodeprt p, ElemType elem)</span> &#123;<span class="comment">//p之后插入 </span></span><br><span class="line">    Nodeprt q = (Nodeprt) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    q-&gt;data = elem;</span><br><span class="line">    q-&gt;link = p-&gt;link;</span><br><span class="line">    p-&gt;link = q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">insertNode1</span><span class="params">(Nodeprt <span class="built_in">list</span>, <span class="type">int</span> n, ElemType elem)</span> &#123;</span><br><span class="line">    <span class="comment">//在第n个结点之后插入</span></span><br><span class="line">    Nodeprt p = <span class="built_in">list</span>, q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;link == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        p = p-&gt;link; <span class="comment">//n-1次后，p表示指向n的指针;</span></span><br><span class="line">        <span class="comment">//list算作第一个结点;</span></span><br><span class="line">    &#125;</span><br><span class="line">    q = (Nodeprt) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    q-&gt;data = elem;</span><br><span class="line">    q-&gt;link = p-&gt;link; <span class="comment">//新元素指向</span></span><br><span class="line">    p-&gt;link = q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Nodeprt <span class="title function_">insertList_rank</span><span class="params">(Nodeprt <span class="built_in">list</span>, ElemType elem)</span> &#123;</span><br><span class="line">    Nodeprt p, q, r;</span><br><span class="line">    r = (Nodeprt) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    r-&gt;data = elem;</span><br><span class="line">    r-&gt;link = <span class="literal">NULL</span>; <span class="comment">//创建新数据点</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">list</span> == <span class="literal">NULL</span>) &#123; <span class="comment">//空表</span></span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (p = <span class="built_in">list</span>; p != <span class="literal">NULL</span> &amp;&amp; elem &gt; p-&gt;data; q = p, p = p-&gt;link); <span class="comment">//找到插入点</span></span><br><span class="line">    <span class="comment">// 应该data是升序排列 q就是插入点指针</span></span><br><span class="line">    <span class="comment">//这里的比较大小，如果是单个元素可以直接比较，</span></span><br><span class="line">    <span class="comment">//如果是结构体,比较元素或者//需要另外写比较函数； </span></span><br><span class="line">    <span class="comment">//插入点在q后，p前 </span></span><br><span class="line">    <span class="keyword">if</span> (p == <span class="built_in">list</span>) &#123; <span class="comment">//没有q，在头指针前插入 </span></span><br><span class="line">        r-&gt;link = p;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        q-&gt;link = r;</span><br><span class="line">        r-&gt;link = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Nodeprt <span class="title function_">deleteNode</span><span class="params">(Nodeprt <span class="built_in">list</span>, Nodeprt p)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="built_in">list</span>) &#123;<span class="comment">//删除首结点 </span></span><br><span class="line">        <span class="built_in">list</span> = p-&gt;link;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Nodeprt q = (Nodeprt) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">        q = p-&gt;link;</span><br><span class="line">        p-&gt;link = q-&gt;link;</span><br><span class="line">        <span class="built_in">free</span>(q);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">buildlist</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line"></span><br><span class="line">    Nodeprt p, <span class="built_in">list</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        Nodeprt r = (Nodeprt) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">        r-&gt;data = read();</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">list</span> == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">list</span> = p = r;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            p-&gt;link = r;</span><br><span class="line">            p = p-&gt;link;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;link = <span class="built_in">list</span>;<span class="comment">//循环链表，把结尾和开头接上 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="栈">栈</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 1000</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">elem</span> &#123;</span></span><br><span class="line"></span><br><span class="line">&#125; ElemType;</span><br><span class="line">ElemType STACK[MAXSIZE];</span><br><span class="line"><span class="type">int</span> top = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化堆栈 </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">initStack</span><span class="params">()</span> &#123;</span><br><span class="line">    top = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试堆栈是否为空</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> top == <span class="number">-1</span>;<span class="comment">//栈空返回1，否则返回0 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试栈是否已满</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isFull</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> top == MAXSIZE - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//进栈</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Error</span><span class="params">(<span class="type">char</span> s[])</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, s);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">push</span><span class="params">(ElemType s[], ElemType item)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isFull()) &#123;</span><br><span class="line">        Error(<span class="string">&quot;Full Stack!&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        s[++top] = item;<span class="comment">//先++再赋值 </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出栈</span></span><br><span class="line">ElemType <span class="title function_">pop</span><span class="params">(ElemType s[])</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">        Error(<span class="string">&quot;Empty Stack!&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> s[top--];<span class="comment">//弹出s[top],再-- </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h2 id="队列">队列</h2>
<h3 id="一般队列">一般队列</h3>
<h3 id="优先队列-基于堆实现">优先队列(基于堆实现)</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MinData -1001</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElementType;<span class="comment">//自定义数据类型； </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">HeapStruct</span> &#123;</span></span><br><span class="line">    ElementType *Elements;<span class="comment">//存储堆元素的数组，指针数组</span></span><br><span class="line">    <span class="type">int</span> size;    <span class="comment">//堆的当前元素个数； </span></span><br><span class="line">    <span class="type">int</span> capacity;<span class="comment">//堆的最大容量 </span></span><br><span class="line">&#125; MinHeap, *MinHeapPrt;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">IsFull</span><span class="params">(MinHeapPrt H)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (H-&gt;size == Maxsize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">IsEmpty</span><span class="params">(MinHeapPrt H)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (H-&gt;size == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MinHeapPrt <span class="title function_">Create</span><span class="params">(<span class="type">int</span> Maxsize)</span> &#123;</span><br><span class="line">    <span class="comment">//创建容量为Maxsize的空的最小堆</span></span><br><span class="line">    <span class="comment">//从1开始插入元素，0留给哨兵； </span></span><br><span class="line">    MinHeapPrt H = (MinHeapPrt) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(MinHeap));</span><br><span class="line">    H-&gt;Elements = (ElementType *) <span class="built_in">malloc</span>((Maxsize + <span class="number">1</span>) * <span class="keyword">sizeof</span>(ElementType));</span><br><span class="line">    H-&gt;size = <span class="number">0</span>;</span><br><span class="line">    H-&gt;capacity = Maxsize;</span><br><span class="line">    H-&gt;Elements[<span class="number">0</span>] = MinData;<span class="comment">//随便找一个特别小，比所有输入数据小的元素就行； </span></span><br><span class="line">    <span class="comment">//MinData.定义哨兵为小于堆中所有可能元素的值，便于以后更快操作</span></span><br><span class="line">    <span class="keyword">return</span> H;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">insert</span><span class="params">(MinHeapPrt H, ElementType item)</span> &#123;</span><br><span class="line">    <span class="comment">//将元素item插入最小堆H，其中H-&gt;Elements[0]已经定义为哨兵；</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">if</span> (IsFull(H)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;最小堆已满&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    i = ++H-&gt;size;<span class="comment">//i指向插入后的最后一个元素位置； </span></span><br><span class="line">    <span class="keyword">for</span> (; H-&gt;Elements[i / <span class="number">2</span>] &gt; item; i /= <span class="number">2</span>)<span class="comment">//完全二叉树有i/2表示父结点的性质；如果父结点比目标item大，</span></span><br><span class="line">        <span class="comment">//这里会有i=1的情况，但是有哨兵存在，哨兵保证了所有输入数据都比哨兵大，如果没有哨兵，可以加一句i&gt;1; </span></span><br><span class="line">        <span class="comment">//哨兵效率更高； </span></span><br><span class="line">        H-&gt;Elements[i] = H-&gt;Elements[i / <span class="number">2</span>];<span class="comment">//保证有序性，把大小不符合的往下过滤， </span></span><br><span class="line">    H-&gt;Elements[i] = item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ElementType <span class="title function_">deleteMin</span><span class="params">(MinHeapPrt H)</span> &#123;</span><br><span class="line">    <span class="comment">//从最小堆中去除键值最小的元素，删除结点</span></span><br><span class="line">    <span class="type">int</span> parent, child;</span><br><span class="line">    ElementType MinItem, temp;</span><br><span class="line">    <span class="keyword">if</span> (IsEmpty(H)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;最小堆已空&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    MinItem = H-&gt;Elements[<span class="number">1</span>];<span class="comment">//从根结点找最小值；</span></span><br><span class="line">    <span class="comment">//用最小堆中最后一个元素从根结点开始向上过滤下层结点，就是先把最后一个元素放到根的位置</span></span><br><span class="line">    temp = H-&gt;Elements[H-&gt;size--];<span class="comment">//先赋值，再减减 </span></span><br><span class="line">    <span class="keyword">for</span> (parent = <span class="number">1</span>; parent * <span class="number">2</span> &lt;= H-&gt;size; parent = child) &#123;<span class="comment">//判断保证存在左子； </span></span><br><span class="line">        child = parent * <span class="number">2</span>;<span class="comment">//左子</span></span><br><span class="line">        <span class="keyword">if</span> ((child != H-&gt;size) &amp;&amp; (H-&gt;Elements[child] &gt; H-&gt;Elements[child + <span class="number">1</span>])) <span class="comment">//判断保证有左子的同时还有右子； </span></span><br><span class="line">            child++;<span class="comment">//左子比右子大 </span></span><br><span class="line">        <span class="keyword">if</span> (temp &lt;= H-&gt;Elements[child])<span class="keyword">break</span>;<span class="comment">//调整值比左右子都小；那就放在父的位置 </span></span><br><span class="line">        <span class="keyword">else</span><span class="comment">//移动temp元素到下一层 </span></span><br><span class="line">            H-&gt;Elements[parent] = H-&gt;Elements[child];<span class="comment">//向上过滤，往上移 </span></span><br><span class="line">    &#125;</span><br><span class="line">    H-&gt;Elements[parent] = temp;</span><br><span class="line">    <span class="keyword">return</span> MinItem;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">adjust_MinHeap</span><span class="params">(MinHeapPrt H, <span class="type">int</span> p)</span> &#123;</span><br><span class="line">    <span class="comment">//保证数据已经形成了一颗完全二叉树，根是H，需要调整第p个结点为根的最小堆；</span></span><br><span class="line">    <span class="type">int</span> parent, child;</span><br><span class="line">    ElementType temp;</span><br><span class="line">    temp = H-&gt;Elements[p];<span class="comment">//以p为根的最小堆；,前提是p的左右子树都是最小堆；一般模型，某个根的左右子树都是最大堆或者最小堆，通过调整根让其整体成为最大/最小堆； </span></span><br><span class="line">    <span class="keyword">for</span> (parent = p; parent * <span class="number">2</span> &lt;= H-&gt;size; parent = child) &#123;</span><br><span class="line">        child = parent * <span class="number">2</span>;<span class="comment">//左</span></span><br><span class="line">        <span class="keyword">if</span> ((child != H-&gt;size) &amp;&amp; (H-&gt;Elements[child] &gt; H-&gt;Elements[child + <span class="number">1</span>])) &#123;</span><br><span class="line">            child++;<span class="comment">//左比右大 </span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (temp &lt;= H-&gt;Elements[child])<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            H-&gt;Elements[parent] = H-&gt;Elements[child];<span class="comment">//向下过滤，向上移动； </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    H-&gt;Elements[parent] = temp;<span class="comment">//调整了堆 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Build_MinHeap</span><span class="params">(MinHeapPrt H)</span> &#123; <span class="comment">/* 调整H-&gt;Data[]中的元素，使满足最小堆的有序性  */</span></span><br><span class="line">    <span class="comment">/* 这里假设所有H-&gt;Size个元素已经存在H-&gt;Elements[]中 */</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="comment">/* 从最后一个结点的父节点开始，到根结点1 */</span></span><br><span class="line">    <span class="comment">//所有叶结点已经是最大堆或者最小堆；从最后一个满足（根不符合，但是根的左右子树都满足最大堆，最小堆的结构开始调整） </span></span><br><span class="line">    <span class="keyword">for</span> (i = H-&gt;size / <span class="number">2</span>; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">        adjust_MinHeap(H, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="单调队列-以递减为例">单调队列(以递减为例)</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Maxsize 10000</span></span><br><span class="line"><span class="type">int</span> queue_num[Maxsize], queue_site[Maxsize];</span><br><span class="line"><span class="comment">//num存储队列数值，site存取对应数值在原先的数组里面的位置；</span></span><br><span class="line"><span class="type">int</span> head = <span class="number">0</span>, rear = <span class="number">0</span>;<span class="comment">//rear-1表示当前队尾的位置，head表示当前对头的位置 </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> n, x, k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">        <span class="keyword">if</span> (head != rear) &#123;<span class="comment">//队列非空</span></span><br><span class="line">            <span class="comment">//单调队列的单调情况有：增，减，自定义</span></span><br><span class="line">            <span class="comment">//下面以递减为例子</span></span><br><span class="line">            <span class="keyword">while</span> (head != rear &amp;&amp; queue_site[head] &lt;= i - k)head++;<span class="comment">//如果队首元素不在扫描区间内部，从队首弹出</span></span><br><span class="line">            <span class="keyword">while</span> (head != rear &amp;&amp; queue_num[rear - <span class="number">1</span>] &lt;= x)rear--;<span class="comment">//队尾元素比新元素小或者等于，从队尾弹出</span></span><br><span class="line">            queue_num[rear] = x;</span><br><span class="line">            queue_site[rear++] = i;<span class="comment">//新元素入队 </span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//队列空了，</span></span><br><span class="line">            queue_num[rear] = x;</span><br><span class="line">            queue_site[rear++] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="树">树</h2>
<h3 id="哈夫曼树-基于最小堆实现最小加权">哈夫曼树(基于最小堆实现最小加权)</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">HuffmanTree</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> weight;</span><br><span class="line">    HuffmanTree left, right;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//需要最小堆实现； </span></span><br><span class="line">HuffmanTree <span class="title function_">Huffman</span><span class="params">(MinHeapPrt H)</span> &#123;</span><br><span class="line">    <span class="comment">//假设H-&gt;size个权值已经存在H-&gt;Elements[]-&gt;weight里面了</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    HuffmanTree T;</span><br><span class="line">    BuildMinHeap(H);<span class="comment">//将H-&gt;Elements[]按照权值调整为最小堆</span></span><br><span class="line">    <span class="type">int</span> k = H-&gt;size;<span class="comment">//在下面合并过程中size会被改变，需要维持不变 </span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; k; i++) &#123;<span class="comment">//做H-&gt;size-1次合并</span></span><br><span class="line">        T = (HuffmanTree) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> TreeNode));</span><br><span class="line">        T-&gt;left = deleteMin(H);<span class="comment">//从最小堆里面删除一个结点作为新T的左子</span></span><br><span class="line">        T-&gt;right = deleteMin(H);<span class="comment">//从最小堆里面删除一个结点作为新T的右子；</span></span><br><span class="line">        T-&gt;weight = T-&gt;left-&gt;weight + T-&gt;right-&gt;weight;</span><br><span class="line">        <span class="comment">//计算新权值；</span></span><br><span class="line">        insert(H, T);<span class="comment">//将新T插入最小堆； </span></span><br><span class="line">    &#125;</span><br><span class="line">    T = deleteMin(H);</span><br><span class="line">    <span class="keyword">return</span> T;<span class="comment">///时间复杂度为nlogn；</span></span><br><span class="line">    <span class="comment">//构造一颗哈夫曼树； </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="图">图</h2>
<h3 id="最小生成树">最小生成树</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXVER  512</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INFINITY   32767<span class="comment">//定义无穷大 </span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Prim</span><span class="params">(<span class="type">int</span> weights[][MAXVER], <span class="type">int</span> n, <span class="type">int</span> src, <span class="type">int</span> edges[])</span> &#123; <span class="comment">//weights为权重数组、n为顶点个数、src为最小树的第一个顶点、edge为最小生成树边</span></span><br><span class="line">    <span class="comment">//定义edge[i]为顶点i的前序顶点，就是edge[i]顶点之后就是i顶点 </span></span><br><span class="line">    <span class="type">int</span> minweight[MAXVER], min;</span><br><span class="line">    <span class="type">int</span> i, j, k;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;  <span class="comment">//初始化相关数组</span></span><br><span class="line">        minweight[i] = weights[src][i];  <span class="comment">//将src顶点与之有边的权值存入数组</span></span><br><span class="line">        <span class="comment">//采用邻接矩阵，不存在的边采用无穷大存取； </span></span><br><span class="line">        edges[i] = src;  <span class="comment">//初始时所有顶点的前序顶点设为src，(src,i）//edge数组其实就是在保存最小生成树的结构； </span></span><br><span class="line">    &#125;</span><br><span class="line">    minweight[src] = <span class="number">0</span>;   <span class="comment">//将第一个顶点src顶点加入生成树</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        min = INFINITY;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>, k = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            <span class="keyword">if</span> (minweight[j] != <span class="number">0</span> &amp;&amp; minweight[j] &lt; min) &#123;  <span class="comment">//在数组中找最小值，其下标为k</span></span><br><span class="line">                <span class="comment">//找距离最小生成树最近的结点，就是最小权值 </span></span><br><span class="line">                min = minweight[j];</span><br><span class="line">                k = j;</span><br><span class="line">            &#125;</span><br><span class="line">        minweight[k] = <span class="number">0</span>;  <span class="comment">//找到最小树的一个顶点，</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            <span class="keyword">if</span> (minweight[j] != <span class="number">0</span> &amp;&amp; weights[k][j] &lt; minweight[j]) &#123;  <span class="comment">//根据最新加入的点k去更新minweight数组； </span></span><br><span class="line">                minweight[j] = weights[k][j];    <span class="comment">//将小于当前权值的边(k,j)权值加入数组中</span></span><br><span class="line">                edges[j] = k;   <span class="comment">//将边(j,k)信息存入边数组中</span></span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//kruskal算法 </span></span><br></pre></td></tr></table></figure>
<h1>动态规划</h1>
<h2 id="01背包">01背包</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> max_num 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> max_weight 200</span></span><br><span class="line"><span class="type">int</span> weight[<span class="number">202</span>], value[<span class="number">202</span>];</span><br><span class="line"><span class="type">int</span> dp[max_num][max_weight];<span class="comment">//dp[i][j]表示考虑前i件商品，有j的容量能取到的最大价值 </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> n, m;<span class="comment">//m就是定义的最大容量 </span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;weight[i], &amp;value[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &lt; weight[i])dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = max(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - weight[i]] + value[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//考虑第i件物品时，当前容量j，商品weight[i]</span></span><br><span class="line"><span class="comment">//如果j能够装下第i件商品，dp[i][j]=dp[i-1][j-weight[i]]+value[i],这是拿下该商品的价值</span></span><br><span class="line"><span class="comment">//如果能装下，但是不买，dp[i][j]=dp[i-1][j],等价于考虑前i-1件商品的情况j容量</span></span><br><span class="line"><span class="comment">//对于内外层循环的参数选择，以及从大到小，或者从小到大的顺序选择,</span></span><br><span class="line"><span class="comment">//以设置的二维dp数组的第一个参数作为行，第二个作为列，画出二维对应图表</span></span><br><span class="line"><span class="comment">//那么dp[i][j]的数值与dp[i-1][j]或者dp[i-1][j-weight[i]]有关，也就是上一行有关，</span></span><br><span class="line"><span class="comment">//而j的取值与j或者j-weight[i]有关，所以确定循环方式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//超级优化：一维滚动数组，详细参考csdn文章 </span></span><br><span class="line"><span class="comment">/*int dp[max_weight];</span></span><br><span class="line"><span class="comment">    for(int i=1;i&lt;=n;i++)&#123;</span></span><br><span class="line"><span class="comment">        for(int j=m;j&gt;=weight[i];j--)&#123;</span></span><br><span class="line"><span class="comment">            dp[j]=max(dp[j],dp[j-weight[i]]+value[i]);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br></pre></td></tr></table></figure>
<h2 id="多重背包-二进制优化">多重背包(二进制优化)</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> max_num 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> max_weight 200</span></span><br><span class="line"><span class="type">int</span> weight[<span class="number">202</span>], value[<span class="number">202</span>];</span><br><span class="line"><span class="type">int</span> dp[max_num][max_weight];<span class="comment">//dp[i][j]表示考虑前i件商品，有j的容量能取到的最大价值 </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="type">int</span> v, w, num;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;v, &amp;w, &amp;num);</span><br><span class="line">        <span class="comment">//对num进行2进制拆解，1，2，4，8，16 .........以及一个无法继续取到的余数</span></span><br><span class="line">        <span class="comment">//10=1,2,4,3</span></span><br><span class="line">        <span class="comment">//58=1,2,4,8,16,27,</span></span><br><span class="line">        <span class="type">int</span> k = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (k &lt;= num) &#123;</span><br><span class="line">            value[cnt] = v * k;</span><br><span class="line">            weight[cnt++] = w * k;</span><br><span class="line">            num -= k;</span><br><span class="line">            k &lt;&lt;= <span class="number">1</span>;<span class="comment">//k乘以2 </span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            value[cnt] = v * num;</span><br><span class="line">            weight[cnt++] = w * num;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//那么就是前cnt件商品</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= cnt - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &lt; weight[i])dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = max(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - weight[i]] + value[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对于n件商品，最大容量是m，每件商品价值value，对应weight，</span></span><br><span class="line"><span class="comment">//(与01背包不同点，每件商品数量是x件，把x件全部拆解开，转换成01背包问题 </span></span><br><span class="line"><span class="comment">//拆解之后，对于数组容量需要适当进行扩大 </span></span><br></pre></td></tr></table></figure>
<h2 id="分组背包">分组背包</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> max_num 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> max_weight 200</span></span><br><span class="line"><span class="type">int</span> weight[<span class="number">100</span>][max_weight], value[<span class="number">100</span>][max_num];</span><br><span class="line"><span class="type">int</span> s[<span class="number">100</span>];<span class="comment">//表示每一组有多少个物品</span></span><br><span class="line"><span class="type">int</span> dp[<span class="number">100</span>][max_weight];<span class="comment">//前i组，最大价值 </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;s[i]);<span class="comment">//有很多个组，每个组最多只能选择一个物品 </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= s[i]; j++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;value[i][j], &amp;weight[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            dp[i][j] = dp[i - <span class="number">1</span>][j];<span class="comment">//不选第i组，从前i-1组里面选择</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= s[i]; k++) &#123;<span class="comment">//遍历第i组的所有物品 </span></span><br><span class="line">                <span class="keyword">if</span> (j &gt;= weight[i][k])</span><br><span class="line">                    dp[i][j] = max(dp[i][j], dp[i - <span class="number">1</span>][j - weight[i][k]] + value[i][k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//滚动数组优化，一维</span></span><br><span class="line"><span class="comment">//滚动数组逆向枚举，具体思想还是得画出二维表格进行推导</span></span><br><span class="line"><span class="comment">/*int f[100];</span></span><br><span class="line"><span class="comment">            for(int i=1;i&lt;=n;i++)&#123;</span></span><br><span class="line"><span class="comment">                for(int j=m;j&gt;=0;j--)&#123;</span></span><br><span class="line"><span class="comment">                    for(int k=1;k&lt;=s[i];k++)&#123;</span></span><br><span class="line"><span class="comment">                        if(j&gt;=weight[i][k])f[j]=max(f[j],f[j-weight[i][k]]+value[i][k]);</span></span><br><span class="line"><span class="comment">                    &#125;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            &#125; */</span> </span><br><span class="line">			</span><br></pre></td></tr></table></figure>
<h2 id="完全背包">完全背包</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> max_num 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> max_weight 200</span></span><br><span class="line"><span class="type">int</span> weight[<span class="number">202</span>], value[<span class="number">202</span>];</span><br><span class="line"><span class="type">int</span> dp[<span class="number">100</span>][<span class="number">200</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &lt; weight[i])dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = max(dp[i - <span class="number">1</span>][j], dp[i][j - weight[i]] + value[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*		分析完全背包问题，每个物品有无限个，求最大价值</span></span><br><span class="line"><span class="comment">	1.暴力解法</span></span><br><span class="line"><span class="comment">		for(int i=1;i&lt;=n;i++)&#123;</span></span><br><span class="line"><span class="comment">			for(int j=0;j&lt;=max_weight;j++)&#123;</span></span><br><span class="line"><span class="comment">				for(int k=0;k*weight[i]&lt;=j;k++)&#123;</span></span><br><span class="line"><span class="comment">				dp[i][j]=max(dp[i][j],dp[i-1][j-k*weight[i]]+k*value[i]);</span></span><br><span class="line"><span class="comment">				&#125;//去遍历对于每件商品的所有取值情况，取最大的价值的情况作为结果 </span></span><br><span class="line"><span class="comment">			&#125;</span></span><br><span class="line"><span class="comment">		&#125;		*/</span></span><br><span class="line"><span class="comment">/*分析：dp[i][j]=max(dp[i-1][j],dp[i-1][j-k*weight[i]]+value[i]*k);</span></span><br><span class="line"><span class="comment">        其中k取很多很多值，这里只是一个缩写,这里把j替换一下，可以实现递归整体替换 </span></span><br><span class="line"><span class="comment">        dp[i][j-weight[i]]=max(dp[i-1][j-weight[i]],dp[i-1][j-weight[i]*k]+k*value[i]);</span></span><br><span class="line"><span class="comment">        把两个式子整合在一起</span></span><br><span class="line"><span class="comment">        dp[i][j]=max(dp[i-1][j],dp[i][j-weight[i]]);</span></span><br><span class="line"><span class="comment">        只要循环的时候j从小到大遍历就行</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">    优化1：</span></span><br><span class="line"><span class="comment">    for(int i=1;i&lt;=n;i++)&#123;</span></span><br><span class="line"><span class="comment">        for(int j=0;j&lt;=max_weight;j++)&#123;</span></span><br><span class="line"><span class="comment">            if(j&lt;weight[i])dp[i][j]=dp[i-1][j];</span></span><br><span class="line"><span class="comment">            else&#123;</span></span><br><span class="line"><span class="comment">                dp[i][j]=max(dp[i-1][j],dp[i][j-weight[i]]+value[i]);</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;	</span></span><br><span class="line"><span class="comment">    超级优化,滚动数组：详细参考csdn文章 </span></span><br><span class="line"><span class="comment">        for(int i=1;i&lt;=n;i++)&#123;</span></span><br><span class="line"><span class="comment">            for(int j=weight[i];j&lt;=max_weight;j++)&#123;</span></span><br><span class="line"><span class="comment">                f[j]=max(f[j],f[j-weight[i]]+value[i]);</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            直接优化成为一维了*/</span></span><br></pre></td></tr></table></figure>
<h1>排序</h1>
<h2 id="二路归并">二路归并</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//归并排序 非递归版本</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MergeSortNonR</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> *tmp = (<span class="type">int</span> *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * n);</span><br><span class="line">    <span class="keyword">if</span> (tmp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;申请空间失败\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> gap = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (gap &lt; n) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i += <span class="number">2</span> * gap) &#123; <span class="comment">//每次跨越两组</span></span><br><span class="line">            <span class="type">int</span> begin1 = i, end1 = i + gap - <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> begin2 = i + gap, end2 = i + <span class="number">2</span> * gap - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (end1 &gt;= n || begin2 &gt;= n) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (end2 &gt;= n) &#123;</span><br><span class="line">                end2 = n - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//归并</span></span><br><span class="line">            <span class="type">int</span> j = begin1;</span><br><span class="line">            <span class="type">int</span> m = end2 - begin1 + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (begin1 &lt;= end1 &amp;&amp; begin2 &lt;= end2) &#123;</span><br><span class="line">                <span class="keyword">if</span> (a[begin1] &lt;= a[begin2]) &#123;</span><br><span class="line">                    tmp[j++] = a[begin1++];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    tmp[j++] = a[begin2++];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (begin1 &lt;= end1) &#123;</span><br><span class="line">                tmp[j++] = a[begin1++];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (begin2 &lt;= end2) &#123;</span><br><span class="line">                tmp[j++] = a[begin2++];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">memcpy</span>(a + i, tmp + i, <span class="keyword">sizeof</span>(<span class="type">int</span>) * m);<span class="comment">//局部复制，end2 - begin1 + 1</span></span><br><span class="line">        &#125;</span><br><span class="line">        gap *= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(tmp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//归并排序的递归///////数据不能太大，不然会爆栈</span></span><br><span class="line"><span class="comment">//////////////////////////</span></span><br><span class="line"><span class="comment">//辅助归并排序递归的子函数</span></span><br><span class="line"><span class="type">void</span> _MergeSort(<span class="type">int</span> *a, <span class="type">int</span> *tmp, <span class="type">int</span> begin, <span class="type">int</span> end) &#123;</span><br><span class="line">    <span class="keyword">if</span> (begin &gt;= end)</span><br><span class="line">        <span class="keyword">return</span>;<span class="comment">//单个或者不存在其区间就结束递归</span></span><br><span class="line">    <span class="comment">//类似于后序：</span></span><br><span class="line">    <span class="type">int</span> middle = (begin + end) / <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> begin1 = begin;</span><br><span class="line">    <span class="type">int</span> end1 = middle;</span><br><span class="line">    <span class="type">int</span> begin2 = middle + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> end2 = end;</span><br><span class="line">    _MergeSort(a, tmp, begin1, end1);</span><br><span class="line">    _MergeSort(a, tmp, begin2, end2);</span><br><span class="line">    <span class="comment">//此时认为 [begin1, end1] 和 [begin2, end2]两段区间上有序</span></span><br><span class="line">    <span class="comment">//归并算法</span></span><br><span class="line">    <span class="type">int</span> i = begin;</span><br><span class="line">    <span class="keyword">while</span> (begin1 &lt;= end1 &amp;&amp; begin2 &lt;= end2) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[begin1] &lt;= a[begin2]) &#123;</span><br><span class="line">            tmp[i++] = a[begin1++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tmp[i++] = a[begin2++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (begin1 &lt;= end1) &#123;</span><br><span class="line">        tmp[i++] = a[begin1++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (begin2 &lt;= end2) &#123;</span><br><span class="line">        tmp[i++] = a[begin2++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memcpy</span>(a + begin, tmp + begin, <span class="keyword">sizeof</span>(<span class="type">int</span>) * (end - begin + <span class="number">1</span>));<span class="comment">//内存操作函数，可以将整个数组的数复制过去</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//归并排序 递归版本</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MergeSort</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> *tmp = (<span class="type">int</span> *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * n);<span class="comment">//首先malloc一个数组</span></span><br><span class="line">    <span class="keyword">if</span> (tmp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;未能申请到内存\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//第一次传入 0 和 n - 1 传入闭区间</span></span><br><span class="line">    _MergeSort(a, tmp, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">free</span>(tmp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="手写快排">手写快排</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE 6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//快速排序</span></span><br><span class="line"><span class="comment">//升序排列，tmp=num[low]</span></span><br><span class="line"><span class="comment">//降序排列，tmp=num[high] </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">quick_sort</span><span class="params">(<span class="type">int</span> num[], <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i, j, temp;</span><br><span class="line">    <span class="type">int</span> tmp;</span><br><span class="line">    i = low;</span><br><span class="line">    j = high;<span class="comment">//快排区间； </span></span><br><span class="line">    tmp = num[low];   <span class="comment">//任命为中间分界线，左边比他小，右边比他大,通常第一个元素是基准数</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt; j) &#123;  <span class="comment">//如果下标i大于下标j，函数结束运行</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i != j) &#123;</span><br><span class="line">        <span class="keyword">while</span> (num[j] &gt;= tmp &amp;&amp; j &gt; i) &#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (num[i] &lt;= tmp &amp;&amp; j &gt; i) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j &gt; i) &#123;</span><br><span class="line">            temp = num[j];</span><br><span class="line">            num[j] = num[i];</span><br><span class="line">            num[i] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">//调整完基准数，分为三分区域，i，比i小的，比i大的； 如果有特数需求，可以只排某位后面的，或者前面的； </span></span><br><span class="line">    num[low] = num[i];</span><br><span class="line">    num[i] = tmp;</span><br><span class="line">    quick_sort(num, low, i - <span class="number">1</span>);</span><br><span class="line">    quick_sort(num, i + <span class="number">1</span>, high);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>其它</h1>
<h2 id="KMP">KMP</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">getnext</span><span class="params">(<span class="type">char</span> T[], <span class="type">int</span> next[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">-1</span>;</span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (T[i] != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">-1</span> || T[i] == T[j]) &#123;</span><br><span class="line">            <span class="comment">// i为后缀位置；j为前缀位置</span></span><br><span class="line">            <span class="comment">//如果新的位置匹配成功，那么说明next[k+1]= j+1;</span></span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            j = next[j]; <span class="comment">//若字符不同，则j值回溯</span></span><br><span class="line">        <span class="comment">//这里的回溯是在前j项里面找最大前后缀，而原串在j位置已经匹配了最大前后缀，所以</span></span><br><span class="line">        <span class="comment">//在前缀里面找最大前后缀，等价于找整个原串的新最大前后缀（类似于递归） </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">KMPindex</span><span class="params">(<span class="type">char</span> S[], <span class="type">char</span> T[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, *next;</span><br><span class="line">    next = (<span class="type">int</span> *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * (<span class="built_in">strlen</span>(T) + <span class="number">1</span>));</span><br><span class="line">    getnext(T, next); <span class="comment">//求next</span></span><br><span class="line">    <span class="keyword">while</span> (S[i] != <span class="string">&#x27;\0&#x27;</span> &amp;&amp; T[j] != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (S[i] == T[j]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line"><span class="comment">//j回退到相应位置开始匹配，i不变</span></span><br><span class="line">            (j == <span class="number">0</span>) ? i++ : (j = next[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(next);</span><br><span class="line">    <span class="keyword">if</span> (T[j] == <span class="string">&#x27;\0&#x27;</span>) <span class="comment">//匹配成功，返回匹配位置</span></span><br><span class="line">        <span class="keyword">return</span> i - j;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="快速幂">快速幂</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> <span class="title function_">low_mul</span><span class="params">(<span class="type">long</span> <span class="type">long</span> x, <span class="type">long</span> <span class="type">long</span> y, <span class="type">long</span> <span class="type">long</span> mod)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (y) &#123;</span><br><span class="line">        <span class="keyword">if</span> (y &amp; <span class="number">1</span>)</span><br><span class="line">            sum = (sum + x) % mod;</span><br><span class="line">        x = (x + x) % mod;</span><br><span class="line">        y &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对x*y拆分成为x+x+x。。。。，进行一个加速的取模，</span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> <span class="title function_">quick_mul</span><span class="params">(<span class="type">long</span> <span class="type">long</span> base, <span class="type">long</span> <span class="type">long</span> power, <span class="type">long</span> <span class="type">long</span> p)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> result = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld%lld&quot;</span>, &amp;base, &amp;power, &amp;p);</span><br><span class="line">    <span class="keyword">while</span> (power) &#123;</span><br><span class="line">        <span class="keyword">if</span> (power &amp; <span class="number">1</span>)<span class="comment">//power%2==1</span></span><br><span class="line">            result = (low_mul(result, base, p)) % p;</span><br><span class="line">        base = low_mul(base, base, p) % p;</span><br><span class="line">        power &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//base是底数，power是幂次，p是模数 </span></span><br></pre></td></tr></table></figure>
<h2 id="欧拉筛">欧拉筛</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> not_prime[<span class="number">1005</span>], prime[<span class="number">1005</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= max_num; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!not_prime[i])</span><br><span class="line">            prime[++cnt] = i;</span><br><span class="line">        <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= cnt &amp;&amp; prime[j] &lt;= max_num / i; j++) &#123;</span><br><span class="line">            not_prime[i * prime[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % prime[j] == <span class="number">0</span>)<span class="comment">//注意</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="简易计算器-单位数">简易计算器(单位数)</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 205</span></span><br><span class="line"><span class="type">char</span> stack_ch[MAXSIZE];</span><br><span class="line"><span class="type">char</span> stack_later[MAXSIZE];</span><br><span class="line"><span class="type">char</span> s[MAXSIZE];</span><br><span class="line"><span class="type">int</span> stack_cal[MAXSIZE];</span><br><span class="line"><span class="type">int</span> top_ch = <span class="number">-1</span>, top_la = <span class="number">-1</span>, top_cal = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">priority</span><span class="params">(<span class="type">char</span> c)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="string">&#x27;^&#x27;</span>)<span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;*&#x27;</span> || c == <span class="string">&#x27;/&#x27;</span> || c == <span class="string">&#x27;%&#x27;</span>)<span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;+&#x27;</span> || c == <span class="string">&#x27;-&#x27;</span>)<span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;(&#x27;</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;#&#x27;</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">isEmpty</span><span class="params">(<span class="type">int</span> top)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (top == <span class="number">-1</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">push</span><span class="params">(<span class="type">char</span> <span class="built_in">stack</span>[], <span class="type">int</span> *top, <span class="type">char</span> item)</span> &#123;</span><br><span class="line">    <span class="built_in">stack</span>[++(*top)] = item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">push_int</span><span class="params">(<span class="type">int</span> <span class="built_in">stack</span>[], <span class="type">int</span> *top, <span class="type">int</span> item)</span> &#123;</span><br><span class="line">    <span class="built_in">stack</span>[++(*top)] = item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> <span class="title function_">pop</span><span class="params">(<span class="type">char</span> <span class="built_in">stack</span>[], <span class="type">int</span> *top)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(*top)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error!&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">stack</span>[(*top)--];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pop_int</span><span class="params">(<span class="type">int</span> <span class="built_in">stack</span>[], <span class="type">int</span> *top)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(*top)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error!&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">stack</span>[(*top)--];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">my_power</span><span class="params">(<span class="type">int</span> base, <span class="type">int</span> power)</span> &#123;</span><br><span class="line">    <span class="type">int</span> k = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; power; i++) &#123;</span><br><span class="line">        k *= base;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s);<span class="comment">//读取中缀表达式；</span></span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    top_ch++;</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line"></span><br><span class="line">    stack_ch[top_ch] = <span class="string">&#x27;#&#x27;</span>;<span class="comment">//作为结束符； </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&#x27;0&#x27;</span> &lt;= s[i] &amp;&amp; s[i] &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">            push(stack_later, &amp;top_la, s[i]);<span class="comment">//数字直接入栈； </span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//操作符 </span></span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;(&#x27;</span>) &#123;<span class="comment">//入栈； </span></span><br><span class="line">                push(stack_ch, &amp;top_ch, s[i]);<span class="comment">//左括号直接入栈； </span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;)&#x27;</span>) &#123;<span class="comment">//依次弹出直到&#x27;(&#x27;,而且删除左括号； </span></span><br><span class="line">                ch = pop(stack_ch, &amp;top_ch);<span class="comment">//从符号栈弹出 </span></span><br><span class="line">                <span class="keyword">while</span> (ch != <span class="string">&#x27;(&#x27;</span> &amp;&amp; ch != <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">                    push(stack_later, &amp;top_la, ch);<span class="comment">//进入后缀栈； </span></span><br><span class="line">                    ch = pop(stack_ch, &amp;top_ch);<span class="comment">//当它是左括号时退出，top_ch指向左括号前面一个位置 </span></span><br><span class="line">                &#125;</span><br><span class="line">                stack_ch[top_ch + <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;<span class="comment">//删除左括号（不知道这样需不需要） </span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;^&#x27;</span>) &#123;<span class="comment">//幂直接入符号栈 </span></span><br><span class="line">                push(stack_ch, &amp;top_ch, s[i]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//最难部分，各种不同优先级操作字符； </span></span><br><span class="line">                <span class="keyword">if</span> (priority(s[i]) &gt; priority(stack_ch[top_ch])) &#123;<span class="comment">//新操作符优先级高于栈顶，直接入栈； </span></span><br><span class="line">                    push(stack_ch, &amp;top_ch, s[i]);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;<span class="comment">//否则依次弹出，直至优先级比它低，或者左括号；然后再进栈； </span></span><br><span class="line">                    ch = pop(stack_ch, &amp;top_ch);</span><br><span class="line">                    <span class="keyword">while</span> (priority(ch) &gt;= priority(s[i]) || ch != <span class="string">&#x27;(&#x27;</span>) &#123;<span class="comment">//低，或者左括号作为退出条件； </span></span><br><span class="line">                        push(stack_later, &amp;top_la, ch);</span><br><span class="line">                        ch = stack_ch[top_ch];</span><br><span class="line">                        <span class="keyword">if</span> (ch == <span class="string">&#x27;(&#x27;</span>) &#123;<span class="comment">//；入栈新操作符，然后跳出 </span></span><br><span class="line">                            push(stack_ch, &amp;top_ch, s[i]);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (priority(ch) &lt; priority(s[i])) &#123;</span><br><span class="line">                            push(stack_ch, &amp;top_ch, s[i]);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;<span class="comment">//说明无法跳出； </span></span><br><span class="line">                            ch = pop(stack_ch, &amp;top_ch);<span class="comment">//继续弹出操作符； </span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (stack_ch[top_ch] != <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">        ch = pop(stack_ch, &amp;top_ch);</span><br><span class="line">        push(stack_later, &amp;top_la, ch);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">///到这里就是后缀表达式； </span></span><br><span class="line">    <span class="comment">//printf(&quot;%s&quot;,stack_later);</span></span><br><span class="line">    <span class="comment">//遍历一遍后缀表达式 </span></span><br><span class="line">    <span class="type">int</span> len_la = <span class="built_in">strlen</span>(stack_later);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len_la; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&#x27;0&#x27;</span> &lt;= stack_later[i] &amp;&amp; stack_later[i] &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;<span class="comment">//是数字，入数字栈 </span></span><br><span class="line">            push_int(stack_cal, &amp;top_cal, stack_later[i] - <span class="string">&#x27;0&#x27;</span>);<span class="comment">//入栈 </span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//遇到操作符，第二个出栈数字   操作。。。 第一个出栈数字 </span></span><br><span class="line">            <span class="type">int</span> num1 = pop_int(stack_cal, &amp;top_cal);</span><br><span class="line">            <span class="type">int</span> num2 = pop_int(stack_cal, &amp;top_cal);<span class="comment">//弹出两个数字； </span></span><br><span class="line">            <span class="keyword">switch</span> (stack_later[i]) &#123;<span class="comment">//计算结果入栈 </span></span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                    push_int(stack_cal, &amp;top_cal, num2 + num1);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                    push_int(stack_cal, &amp;top_cal, num2 - num1);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                    push_int(stack_cal, &amp;top_cal, num2 * num1);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">                    push_int(stack_cal, &amp;top_cal, num2 / num1);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;%&#x27;</span>:</span><br><span class="line">                    push_int(stack_cal, &amp;top_cal, num2 % num1);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;^&#x27;</span>:</span><br><span class="line">                    push_int(stack_cal, &amp;top_cal, my_power(num2, num1));</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, stack_cal[top_cal]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="简易计算器-多位数">简易计算器(多位数)</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 205</span></span><br><span class="line"><span class="type">char</span> stack_ch[MAXSIZE];<span class="comment">//操作符临时栈 </span></span><br><span class="line"><span class="type">char</span> stack_later[MAXSIZE];<span class="comment">//操作符号最终栈； </span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> stack_num[MAXSIZE];<span class="comment">//数字栈； </span></span><br><span class="line"><span class="type">char</span> s[MAXSIZE];<span class="comment">//初始读取数组； </span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> stack_cal[MAXSIZE];<span class="comment">//计算栈；</span></span><br><span class="line"><span class="type">int</span> flag_sign[MAXSIZE];<span class="comment">//记录顺序数组，1表示这里使用数字栈，2表示使用符号栈 </span></span><br><span class="line"><span class="type">int</span> top_ch = <span class="number">-1</span>, top_num = <span class="number">-1</span>, top_cal = <span class="number">-1</span>, top_la = <span class="number">-1</span>;</span><br><span class="line"><span class="type">int</span> cnt_sign = <span class="number">0</span>;<span class="comment">//记录对应使用的栈的种类； </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">priority</span><span class="params">(<span class="type">char</span> c)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="string">&#x27;^&#x27;</span>)<span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;*&#x27;</span> || c == <span class="string">&#x27;/&#x27;</span> || c == <span class="string">&#x27;%&#x27;</span>)<span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;+&#x27;</span> || c == <span class="string">&#x27;-&#x27;</span>)<span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;(&#x27;</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;#&#x27;</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">isEmpty</span><span class="params">(<span class="type">int</span> top)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (top == <span class="number">-1</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">push_ch</span><span class="params">(<span class="type">char</span> <span class="built_in">stack</span>[], <span class="type">int</span> *top, <span class="type">char</span> item)</span> &#123;<span class="comment">//入字符栈 </span></span><br><span class="line">    <span class="built_in">stack</span>[++(*top)] = item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">push_num</span><span class="params">(<span class="type">long</span> <span class="type">long</span> <span class="built_in">stack</span>[], <span class="type">int</span> *top, <span class="type">long</span> <span class="type">long</span> item)</span> &#123;<span class="comment">//入数字栈 </span></span><br><span class="line">    <span class="built_in">stack</span>[++(*top)] = item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> <span class="title function_">pop_ch</span><span class="params">(<span class="type">char</span> <span class="built_in">stack</span>[], <span class="type">int</span> *top)</span> &#123;<span class="comment">//弹出符号栈 </span></span><br><span class="line">    <span class="keyword">if</span> (isEmpty(*top)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error!&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">stack</span>[(*top)--];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> <span class="title function_">pop_num</span><span class="params">(<span class="type">long</span> <span class="type">long</span> <span class="built_in">stack</span>[], <span class="type">int</span> *top)</span> &#123;<span class="comment">//弹出数字栈 </span></span><br><span class="line">    <span class="keyword">if</span> (isEmpty(*top)) &#123;</span><br><span class="line">        <span class="comment">//printf(&quot;error!&quot;);</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//解决负号问题； </span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">stack</span>[(*top)--];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">my_power</span><span class="params">(<span class="type">long</span> <span class="type">long</span> base, <span class="type">long</span> <span class="type">long</span> power)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> k = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; power; i++) &#123;</span><br><span class="line">        k *= base;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s);<span class="comment">//读取中缀表达式；//此处不修改 </span></span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    top_ch++;</span><br><span class="line">    stack_ch[top_ch] = <span class="string">&#x27;#&#x27;</span>;<span class="comment">//作为结束符；//不修改 </span></span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> tmp = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> flag_num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;<span class="comment">//b遍历所有输入的字符； </span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&#x27;0&#x27;</span> &lt;= s[i] &amp;&amp; s[i] &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;<span class="comment">//读取到数字，准备转换这个字符，变成多位（单位）数字； </span></span><br><span class="line">            tmp *= <span class="number">10</span>;</span><br><span class="line">            tmp += s[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            flag_num = <span class="number">1</span>; <span class="comment">//标记数字； </span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//操作符</span></span><br><span class="line">            <span class="comment">//说明要中断数字读取</span></span><br><span class="line">            <span class="keyword">if</span> (flag_num == <span class="number">1</span>) &#123;<span class="comment">//标记成功，之前有数字需要转换； </span></span><br><span class="line">                push_num(stack_num, &amp;top_num, tmp); <span class="comment">//入数字栈，并且清除各种标记；</span></span><br><span class="line">                flag_num = <span class="number">0</span>;</span><br><span class="line">                tmp = <span class="number">0</span>;</span><br><span class="line">                flag_sign[cnt_sign++] = <span class="number">1</span>;<span class="comment">//是数字标记 </span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;(&#x27;</span>) &#123;<span class="comment">//入临时符号栈 </span></span><br><span class="line">                push_ch(stack_ch, &amp;top_ch, s[i]);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;)&#x27;</span>) &#123;<span class="comment">//依次弹出直到&#x27;(&#x27;,而且删除左括号； </span></span><br><span class="line">                ch = pop_ch(stack_ch, &amp;top_ch);<span class="comment">//从临时符号栈弹出， </span></span><br><span class="line">                <span class="keyword">while</span> (ch != <span class="string">&#x27;(&#x27;</span> &amp;&amp; ch != <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">                    push_ch(stack_later, &amp;top_la, ch);<span class="comment">//进入最终栈；</span></span><br><span class="line">                    flag_sign[cnt_sign++] = <span class="number">2</span>;<span class="comment">//是操作符标记  </span></span><br><span class="line">                    ch = pop_ch(stack_ch, &amp;top_ch);<span class="comment">//当它是左括号时退出，top_ch指向左括号前面一个位置 </span></span><br><span class="line">                &#125;</span><br><span class="line">                stack_ch[top_ch + <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;<span class="comment">//删除左括号（不知道这样需不需要） </span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;^&#x27;</span>) &#123;<span class="comment">//幂直接入临时符号栈 </span></span><br><span class="line">                push_ch(stack_ch, &amp;top_ch, s[i]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//最难部分，各种不同优先级操作字符； </span></span><br><span class="line">                <span class="keyword">if</span> (priority(s[i]) &gt; priority(stack_ch[top_ch])) &#123;<span class="comment">//新操作符优先级高于临时栈栈顶，直接入临时栈； </span></span><br><span class="line">                    push_ch(stack_ch, &amp;top_ch, s[i]);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;<span class="comment">//否则依次弹出到最终栈，直至优先级比它低，或者左括号；然后再进临时栈； </span></span><br><span class="line">                    ch = pop_ch(stack_ch, &amp;top_ch);</span><br><span class="line">                    <span class="keyword">while</span> (priority(ch) &gt;= priority(s[i]) || ch != <span class="string">&#x27;(&#x27;</span>) &#123;<span class="comment">//低，或者左括号作为退出条件； </span></span><br><span class="line">                        push_ch(stack_later, &amp;top_la, ch);</span><br><span class="line">                        flag_sign[cnt_sign++] = <span class="number">2</span>;<span class="comment">//是操作符标记 </span></span><br><span class="line">                        ch = stack_ch[top_ch];</span><br><span class="line">                        <span class="keyword">if</span> (ch == <span class="string">&#x27;(&#x27;</span>) &#123;<span class="comment">//；入栈新操作符，然后跳出 </span></span><br><span class="line">                            push_ch(stack_ch, &amp;top_ch, s[i]);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (priority(ch) &lt; priority(s[i])) &#123;</span><br><span class="line">                            push_ch(stack_ch, &amp;top_ch, s[i]);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;<span class="comment">//说明无法跳出； </span></span><br><span class="line">                            ch = pop_ch(stack_ch, &amp;top_ch);<span class="comment">//继续弹出操作符； </span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//可能有末尾数字没录进去，</span></span><br><span class="line">    <span class="keyword">if</span> (flag_num == <span class="number">1</span>) &#123;</span><br><span class="line">        push_num(stack_num, &amp;top_num, tmp);</span><br><span class="line">        flag_sign[cnt_sign++] = <span class="number">1</span>;<span class="comment">//是数字标记 </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (stack_ch[top_ch] != <span class="string">&#x27;#&#x27;</span>) &#123;<span class="comment">//临时字符栈里面全部弹出到最终栈，并且标记顺序； </span></span><br><span class="line">        ch = pop_ch(stack_ch, &amp;top_ch);</span><br><span class="line">        push_ch(stack_later, &amp;top_la, ch);</span><br><span class="line">        flag_sign[cnt_sign++] = <span class="number">2</span>;<span class="comment">//是操作符标记 </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//到这里所有操作符都在stack_la里面，所有数字都在stack_num里面，有flag_sign数组存取各个操作符应该出现的顺序 </span></span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>, k = <span class="number">0</span>;<span class="comment">//j代表数字栈的下标，k代表符号栈的下标； </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; cnt_sign; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (flag_sign[i] == <span class="number">1</span>) &#123;<span class="comment">//是数字，入数字栈 </span></span><br><span class="line">            push_num(stack_cal, &amp;top_cal, stack_num[j++]);<span class="comment">//入计算栈 </span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (flag_sign[i] == <span class="number">2</span>) &#123;<span class="comment">//遇到操作符，第二个出栈数字   操作。。。 第一个出栈数字 </span></span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> num1 = pop_num(stack_cal, &amp;top_cal);</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> num2 = pop_num(stack_cal, &amp;top_cal);<span class="comment">//弹出两个数字； </span></span><br><span class="line">            <span class="keyword">switch</span> (stack_later[k++]) &#123;<span class="comment">//计算结果入栈 </span></span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                    push_num(stack_cal, &amp;top_cal, num2 + num1);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                    push_num(stack_cal, &amp;top_cal, num2 - num1);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                    push_num(stack_cal, &amp;top_cal, num2 * num1);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">                    push_num(stack_cal, &amp;top_cal, num2 / num1);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;%&#x27;</span>:</span><br><span class="line">                    push_num(stack_cal, &amp;top_cal, num2 % num1);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;^&#x27;</span>:</span><br><span class="line">                    push_num(stack_cal, &amp;top_cal, my_power(num2, num1));</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>, stack_cal[top_cal]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>c语言</category>
      </categories>
      <tags>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>typedef介绍</title>
    <url>/2023/03/23/typedef%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<span id="more"></span>
<ul>
<li>
<p><em><strong>typedef解释</strong></em></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">link</span>;</span></span><br><span class="line">&#125;<span class="comment">//通常使用这种方法创建链表结点，但是每次使用&quot;结点&quot;，我们都需要敲出&quot;struct node&quot;</span></span><br><span class="line"> <span class="comment">//同样，使用自引用指针需要&quot;struct node *&quot;，非常的麻烦，而且在一个c语言文件中不只有一类结点时非常混乱</span></span><br></pre></td></tr></table></figure>
<p>基于此我们引入&quot;typedef&quot;,typedef 类似于重命名操作，和&quot;define&quot;非常相似</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> max 1000 <span class="comment">//这里我们把max&quot;转换&quot;成1000(本人菜菜，想不到专业的话来解释，因此使用“转换”一词)</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> elementType <span class="comment">//这里我们使用 typedef 重命名 int 为 elementType</span></span><br><span class="line"><span class="comment">//typedef 的作用对象一般是&quot;类型&quot;，</span></span><br><span class="line">    <span class="comment">//类型包含系统自带的类型：char, short, int, long, long long, float, double等等</span></span><br><span class="line">    <span class="comment">//也包含用户自定义的类型：结构体</span></span><br><span class="line"><span class="comment">//考虑链表结点的创建</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">link</span>;</span></span><br><span class="line">&#125;<span class="comment">//这里的struct node就是用户自定义类型，因此可以使用typedef进行&quot;改名&quot;操作</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">link</span>;</span><span class="comment">//到这一步还未完成重命名操作，因此不可以用重命名之后的指针来替换struct node *</span></span><br><span class="line">&#125;Node,*Nodeptr;<span class="comment">//一般把重命名的名字写在大括号后面。</span></span><br><span class="line"><span class="comment">//这里的操作可以解释为以下两条语句</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> <span class="title">Node</span>;</span><span class="comment">//Node 表示struct node</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> * <span class="title">Nodeptr</span>;</span><span class="comment">//Nodeptr 表示struct node *</span></span><br><span class="line"><span class="comment">//考虑如下代码</span></span><br><span class="line"><span class="type">int</span> *a, b;<span class="comment">//这里的a是int*型的指针，而b是int整型</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">a</span>, <span class="title">b</span>;</span><span class="comment">//这里a是struct node *型的指针，b却是自定义类型struct node;</span></span><br><span class="line">Nodeptr a, b;<span class="comment">//这里用Nodeptr表示struct node *,不是简单的替换关系，a和b都是struct node* 型的指针。</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>c语言</category>
      </categories>
      <tags>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>其它算法</title>
    <url>/2023/03/27/%E5%85%B6%E5%AE%83%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<ul>
<li>本文所有内容均出自微信公众号&quot;labuladong&quot;,公众号本身代码均以java代码块形式呈现，本文将以c语言呈现。文章类似转载，但是已经声明出处，并修改代码为c语言，此内容主要是记录博主自身学习过程，有疑惑建议翻看原文</li>
</ul>
<span id="more"></span>
<ul>
<li>写在结尾: 再次鸣谢公众号&quot;labuladong&quot;,公众号中有很多写的优质的文章和资源，对于部分算法也有着非常透彻的分析，对于本菜菜的学习有着非常大的帮助。</li>
</ul>
<p><a href="https://mp.weixin.qq.com/s/GOOgO5Wp48jM9jSPzqJwOQ">原作者labuladong</a></p>
]]></content>
      <tags>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>树状数组和线段树</title>
    <url>/2023/03/27/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E5%92%8C%E7%BA%BF%E6%AE%B5%E6%A0%91/</url>
    <content><![CDATA[<p>s作者平时喜欢看看各种奇妙的算法，似走马观花，什么都只懂个大概，以至于在蓝桥杯中那重要的20分，让我以为我能现场搓出线段树，然后终究是学艺不精，痛失也许本就不属于我，但是我又碰巧看过线段树，所以也算是属于我的20分，可能这20分在后面的拿奖起到关键作用，然而终究已经结束，后悔于不争气的自己，偷懒的自己，于是决定写本篇文章细锁线段树和树状数组</p>
<span id="more"></span>
<ul>
<li>特别鸣谢<a href="https://blog.csdn.net/weixin_45697774/article/details/104274713?ops_request_misc=%7B%22request%5Fid%22%3A%22168101067816800217234046%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=168101067816800217234046&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-104274713-null-null.142%5Ev82%5Einsert_down38,201%5Ev4%5Eadd_ask,239%5Ev2%5Einsert_chatgpt&amp;utm_term=%E7%BA%BF%E6%AE%B5%E6%A0%91&amp;spm=1018.2226.3001.4187">线段树 从入门到进阶（超清晰，简单易懂）_线段树进阶_繁凡さん的博客-CSDN博客</a></li>
</ul>
<p>原文对线段树作了非常透彻的分析和解释，清楚讲出了关于线段树甚至是关于树状数组的相关操作。</p>
]]></content>
      <tags>
        <tag>c语言</tag>
        <tag>算法</tag>
        <tag>线段树</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划</title>
    <url>/2023/03/27/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<ul>
<li>本文为作者的动态规划学习的历程，部分内容选自公众号labuladong，部分来自洛谷刷题时或者是平常作业中遇到的问题，进而在csdn的优质文章中学习或者是洛谷的题解中学习。文中各种dp并不按照广义的学习路线设置，属于作者自身的一个学习过程</li>
</ul>
<span id="more"></span>
<h3 id="四维dp问题">四维dp问题</h3>
<p>动态规划问题通常为一维或者二维，很少出现四维。</p>
<p>对于四维dp，有如下几个特点，</p>
<ul>
<li>dp范围非常小，通常在10~50左右，保证在O(n^4)时间内能够解决。</li>
<li>无法拆分成为两个二维，第一个二维能取到最优解，但是在此前提下，第二个二维dp只能取到局部最优，两者的和并不一定是全局最优解。</li>
<li>根据题目信息可以归纳出四维之间的特殊关系</li>
</ul>
<p>下面举两个例子来进行说明</p>
<ol>
<li><a href="https://www.luogu.com.cn/problem/P1004">洛谷p1004</a></li>
</ol>
<p>题目要求在<code>n*n</code>的方格中从左上角取到左下角取两次，计算两次取数的最大结果</p>
<p>分析：定义<code>dp[i][j][k][p]</code>为第一次到达ij，第二次到达kp位置时的总数值，对于每一个点，只能从其左侧一格或者上侧一格到达。对于两次取数的两种状态，一共有四种综合转移情况</p>
<p>因此我们可以考虑状态转移方程</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>p</mi><mo stretchy="false">]</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>k</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>p</mi><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>p</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>k</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>p</mi><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>p</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">)</mo><mo>+</mo><mi>m</mi><mi>a</mi><mi>p</mi><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>p</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dp[i][j][k][p]=max(dp[i-1][j][k-1][p],dp[i-1][j][k][p-1],dp[i][j-1][k-1][p],dp[i][j-1][k][p-1])+map[k][p]
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal">p</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal">p</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal">p</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">])</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">ma</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal">p</span><span class="mclose">]</span></span></span></span></span></p>
<p>我们来分析这个方程，四种位置变化的组合，最后加上对于转移到<code>(k,p)</code>点的数值<code>map[k][p]</code></p>
<p>也许你会有疑惑为什么不加上转移到<code>(i,j)</code>点的数值<code>map[i][j]</code>;	别急，听我慢慢解释</p>
<p>两次移动虽然用一个方程表示，但是实质上是两次取数的过程，第一个人从左上到右下取完之后才进行第二个人取数（第一个人取过的位置都会变成0，但是对于我们的dp过程，我们不方便将<code>map[][]</code>的某一个位置的数值变成0）</p>
<p>但是不论如何取数，即使两个人的位置有重合，对于重合点的数值<code>map[][]</code>,我们都可以都只加一次，也就是加上<code>map[k][p]</code>,而对于<code>map[i][j]</code>,我们将讨论相关条件来决定是否加入。</p>
<p>对于状态转移之后，也就是<code>dp[i][j][k][p]</code>点，表示已经到达这个状态的最大数值，那么到达此状态之后，我们可以将次状态分为两种情况</p>
<ol>
<li>点<code>(i,j)和(k,p)</code>重合，那么意味着我们只用将这个点的数值计算一次，也就是<code>map[k][p]</code>,不用考虑<code>map[i][j]</code>；</li>
<li>点<code>(i,j)和(k,p)</code>不重合，对于点<code>(k,p)</code>我们计算了其数值<code>map[k][p]</code>,那么对于到达点<code>(i,j)</code>的数值<code>map[i][j]</code>没有计算，那么我们只需要加上<code>map[i][j]</code>即可；</li>
</ol>
<p>到此状态转移方程分析结束，代码如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="built_in">map</span>[<span class="number">11</span>][<span class="number">11</span>];</span><br><span class="line"><span class="type">int</span> dp[<span class="number">11</span>][<span class="number">11</span>][<span class="number">11</span>][<span class="number">11</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//freopen(&quot;a.in&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line">    <span class="comment">//freopen(&quot;a.out&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> x, y, z;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;x, &amp;y, &amp;z);</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">0</span> &amp;&amp; y == <span class="number">0</span> &amp;&amp; z == <span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">map</span>[x][y] = z;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n; k++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> p = <span class="number">1</span>; p &lt;= n; p++) &#123;</span><br><span class="line">                    dp[i][j][k][p] = max(dp[i][j][k][p], dp[i - <span class="number">1</span>][j][k - <span class="number">1</span>][p] + <span class="built_in">map</span>[k][p]);</span><br><span class="line">                    dp[i][j][k][p] = max(dp[i][j][k][p], dp[i - <span class="number">1</span>][j][k][p - <span class="number">1</span>] + <span class="built_in">map</span>[k][p]);</span><br><span class="line">                    dp[i][j][k][p] = max(dp[i][j][k][p], dp[i][j - <span class="number">1</span>][k - <span class="number">1</span>][p] + <span class="built_in">map</span>[k][p]);</span><br><span class="line">                    dp[i][j][k][p] = max(dp[i][j][k][p], dp[i][j - <span class="number">1</span>][k][p - <span class="number">1</span>] + <span class="built_in">map</span>[k][p]);</span><br><span class="line">                    <span class="keyword">if</span> (i != k || j != p)dp[i][j][k][p] += <span class="built_in">map</span>[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, dp[n][n][n][n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><a href="https://www.luogu.com.cn/problem/P1006">洛谷p1006</a></li>
</ol>
<p>这道题和上面的方格取数有很大的相似处，但是也有部分不同，两个人的路径无法交叉,矩阵大小<strong>m行n列</strong></p>
<p>分析：路径无法交叉，意味着从左上角的同一点出发时就只能一个人向下并且到达右下顶点的左侧，一个人向右迈出第一步并且到达右下顶点的上侧；</p>
<p><img src="https://soybeanlittlecar.oss-cn-beijing.aliyuncs.com/blog/%E4%BC%A0%E7%BA%B8%E6%9D%A1-1.png" alt=""></p>
<p>这里是对于起始点和终点的判定防止交叉;	这里我们假定开始向下的为第一个人，向右的是第二个人</p>
<p>同理我们定义<code>dp[i][j][k][p]</code>表示第一个人到达<code>[i][j]</code>，第二个人到达<code>[k][p]</code>位置时的数值（好感度）总和</p>
<p>考虑第一个人，他能涉及的区域应该为矩形<code>左上角(1,1),右下角(m,n-1)</code>，因此外层循环如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n<span class="number">-1</span>; j++) &#123;</span><br><span class="line">            <span class="comment">//balabala</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然状态转移考虑的时候我们考虑两个人同时进行位置改变，但是实质上是第一个人到达<code>(i,j)</code>，在此前提之下，因为事实情况是第一个人已经到达这个确定的位置（这个位置已经是合法的了），那么说明第二个人的路径没有和第一个人当前的路径有重合，我们再来考虑第二个人，因为不能有路径交叉，第一个人的考虑范围为矩形<code>左上角(1,j+1)，右下角(m-1,n)</code>;</p>
<p>因为这个<code>(i,j)</code>能涉及的范围包括整个矩形<code>(1,1),(i,j)</code>;所以让<code>p&gt;j</code>即可保证无重合;状态转移方程如下</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>p</mi><mo stretchy="false">]</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>k</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>p</mi><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>p</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>k</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>p</mi><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>p</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">)</mo><mo>+</mo><mi>m</mi><mi>a</mi><mi>p</mi><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>p</mi><mo stretchy="false">]</mo><mo>+</mo><mi>m</mi><mi>a</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dp[i][j][k][p]=max(dp[i-1][j][k-1][p],dp[i-1][j][k][p-1],dp[i][j-1][k-1][p],dp[i][j-1][k][p-1])+map[k][p]+map[i][j]
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal">p</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal">p</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal">p</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">])</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">ma</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal">p</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">ma</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span></span></p>
<p>整体代码如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="built_in">map</span>[<span class="number">53</span>][<span class="number">53</span>];</span><br><span class="line"><span class="type">int</span> dp[<span class="number">52</span>][<span class="number">52</span>][<span class="number">52</span>][<span class="number">52</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;m, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;<span class="built_in">map</span>[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= m - <span class="number">1</span>; k++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> p = <span class="number">1</span> + j; p &lt;= n; p++) &#123;</span><br><span class="line">                    dp[i][j][k][p] = max(dp[i][j][k][p], dp[i - <span class="number">1</span>][j][k - <span class="number">1</span>][p] + <span class="built_in">map</span>[k][p] + <span class="built_in">map</span>[i][j]);</span><br><span class="line">                    dp[i][j][k][p] = max(dp[i][j][k][p], dp[i - <span class="number">1</span>][j][k][p - <span class="number">1</span>] + <span class="built_in">map</span>[k][p] + <span class="built_in">map</span>[i][j]);</span><br><span class="line">                    dp[i][j][k][p] = max(dp[i][j][k][p], dp[i][j - <span class="number">1</span>][k - <span class="number">1</span>][p] + <span class="built_in">map</span>[k][p] + <span class="built_in">map</span>[i][j]);</span><br><span class="line">                    dp[i][j][k][p] = max(dp[i][j][k][p], dp[i][j - <span class="number">1</span>][k][p - <span class="number">1</span>] + <span class="built_in">map</span>[k][p] + <span class="built_in">map</span>[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, dp[m][n - <span class="number">1</span>][m - <span class="number">1</span>][n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里是四维，但是仔细想一下，从左上角到右下角，因为两人路径互不干扰，因此可以假设两人同时进行，步数一样</p>
<p>那么可以得到方程	<code>i+j=p+q</code>,因此只需要枚举三个坐标i，j，k即可得到第四个坐标q（q从j+1开始），降低阶数到3阶；</p>
<h3 id="背包问题">背包问题</h3>
<h4 id="01背包">01背包</h4>
<p>​	有n件物品，每一件物品有对应的价值value和重量weight，有背包最大容量max，如何选取物品，在不超过背包容量的情况下取得最大的总价值</p>
<p>​	分析：我们可以定义<code>dp[i][j]</code>为考虑前i件物品，背包容量为j，能装下的最大价值</p>
<p>​	在前i-1件物品考虑完的情况下，我们考虑第i件物品，对应的<code>value[i]和weight[i]</code>,</p>
<ul>
<li>如果背包此时的<code>j&lt;weight[i]</code>，那么无法装下第i件物品，那么考虑前i件物品和考虑前i-1件物品的价值是一样的，状态转移方程为：</li>
</ul>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dp[i][j]=dp[i-1][j]
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span></span></p>
<ul>
<li>如果背包装得下，也就是<code>j&gt;weight[i]</code>，那么此时有两种取向，装第i件商品和不装第i件商品，取两者的最大值，状态转移方程为：</li>
</ul>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mi>w</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">]</mo><mo>+</mo><mi>v</mi><mi>a</mi><mi>l</mi><mi>u</mi><mi>e</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">dp[i][j]=max(dp[i][j],dp[i-1][j-weight[i]]+value[i])
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal">e</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">h</span><span class="mord mathnormal">t</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">u</span><span class="mord mathnormal">e</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">])</span></span></span></span></span></p>
<p>因此代码如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> max_num 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> max_weight 200</span></span><br><span class="line"><span class="type">int</span> weight[<span class="number">202</span>], value[<span class="number">202</span>];</span><br><span class="line"><span class="type">int</span> dp[max_num][max_weight];<span class="comment">//dp[i][j]表示考虑前i件商品，有j的容量能取到的最大价值 </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> n, m;<span class="comment">//m就是定义的最大容量 </span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;weight[i], &amp;value[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &lt; weight[i])dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = max(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - weight[i]] + value[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, dp[n][m]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>优化：滚动数组（后面有时间再写详细优化解释）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> dp[max_weight];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = m; j &gt;= weight[i]; j--) &#123;</span><br><span class="line">		dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="多重背包">多重背包</h4>
<p>​	对于n件商品，每一件对应有价值value和weight，每一件商品有num件，对于容量为max的背包，如何选取商品获得最大价值</p>
<p>​	分析：将每一件商品的num件都进行拆解，转换成数据量更大的01背包问题，问题在于，数据量更大可能超时，因此需要进行优化</p>
<p>​	考虑这样一个问题，对于一种商品的num件，我们可以选取任意件，但是有没有更好的方法表示这任意件商品呢？</p>
<p>​	这里我们讨论关于<strong>二进制优化</strong>，给你一个数字k，你可以将其表示成为</p>
<p>​    <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>=</mo><mn>1</mn><mo>+</mo><mn>2</mn><mo>+</mo><mn>4</mn><mo>+</mo><mn>8</mn><mo>+</mo><mn>16</mn><mo>+</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>+</mo><msup><mn>2</mn><mi>m</mi></msup><mo>+</mo><mi>t</mi></mrow><annotation encoding="application/x-tex">k=1+2+4+8+16+......+2^m+t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">8</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">16</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord">......</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7477em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">t</span></span></span></span>;这里的m取最大值，然后剩余一个数字t，举个例子：</p>
<ul>
<li>27=1+2+4+8+12；</li>
<li>49=1+2+4+8+16+17；</li>
<li>235=1+2+4+8+16+32+64+108；</li>
</ul>
<p>这样有什么用呢？		对于数字27，原来数字15=1*15（需要15个1来表示15），现在可以<strong>压缩</strong>成15=1+2+12；	11=1+2+8；</p>
<p>也就是对于数字的分解<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>=</mo><mn>1</mn><mo>+</mo><mn>2</mn><mo>+</mo><mn>4</mn><mo>+</mo><mn>8</mn><mo>+</mo><mn>16</mn><mo>+</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>+</mo><msup><mn>2</mn><mi>m</mi></msup><mo>+</mo><mi>t</mi></mrow><annotation encoding="application/x-tex">k=1+2+4+8+16+......+2^m+t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">8</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">16</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord">......</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7477em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">t</span></span></span></span>，对于任意小于等于k的数字q，q可以用k的分解数字组合而成，从而进行<strong>压缩</strong></p>
<p>这样我们也可以对num件同样的物品进行<strong>二进制压缩</strong>，把每个压缩的数字作为一个整体的新的物品</p>
<p>代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> max_num 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> max_weight 200</span></span><br><span class="line"><span class="type">int</span> weight[<span class="number">202</span>], value[<span class="number">202</span>];</span><br><span class="line"><span class="type">int</span> dp[max_num][max_weight];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="type">int</span> v, w, num;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;v, &amp;w, &amp;num);</span><br><span class="line">        <span class="comment">//对num进行2进制拆解，1，2，4，8，16 .........以及一个无法继续取到的余数</span></span><br><span class="line">        <span class="type">int</span> k = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (k &lt;= num) &#123;</span><br><span class="line">            value[cnt] = v * k;</span><br><span class="line">            weight[cnt++] = w * k;</span><br><span class="line">            num -= k;</span><br><span class="line">            k &lt;&lt;= <span class="number">1</span>;<span class="comment">//k乘以2</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            value[cnt] = v * num;</span><br><span class="line">            weight[cnt++] = w * num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">//那么就是前cnt件商品</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= cnt - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &lt; weight[i])dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = max(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - weight[i]] + value[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, dp[cnt][m]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="分组背包">分组背包</h4>
<p>一共有m组物品，每一组物品对应有s[i]个，对应每个物体有value和weight；背包容量为max，每一组物品中最多只能选择一个，如何选取获得最大的价值</p>
<p>分析：与01背包的差别在于，每一组的个数更多了，因此原来的考虑第i个物品，变成了考虑第i组物品</p>
<p>我们依然定义<code>dp[i][j]</code>为前i组物品，j容量对应的最大价值。</p>
<p>我们来考虑第i组物品，一共有s[i]个，假设不取i组的物品</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo separator="true">;</mo></mrow><annotation encoding="application/x-tex">dp[i][j]=dp[i-1][j];
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mpunct">;</span></span></span></span></span></p>
<p>然后再依次考虑第i组所有物品对应的情况，遍历该组的每一个物品，考虑其取与不取对应的最大价值</p>
<p>当然需要前提判断，当前容量j能够放下我们考虑的物品，<code>if(j&gt;=s[i][k])</code>,第i组的第k个物品</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mi>w</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo><mo stretchy="false">]</mo><mo>+</mo><mi>v</mi><mi>a</mi><mi>l</mi><mi>u</mi><mi>e</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">dp[i][j]=max(dp[i][j],dp[i-1][j-weight[i][k]]+value[i][k])
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal">e</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">h</span><span class="mord mathnormal">t</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">]]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">u</span><span class="mord mathnormal">e</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">])</span></span></span></span></span></p>
<p>因此代码如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> max_num 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> max_weight 200</span></span><br><span class="line"><span class="type">int</span> weight[<span class="number">100</span>][max_weight], value[<span class="number">100</span>][max_num];</span><br><span class="line"><span class="type">int</span> s[<span class="number">100</span>];<span class="comment">//表示每一组有多少个物品</span></span><br><span class="line"><span class="type">int</span> dp[<span class="number">100</span>][max_weight];<span class="comment">//前i组，最大价值 </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;s[i]);<span class="comment">//有很多个组，每个组最多只能选择一个物品 </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= s[i]; j++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;value[i][j], &amp;weight[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            dp[i][j] = dp[i - <span class="number">1</span>][j];<span class="comment">//不选第i组，从前i-1组里面选择</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= s[i]; k++) &#123;<span class="comment">//遍历第i组的所有物品 </span></span><br><span class="line">                <span class="keyword">if</span> (j &gt;= weight[i][k])</span><br><span class="line">                    dp[i][j] = max(dp[i][j], dp[i - <span class="number">1</span>][j - weight[i][k]] + value[i][k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, dp[n][m]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="完全背包">完全背包</h4>
<p>一共有n种物品，每个物品有无限个，对应有value和weight，背包容量为max，求解取到的最大价值</p>
<p>分析：如果我们把每一种物品的无限数量进行拆分，依然是01背包问题，或者是多重背包问题（只是这里无上限，不好进行优化），我们只需要在01背包基础上枚举每一种物品取的数量k即可，代码如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> max_num 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> max_weight 200</span></span><br><span class="line"><span class="type">int</span> weight[<span class="number">202</span>], value[<span class="number">202</span>];</span><br><span class="line"><span class="type">int</span> dp[<span class="number">100</span>][<span class="number">200</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这里看作01背包</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= max_weight; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k * weight[i] &lt;= j; k++) &#123;</span><br><span class="line">                dp[i][j] = max(dp[i][j], dp[i - <span class="number">1</span>][j - k * weight[i]] + k * value[i]);</span><br><span class="line">            &#125;<span class="comment">//去遍历对于每件商品的所有取值情况，取最大的价值的情况作为结果</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来我们仔细分析这段代码，显然发现</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mi>k</mi><mo>∗</mo><mi>w</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">]</mo><mo>+</mo><mi>k</mi><mo>∗</mo><mi>v</mi><mi>a</mi><mi>l</mi><mi>u</mi><mi>e</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi>k</mi><mo>=</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>3</mn><mo separator="true">,</mo><mn>4</mn></mrow><annotation encoding="application/x-tex">dp[i][j]=max(dp[i-1][j],dp[i-1][j-k*weight[i]]+k*value[i])... k=1,2,3,4
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal">e</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">h</span><span class="mord mathnormal">t</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">u</span><span class="mord mathnormal">e</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">])</span><span class="mord">...</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">4</span></span></span></span></span></p>
<p>我们将j替换成<code>j-weight[i]</code>有</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mi>w</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">]</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mi>w</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mi>k</mi><mo>∗</mo><mi>w</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">]</mo><mo>+</mo><mi>k</mi><mo>∗</mo><mi>v</mi><mi>a</mi><mi>l</mi><mi>u</mi><mi>e</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi>k</mi><mo>=</mo><mn>2</mn><mo separator="true">,</mo><mn>3</mn><mo separator="true">,</mo><mn>4</mn><mo separator="true">,</mo><mn>5</mn><mo separator="true">,</mo><mn>6</mn></mrow><annotation encoding="application/x-tex">dp[i][j-weight[i]]=max(dp[i-1][j-weight[i]],dp[i-1][j-k*weight[i]]+k*value[i])...k=2,3,4,5,6
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal">e</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">h</span><span class="mord mathnormal">t</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal">e</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">h</span><span class="mord mathnormal">t</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal">e</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">h</span><span class="mord mathnormal">t</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">u</span><span class="mord mathnormal">e</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">])</span><span class="mord">...</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">6</span></span></span></span></span></p>
<p>观察两个式子，我们发现两个式子可以把k给抵消掉（采用<strong>递归</strong>的形式消去k）（递归的过程是j从小到大递归，因此在代码的循环部分j也要从小到大），两个式子整合为下面式子 <strong>（读者可以自己多列举几个k的数值去理解这里是如何整合的）</strong></p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mi>w</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">]</mo><mo>+</mo><mi>v</mi><mi>a</mi><mi>l</mi><mi>u</mi><mi>e</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">dp[i][j]=max(dp[i-1][j],dp[i][j-weight[i]]+value[i])
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal">e</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">h</span><span class="mord mathnormal">t</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">u</span><span class="mord mathnormal">e</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">])</span></span></span></span></span></p>
<p>因此代码在时间复杂度上可以优化成这样（三维到二维）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> max_weight 200</span></span><br><span class="line"><span class="type">int</span> weight[<span class="number">202</span>], value[<span class="number">202</span>];</span><br><span class="line"><span class="type">int</span> dp[<span class="number">100</span>][<span class="number">200</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &lt; weight[i])dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = max(dp[i - <span class="number">1</span>][j], dp[i][j - weight[i]] + value[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, dp[n][m]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="背包问题总结">背包问题总结</h4>
<p>四种背包问题在本质上都可以解释为01背包问题，简单的二维dp，只是附加了不同的条件，需要对应不同的方法去<strong>优化加强版的01背包</strong>，这些优化都是基于时间上的优化，但是背包问题普遍都可以使用<strong>滚动数组优化空间</strong>到一维。滚动数组优化以及各种背包问题的循环嵌套顺序，遍历顺序（从小到大或者是从大到小），可以自己尝试画出二维的递归表格，通过填涂表格的形式更好的理解嵌套和遍历顺序。</p>
<p>当然，嵌套和遍历顺序我们也可以通过状态转移方程推出，背包问题属于最基础形式的动态规划问题。</p>
]]></content>
      <tags>
        <tag>c语言</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构</title>
    <url>/2023/03/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<ul>
<li>本文所有内容均出自微信公众号&quot;labuladong&quot;,公众号本身代码均以java代码块形式呈现，本文将以c语言呈现。文章类似转载，但是已经声明出处，并修改代码为c语言，此内容主要是记录博主自身学习过程，有疑惑建议翻看原文</li>
</ul>
<span id="more"></span>
<h1>数据结构</h1>
<h2 id="链表">链表</h2>
<h3 id="合并两个有序链表">合并两个有序链表</h3>
<p><img src="https://soybeanlittlecar.oss-cn-beijing.aliyuncs.com/blog/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E5%8D%95%E9%93%BE%E8%A1%A8.jpg" alt="两个链表合并"></p>
<p>采用双指针实现，这里封装函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">link</span>;</span></span><br><span class="line">&#125; Node, *Nodeprt;</span><br><span class="line"></span><br><span class="line">Nodeprt <span class="title function_">mergeTwoLists</span><span class="params">(Nodeprt l1, Nodeprt l2)</span> &#123;</span><br><span class="line">    <span class="comment">//这里用两个指针分别指向两条链表的头结点，最终返回链表头节点,默认单增</span></span><br><span class="line">    Nodeprt head = (Nodeprt) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    Nodeprt p = head;<span class="comment">//虚拟头结点</span></span><br><span class="line">    <span class="keyword">while</span> (l1 != <span class="literal">NULL</span> &amp;&amp; l2 != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p1-&gt;data &gt; p2-&gt;data) &#123;</span><br><span class="line">            p-&gt;link = l2;</span><br><span class="line">            l2 = l2-&gt;link;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            p-&gt;link = l1;</span><br><span class="line">            l1 = l1-&gt;link;</span><br><span class="line">        &#125;</span><br><span class="line">        p = p-&gt;link;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p1 != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        p-&gt;link = l1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p2 != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        p-&gt;link = l2;</span><br><span class="line">    &#125;</span><br><span class="line">    p = head-&gt;link;<span class="comment">//重新指向头结点</span></span><br><span class="line">    <span class="built_in">free</span>(head);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="合并k个有序链表">合并k个有序链表</h3>
<p><img src="https://soybeanlittlecar.oss-cn-beijing.aliyuncs.com/blog/%E5%90%88%E5%B9%B6k%E4%B8%AA%E5%8D%95%E9%93%BE%E8%A1%A8.jpg" alt="合并k个有序链表"></p>
<p>合并k个有序链表的难点在于如何快速得到k个链表当中的最小节点并且接到链表上</p>
<p>这里采用<strong>优先队列(二叉堆)</strong>，把链表节点放到一个最小堆里面，每次获得k个节点中的最小节点。最开始堆中都是k条链表的头，每次弹出一个元素的同时，对应链表需要后移一位，然后将新的头插入到最小堆中，然后调整堆</p>
<p>最小堆模板</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MinData -1001</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElementType;<span class="comment">//自定义数据类型； </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">HeapStruct</span> &#123;</span></span><br><span class="line">    ElementType *Elements;<span class="comment">//存储堆元素的数组，指针数组</span></span><br><span class="line">    <span class="type">int</span> size;    <span class="comment">//堆的当前元素个数； </span></span><br><span class="line">    <span class="type">int</span> capacity;<span class="comment">//堆的最大容量 </span></span><br><span class="line">&#125; MinHeap, *MinHeapPrt;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">IsFull</span><span class="params">(MinHeapPrt H)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (H-&gt;size == Maxsize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">IsEmpty</span><span class="params">(MinHeapPrt H)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (H-&gt;size == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MinHeapPrt <span class="title function_">Create</span><span class="params">(<span class="type">int</span> Maxsize)</span> &#123;</span><br><span class="line">    <span class="comment">//创建容量为Maxsize的空的最小堆</span></span><br><span class="line">    <span class="comment">//从1开始插入元素，0留给哨兵； </span></span><br><span class="line">    MinHeapPrt H = (MinHeapPrt) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(MinHeap));</span><br><span class="line">    H-&gt;Elements = (ElementType *) <span class="built_in">malloc</span>((Maxsize + <span class="number">1</span>) * <span class="keyword">sizeof</span>(ElementType));</span><br><span class="line">    H-&gt;size = <span class="number">0</span>;</span><br><span class="line">    H-&gt;capacity = Maxsize;</span><br><span class="line">    H-&gt;Elements[<span class="number">0</span>] = MinData;<span class="comment">//随便找一个特别小，比所有输入数据小的元素就行； </span></span><br><span class="line">    <span class="comment">//MinData.定义哨兵为小于堆中所有可能元素的值，便于以后更快操作</span></span><br><span class="line">    <span class="keyword">return</span> H;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">insert</span><span class="params">(MinHeapPrt H, ElementType item)</span> &#123;</span><br><span class="line">    <span class="comment">//将元素item插入最小堆H，其中H-&gt;Elements[0]已经定义为哨兵；</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">if</span> (IsFull(H)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;最小堆已满&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    i = ++H-&gt;size;<span class="comment">//i指向插入后的最后一个元素位置； </span></span><br><span class="line">    <span class="keyword">for</span> (; H-&gt;Elements[i / <span class="number">2</span>] &gt; item; i /= <span class="number">2</span>)<span class="comment">//完全二叉树有i/2表示父结点的性质；如果父结点比目标item大，</span></span><br><span class="line">        <span class="comment">//这里会有i=1的情况，但是有哨兵存在，哨兵保证了所有输入数据都比哨兵大，如果没有哨兵，可以加一句i&gt;1; </span></span><br><span class="line">        <span class="comment">//哨兵效率更高； </span></span><br><span class="line">        H-&gt;Elements[i] = H-&gt;Elements[i / <span class="number">2</span>];<span class="comment">//保证有序性，把大小不符合的往下过滤， </span></span><br><span class="line">    H-&gt;Elements[i] = item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ElementType <span class="title function_">deleteMin</span><span class="params">(MinHeapPrt H)</span> &#123;</span><br><span class="line">    <span class="comment">//从最小堆中去除键值最小的元素，删除结点</span></span><br><span class="line">    <span class="type">int</span> parent, child;</span><br><span class="line">    ElementType MinItem, temp;</span><br><span class="line">    <span class="keyword">if</span> (IsEmpty(H)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;最小堆已空&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    MinItem = H-&gt;Elements[<span class="number">1</span>];<span class="comment">//从根结点找最小值；</span></span><br><span class="line">    <span class="comment">//用最小堆中最后一个元素从根结点开始向上过滤下层结点，就是先把最后一个元素放到根的位置</span></span><br><span class="line">    temp = H-&gt;Elements[H-&gt;size--];<span class="comment">//先赋值，再减减 </span></span><br><span class="line">    <span class="keyword">for</span> (parent = <span class="number">1</span>; parent * <span class="number">2</span> &lt;= H-&gt;size; parent = child) &#123;<span class="comment">//判断保证存在左子； </span></span><br><span class="line">        child = parent * <span class="number">2</span>;<span class="comment">//左子</span></span><br><span class="line">        <span class="keyword">if</span> ((child != H-&gt;size) &amp;&amp; (H-&gt;Elements[child] &gt; H-&gt;Elements[child + <span class="number">1</span>])) <span class="comment">//判断保证有左子的同时还有右子； </span></span><br><span class="line">            child++;<span class="comment">//左子比右子大 </span></span><br><span class="line">        <span class="keyword">if</span> (temp &lt;= H-&gt;Elements[child])<span class="keyword">break</span>;<span class="comment">//调整值比左右子都小；那就放在父的位置 </span></span><br><span class="line">        <span class="keyword">else</span><span class="comment">//移动temp元素到下一层 </span></span><br><span class="line">            H-&gt;Elements[parent] = H-&gt;Elements[child];<span class="comment">//向上过滤，往上移 </span></span><br><span class="line">    &#125;</span><br><span class="line">    H-&gt;Elements[parent] = temp;</span><br><span class="line">    <span class="keyword">return</span> MinItem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现合并k个链表</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Nodeprt <span class="title function_">mergerKLists</span><span class="params">(Nodeprt lists[], <span class="type">int</span> k)</span> &#123;<span class="comment">//传入一个指针数组，里面是k个头节点指针</span></span><br><span class="line">    Nodeprt head = (Nodeprt) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    Nodeprt p = head;</span><br><span class="line">    MinHeapPrt H = Create(k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">        insert(H, lists[i]-&gt;data);<span class="comment">//k个头节点插入最小堆</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!IsEmpty(H)) &#123;<span class="comment">//堆非空</span></span><br><span class="line">        Nodeprt q = (Nodeprt) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">        q-&gt;data = deleteMin(H);<span class="comment">//弹出堆顶元素</span></span><br><span class="line">        q-&gt;link = <span class="literal">NULL</span>;</span><br><span class="line">        p-&gt;link = q;</span><br><span class="line">        p = p-&gt;link;</span><br><span class="line">    &#125;</span><br><span class="line">    p = head-&gt;link;<span class="comment">//p作为链表头节点</span></span><br><span class="line">    <span class="built_in">free</span>(head);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="寻找单链表的倒数第k个结点">寻找单链表的倒数第k个结点</h3>
<p>从前往后找第k个节点非常简单，从后往前找k个节点也只是需要遍历两次，但是有没有更好的方法只遍历一次呢</p>
<p>有个非常巧妙的思路，当从前往后遍历k个时，拿一个指针指向头节点，那么当第一个指针到末尾时，第二个指针就指向倒数第k个节点了</p>
<p><img src="https://soybeanlittlecar.oss-cn-beijing.aliyuncs.com/blog/%E5%AF%BB%E6%89%BE%E9%93%BE%E8%A1%A8%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9-1.jpg" alt=""></p>
<p><img src="https://soybeanlittlecar.oss-cn-beijing.aliyuncs.com/blog/%E5%AF%BB%E6%89%BE%E9%93%BE%E8%A1%A8%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9-2.jpg" alt=""></p>
<p><img src="https://soybeanlittlecar.oss-cn-beijing.aliyuncs.com/blog/%E5%AF%BB%E6%89%BE%E9%93%BE%E8%A1%A8%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9-3.jpg" alt=""></p>
<h3 id="寻找单链表的中点">寻找单链表的中点</h3>
<p>单链表终点的一次遍历方法与上文类似，使用双指针(快慢指针)</p>
<h3 id="判断单链表是否包含环并找出环起点">判断单链表是否包含环并找出环起点</h3>
<p>暂时懒</p>
<h3 id="判断两个单链表是否相交并找出交点">判断两个单链表是否相交并找出交点</h3>
<p>暂时懒</p>
<h3 id="递归反转链表">递归反转链表</h3>
<p>暂时懒</p>
<h2 id="数组">数组</h2>
<h3 id="最长连续回文子串">最长连续回文子串</h3>
<p>对于一个给定的字符串，寻找其最长的连续的回文子串</p>
<p>难点：回文串的长度可能是奇数也可能是偶数，假如是奇数，那么有中心字符，如果是偶数，得从两个相邻的字符去向两侧寻找；因此先实现一个对于某个确定点找回文串的函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">palindrome</span><span class="params">(<span class="type">char</span> s[], <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (l &gt;= <span class="number">0</span> &amp;&amp; r &lt;= len - <span class="number">1</span> &amp;&amp; s[l] == s[r]) &#123;</span><br><span class="line">        l--;</span><br><span class="line">        r++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//具体细节可以使用指针来实现返回值</span></span><br><span class="line"><span class="comment">//然后就可寻找任意以s[i]为中心的回文串，或者以s[i]和s[i+1]为中心的回文串</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line"><span class="comment">//考虑所有情况，每次对于返回的长度进行比较，保留最长的即可</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="前缀和数组">前缀和数组</h3>
<p>前缀和用于速快频繁的计算一个索引区间内的元素之和</p>
<h4 id="一维前缀和">一维前缀和</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//我们可以定义一个类似于一维前缀和的二维数组</span></span><br><span class="line"><span class="comment">//预处理的时候将每一位累加起来</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">s[i] = s[i - <span class="number">1</span>] + x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这样对于任何原数组的区间和，例如区间[l,r];</span></span><br><span class="line"><span class="comment">//我们可以快速用s[r]-s[l-1]实现</span></span><br></pre></td></tr></table></figure>
<h4 id="二维矩阵的前缀和">二维矩阵的前缀和</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> sum[<span class="number">100</span>][<span class="number">100</span>];<span class="comment">//sum[i][j]表示从左上角(0,0)到(i,j)构成的矩形区域的和</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">		sum[i][j] = x + sum[i - <span class="number">1</span>][j] + sum[i][j - <span class="number">1</span>] - sum[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="差分数组">差分数组</h3>
<h4 id="一维差分">一维差分</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//对于正常的对一个广义连续的区间进行统一的加或者减去一个数字，常常使用循环遍历这个区间</span></span><br><span class="line"><span class="comment">//但是对于多次的加减操作非常麻烦，因此引出差分数组</span></span><br><span class="line"><span class="comment">//对于正常数组nums[],我们定义差分数组diff[100],diff[i]=nums[i]-nums[i-1];</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;nums[i]);</span><br><span class="line">    diff[i]=nums[i]-nums[i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于原来的nums[]数组，每次修改区间[left,right]，修改值为k，这里以加法为例子，我们只需在差分数组的diff[left]+=k;	diff[right+1]-=k;这样操作，这样有什么用处呢？</p>
<p>对于diff[left]+=k；我们累加的时候，从nums[left]~nums[right]之间的每一个数字，都加上了k，但是nuns[right+1]以及之后的数字不需要＋k了，因此在diff[right+1]-=k；进行弥补，使得这个-k和前面的+k抵消，从而实现了修改区间[left,right]，区间的每个数字都加上了k。</p>
<p>在最后访问第i个位置的数字nums[i]的时候（是经过很多次修改之后的nums[i])，我们累加diff[1]，diff[2]…diff[i],将i个数字加起来作为修改后的nums[i]数值。</p>
<h4 id="二维差分">二维差分</h4>
<ul>
<li>
<p>写在结尾: 再次鸣谢公众号&quot;labuladong&quot;,公众号中有很多写的优质的文章和资源，对于部分算法也有着非常透彻的分析，对于本菜菜的学习有着非常大的帮助。</p>
<p><a href="https://mp.weixin.qq.com/s/GOOgO5Wp48jM9jSPzqJwOQ">原作者laluladong</a></p>
</li>
</ul>
]]></content>
      <tags>
        <tag>c语言</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
</search>
