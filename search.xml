<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>AVL树</title>
    <url>/2023/04/27/AVL%E6%A0%91/</url>
    <content><![CDATA[<h1>平衡二叉树</h1>
<h2 id="引入">引入</h2>
<p>我们曾经学习过二叉搜索树（Binary Search Tree，(BST))。它的插入和查找效率可以达到   o(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi></mrow><annotation encoding="application/x-tex">log_2n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal">n</span></span></span></span>)   ，但是在一些情况下，比如输入序列为<code>&#123;1, 2, 3, 4, 5, 6&#125;</code>，二叉搜索树将会退化成为一个单链表，这样对于插入和查找效率又回到了  <strong>o(n)</strong>  。因此引出平衡二叉树</p>
<p><img src="https://soybeanlittlecar.oss-cn-beijing.aliyuncs.com/blog/AVL/00001.png" alt=""></p>
<h2 id="性质">性质</h2>
<p>平衡二叉树具有以下性质</p>
<ol>
<li>任意结点的左右子树也是平衡二叉树</li>
<li>任意结点的左右子树高度差的绝对值小于等于1</li>
</ol>
<p>我们定义某个结点的左右子树高度差为平衡因子，平衡二叉树的所有结点的平衡因子都小于属于<code>&#123;-1, 0, 1&#125;</code></p>
<h2 id="结点组成结构">结点组成结构</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">AVLNode</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="type">int</span> height;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">AVLNode</span> *<span class="title">left</span>, *<span class="title">right</span>;</span></span><br><span class="line">&#125; Node, *Nodeprt;</span><br></pre></td></tr></table></figure>
<h2 id="失衡">失衡</h2>
<p>对于一颗平衡二叉树来说，插入一个结点可能导致失衡</p>
<p><img src="https://soybeanlittlecar.oss-cn-beijing.aliyuncs.com/blog/AVL/00003.png" alt=""></p>
<p>我们在原本平衡的树上插入20结点，导致失衡，因为13结点的左右子树高度差的绝对值大于1</p>
<p>这时我们需要相应的操作对这颗树进行调整，我们需要先了解最小不平衡子树的概念</p>
<h3 id="最小不平衡子树">最小不平衡子树</h3>
<p>从新插入的结点向上寻找，找到第一个不平衡点（左右子树差值的绝对值大于1）（平衡因子绝对值大于1），上图中，最小不平衡子树为13号结点为根的树。</p>
<p>往往很多时候第一个不平衡点并不是整棵树的树根，只是一颗子树，这时我们只需要调整子树即可</p>
<h3 id="旋转">旋转</h3>
<p>通过旋转操作调整最小不平衡子树，从而最终形成平衡二叉树，以下所有操作的描述起点都是当前对应的第一个不平衡点，也就是最小不平衡子树的树根，以下分类按照不平衡点的位置划分，</p>
<p>按照引起不平衡的点进行四种类比划分——左左，右右，左右，右左</p>
<h4 id="左旋（右孩子的右子树）">左旋（右孩子的右子树）</h4>
<p><img src="https://soybeanlittlecar.oss-cn-beijing.aliyuncs.com/blog/AVL/left-round.png" alt=""></p>
<ul>
<li>节点（20）的右孩子（25）代替当前节点（20）的位置</li>
<li>右孩子（25）的左孩子（24）作为当前结点（20）的右孩子【前提是右孩子（25）有左孩子（24）】</li>
<li>当前结点（20）变成右孩子（25）的左子树</li>
</ul>
<p>例子：</p>
<p>插入结点20之后，二叉树失衡，进行左旋调整</p>
<p><img src="https://soybeanlittlecar.oss-cn-beijing.aliyuncs.com/blog/AVL/00004.png" alt=""></p>
<p>左旋调整代码（右孩子的右子树）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Nodeprt <span class="title function_">right_right</span><span class="params">(Nodeprt tree)</span> &#123;<span class="comment">//左旋</span></span><br><span class="line">    <span class="comment">//结点调整</span></span><br><span class="line">    Nodeprt k = tree-&gt;right;<span class="comment">//保存右孩子，最终成为子树根节点</span></span><br><span class="line">    tree-&gt;right = k-&gt;left;<span class="comment">//k的左孩子作为tree的右子树</span></span><br><span class="line">    k-&gt;left = tree;<span class="comment">//tree作为k的左子树</span></span><br><span class="line">    <span class="comment">//高度调整</span></span><br><span class="line">    k-&gt;height = max(k-&gt;left-&gt;height, k-&gt;right-&gt;height) + <span class="number">1</span>;</span><br><span class="line">    tree-&gt;height = max(tree-&gt;left-&gt;height, tree-&gt;right-&gt;height) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="右旋（左孩子的左子树）">右旋（左孩子的左子树）</h4>
<p><img src="https://soybeanlittlecar.oss-cn-beijing.aliyuncs.com/blog/AVL/right-round.png" alt=""></p>
<ul>
<li>当前结点（20）的左孩子（16）代替当前结点（20）的位置</li>
<li>左孩子（16）的右子树（18）变成当前结点（20）的左孩子【前提是左孩子（16）有右子树（18）】</li>
<li>当前结点（20）变成左孩子（16）的右子树</li>
</ul>
<p>例子：</p>
<p>插入结点1之后，二叉树失衡，进行右旋调整</p>
<p><img src="https://soybeanlittlecar.oss-cn-beijing.aliyuncs.com/blog/AVL/00005.png" alt=""></p>
<p>右旋调整代码（左孩子的左子树）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Nodeprt <span class="title function_">left_left</span><span class="params">(Nodeprt tree)</span> &#123;<span class="comment">//右旋</span></span><br><span class="line">    <span class="comment">//结点调整</span></span><br><span class="line">    Nodeprt k = tree-&gt;left;<span class="comment">//保存右孩子，最终成为子树根节点</span></span><br><span class="line">    tree-&gt;left = k-&gt;right;<span class="comment">//k的右孩子作为tree的左子树</span></span><br><span class="line">    k-&gt;right = tree;<span class="comment">//tree作为k的右子树</span></span><br><span class="line">    <span class="comment">//高度调整</span></span><br><span class="line">    k-&gt;height = max(k-&gt;left-&gt;height, k-&gt;right-&gt;height) + <span class="number">1</span>;</span><br><span class="line">    tree-&gt;height = max(tree-&gt;left-&gt;height, tree-&gt;right-&gt;height) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="先左旋再右旋（左孩子的右子树）">先左旋再右旋（左孩子的右子树）</h4>
<p><img src="https://soybeanlittlecar.oss-cn-beijing.aliyuncs.com/blog/AVL/00006.png" alt=""></p>
<p>新插入的9号结点造成二叉树失衡，向上寻找最小不平衡子树的根节点为13，9在13的左孩子的右子树。先对13的左孩子进行左旋，再对13进行右旋。</p>
<p>左旋再右旋（左孩子的右子树）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Nodeprt <span class="title function_">left_right</span><span class="params">(Nodeprt tree)</span>&#123;</span><br><span class="line">    tree-&gt;left=right_right(tree-&gt;left);<span class="comment">//左子树左旋</span></span><br><span class="line">    tree=left_left(tree);<span class="comment">//自身右旋</span></span><br><span class="line">    <span class="keyword">return</span> tree;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="先右旋再左旋（右孩子的右子树）">先右旋再左旋（右孩子的右子树）</h4>
<p><img src="https://soybeanlittlecar.oss-cn-beijing.aliyuncs.com/blog/AVL/00007.png" alt=""></p>
<p>新插入的14号结点造成二叉树失衡，向上寻找最小不平衡子树的根节点13，14在13的右孩子的左子树，先对右孩子18右旋，再对13左旋。</p>
<p>右旋再左旋（右孩子的左子树）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Nodeprt <span class="title function_">right_left</span><span class="params">(Nodeprt tree)</span> &#123;</span><br><span class="line">    tree-&gt;right = left_left(tree-&gt;right);</span><br><span class="line">    tree = right_right(tree);</span><br><span class="line">    <span class="keyword">return</span> tree;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="失衡调整总结">失衡调整总结</h3>
<p>以<strong>A</strong>结点作为最小不平衡子树的<strong>根节点</strong></p>
<p>插入位置								描述														调整方式</p>
<p>​	LL			在结点A的<strong>左</strong>孩子的<strong>左</strong>子树插入导致A失衡						A右旋</p>
<p>​	RR			在结点A的<strong>右</strong>孩子的<strong>右</strong>子树插入导致A失衡						A左旋</p>
<p>​	LR			在结点A的<strong>左</strong>孩子的<strong>右</strong>子树插入导致A失衡			A的左子左旋，A右旋</p>
<p>​	RL			在结点A的<strong>右</strong>孩子的<strong>左</strong>子树插入导致A失衡			A的右子右旋，A左旋</p>
<p>插入的最终代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Nodeprt <span class="title function_">insert</span><span class="params">(Nodeprt tree, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (tree == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        Nodeprt p = build_node(key);</span><br><span class="line">        tree = p;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &lt; tree-&gt;data) &#123;</span><br><span class="line">        tree-&gt;left = insert(tree-&gt;left, key);<span class="comment">//递归插入左子树</span></span><br><span class="line">        <span class="comment">//在左侧插入，只可能左侧比右侧高了2导致失衡</span></span><br><span class="line">        <span class="keyword">if</span> (tree-&gt;left-&gt;height - tree-&gt;right-&gt;height == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="comment">//判断左子树还是右子树是插入位置</span></span><br><span class="line">            <span class="keyword">if</span> (key &lt; tree-&gt;left-&gt;data) &#123;<span class="comment">//左左</span></span><br><span class="line">                tree = left_left(tree);</span><br><span class="line">            &#125; <span class="keyword">else</span> tree = left_right(tree);<span class="comment">//左右</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; tree-&gt;data) &#123;<span class="comment">//递归插入右子树</span></span><br><span class="line">        tree-&gt;right = insert(tree-&gt;right, key);</span><br><span class="line">        <span class="comment">///在右侧插入，只可能右侧比左侧高2导致失衡</span></span><br><span class="line">        <span class="keyword">if</span> (tree-&gt;right-&gt;height - tree-&gt;left-&gt;height == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="comment">//判断左子树还是右子树插入</span></span><br><span class="line">            <span class="keyword">if</span> (key &gt; tree-&gt;right-&gt;data) &#123;<span class="comment">//右右</span></span><br><span class="line">                tree = right_right(tree);</span><br><span class="line">            &#125; <span class="keyword">else</span> tree = right_left(tree);<span class="comment">//右左</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;不允许插入重复值\n&quot;</span>);</span><br><span class="line">    tree-&gt;height = max(tree-&gt;left-&gt;height, tree-&gt;right-&gt;height) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> tree;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="删除结点">删除结点</h2>
<p>删除操作过于复杂，后面有机会再补充，和普通二叉树的删除操作一起补充。</p>
<p>上述代码或者描述有问题的请联系作者（代码还未测试…）</p>
<p>感谢博主文章<a href="https://blog.csdn.net/weixin_54186646/article/details/124557830?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-4-124557830.nonecase&amp;spm=1018.2226.3001.4187">平衡二叉树（详细解释+完整C语言）_～在下小吴的博客-CSDN博客</a></p>
]]></content>
      <categories>
        <category>平衡二叉树</category>
      </categories>
      <tags>
        <tag>平衡二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>oo-java</title>
    <url>/2023/06/27/oo-java/</url>
    <content><![CDATA[<p>此文章为作者基于浙江大学mooc中的java基础和面向对象的相关学习而写，</p>
<p>参考书籍《Java编程思想》</p>
<p>一切内容均来自于个人，以下所谓“差异”，均比较与C语言</p>
<h1>Java基础</h1>
<p>Java中的大部分内容和c语言极其相似，以下列出一些不同点</p>
<h2 id="基本数据类型差异">基本数据类型差异</h2>
<table>
<thead>
<tr>
<th><strong>整数类型</strong></th>
<th><strong>byte</strong></th>
<th><strong>一个字节</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td><strong>short</strong></td>
<td><strong>两个字节</strong></td>
</tr>
<tr>
<td></td>
<td><strong>int</strong></td>
<td><strong>四个字节</strong></td>
</tr>
<tr>
<td></td>
<td><strong>long</strong></td>
<td><strong>八个字节</strong></td>
</tr>
<tr>
<td><strong>浮点类型</strong></td>
<td><strong>float与double</strong></td>
<td><strong>四字节与八字节(同c语言)</strong></td>
</tr>
<tr>
<td><strong>字符类型</strong></td>
<td><strong>char</strong></td>
<td><strong>两个字节，‘\u0000’~‘\uffff’,支持汉字</strong></td>
</tr>
<tr>
<td><strong>布尔类型</strong></td>
<td><strong>boolean</strong></td>
<td><strong>一个字节，true  false</strong></td>
</tr>
</tbody>
</table>
<p>Java也具有<code>null</code>类型</p>
<h2 id="字面值常量差异">字面值常量差异</h2>
<p><code>0</code>开头表示八进制</p>
<p><code>0B/0b</code>表示二进制</p>
<p><code>0X/0x</code>表示十六进制</p>
<p>同时支持<code>_</code>分隔数字，便于分清数字位数（类似于python）</p>
<p>字面值常量整数默认为<code>int</code>，长整型<code>long</code>在数字末尾需要添加<code>L</code></p>
<p>字面值常量浮点数默认为<code>double</code>，浮点型<code>float</code>在数字末尾需要添加<code>F或f</code></p>
<p><code>boolean</code>为逻辑数字类型，只有<code>true和false</code>两种字面值，并且<strong>不对应于任何整数值1和0</strong>（这一点与c语言不同）</p>
<h2 id="变量声明差异">变量声明差异</h2>
<p>大部分和c语言一样，需要提前声明变量，并且需要进行初始化</p>
<p>java的变量如果不进行初始化，则会默认设为0或者false</p>
<p>Java11后支持局部变量类型推定，使用<code>var</code>进行声明变量，变量类型未定，根据上下文自动推定类型</p>
<h2 id="运算提醒">运算提醒</h2>
<p>与c语言相同，对于<code>&amp;&amp;</code>和<code>||</code>运算都具有“短路”现象，只有左操作数无法决定最终的值时才会计算右操作数</p>
<p><code>&gt;&gt;&gt;</code>代表无符号右移，高位补0</p>
<p><code>instanceof</code>测试某个对象是否为指定类的对象实例，返回boolean，类似于python</p>
<p>整数计算的时候默认为<code>int</code>型，即使所有参与运算的数据类型都低于<code>int</code>，除非有long，则上升类型为long</p>
<p>带有浮点数运算默认为<code>float</code>型，除非有double，则上升类型为double</p>
<h2 id="控制语句差异">控制语句差异</h2>
<p>除了c语言一样的控制语句之外，java还有一些特殊的控制语句形式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">rangeOf</span><span class="params">(<span class="type">int</span> k)</span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(k)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>			-&gt;System.out.println(<span class="string">&quot;Ranking one&quot;</span>);</span><br><span class="line">        	<span class="keyword">case</span> <span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>		-&gt;System.out.println(<span class="string">&quot;Ranking two&quot;</span>);</span><br><span class="line">            <span class="keyword">default</span>				-&gt;System.out.println(<span class="string">&quot;Ranking three&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>支持多种条件写在同一行，同时不需要冒号，使用<code>-&gt;</code>，不需要break语句跳出（在JDK14版本之后）</p>
<p>增强型for循环，主要用于枚举、数组和集合对象的元素遍历</p>
<p>Foreach用法,用于数组和容器</p>
<p><code>for(&lt;类型&gt;&lt;变量&gt;:&lt;集合对象&gt;)</code>声明类型需要与集合对象相兼容</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String []args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] num = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">100</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            num[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k : num) &#123;</span><br><span class="line">            System.out.println(k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="移位操作符">移位操作符</h2>
<p>移位仅针对<code>int</code>,<code>long</code>使用，对于<code>byte, char, short</code>，在移位前都会转换成同数字大小的<code>int</code></p>
<p>位操作都是针对二进制补码操作</p>
<p><code>&lt;&lt;</code>左移，低位补0</p>
<p><code>&gt;&gt;</code>有符号右移，如果是正数，高位全部补0，如果是负数，高位全部补1</p>
<p><code>&gt;&gt;&gt;</code>无符号右移，不论正负，全部补0</p>
<p>java对于移位操作的数值有一定限制，对于int类型的操作数只考虑<strong>低五位</strong>，long类型只考虑<strong>低六位</strong></p>
<p>比如说<code>30&gt;&gt;32</code>等价于<code>30&gt;&gt;0</code>，有一个类似于取模32的过程，对于long就有个取模64的过程</p>
<h2 id="static详解">static详解</h2>
<p>static大多数用于类的成员变量或者成员方法，少数用于代码块提升性能，static不能修饰局部变量</p>
<ul>
<li>static修饰的成员变量或者方法属于<strong>类</strong>，因此生命周期和类相同</li>
<li>普通成员变量或者方法属于<strong>对象</strong></li>
<li>静态方法不能调用非静态成员变量，会报错</li>
<li>非静态方法可以调用非静态方法和静态方法，可以调用非静态成员和静态成员</li>
</ul>
<p>static方法称为静态方法，不依赖于任何对象就能使用，因此也不具备this的使用，其不依赖于任何对象，没有对象，也就没有this</p>
<p>静态方法中不能使用非静态成员变量和非静态方法，因为后者都是需要依附于对象才能被调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;soy&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">address</span> <span class="operator">=</span> <span class="string">&quot;BUAA&quot;</span>;</span><br><span class="line"></span><br><span class="line">    Main() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">        System.out.println(address);</span><br><span class="line">        test2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">        System.out.println(address);<span class="comment">//error</span></span><br><span class="line">        test1();<span class="comment">//error</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个示例的第17行，在静态的方法内调用了非静态成员变量<code>address</code>，系统报错</p>
<p>第18行，在静态方法内部调用了非静态方法<code>test1()</code>，系统报错</p>
<p>但是对于非静态方法，其可以随意调用静态变量和方法</p>
<p>静态方法可以不创建对象就调用，最常见的就是main方法是静态的</p>
<ul>
<li>静态变量被所有对象共享，内存只有一份，不同对象都可以修改该静态变量</li>
<li>非静态变量相互独立，在对象创建的时候进行初始化，有多个副本互不影响</li>
</ul>
<p>在类被加载的时候，static代码块就按照顺序进行初始化了</p>
<p>静态的加载顺序是从上往下依次执行，静态变量和静态代码块视作同一类，从上往下执行</p>
<h3 id="静态代码块">静态代码块</h3>
<p>静态代码块里面定义的变量都是局部变量，只在本块中有效</p>
<h1>初始化与清理</h1>
<h2 id="构造器初始化">构造器初始化</h2>
<p>在类里面使用和类名相同的方法作为构造函数，可以有多个构造函数，区别在于参数不同</p>
<p>构造器没有返回值</p>
<p>如果类没有构造器，系统会自动为你创造一个默认构造器</p>
<h2 id="方法重载">方法重载</h2>
<p>同一个类里面支持多个同名方法，区别在于参数不同，方法重载在涉及到数据的类型转换时可能有一些问题</p>
<p>传入的参数类型低于要求的类型，就会自动提升参数类型</p>
<p>传入的参数类型高于要求的类型，就会自动降低到参数对应的类型</p>
<h2 id="this">this</h2>
<p>this表示对当前对象的引用，可以作为返回值，返回对当前对象的引用</p>
<p>构造器之间可以相互调用，但是一次只能调用一个构造器，使用this调用</p>
<p>只有构造器能调用构造器，其它方法不能调用构造器</p>
<h2 id="变量初始化顺序">变量初始化顺序</h2>
<p>类的内部，变量的初始化顺序取决于其定义的先后顺序，但是不论他们处于任何位置，他们都会在构造器和任何方法调用之前完成初始化</p>
<h2 id="多个类">多个类</h2>
<p>一个<code>.java</code>文件允许有多个<code>class</code>，但是一般只有一个<code>class</code>由<code>public</code>修饰作为主类，主类的名字和<code>.java</code>文件名字相同</p>
<h2 id="类与类的关系">类与类的关系</h2>
<ul>
<li>关联：是一种has的关系
<ul>
<li>一对一</li>
<li>一对多</li>
</ul>
</li>
<li>依赖：比has关系较弱，类之间的调用关系</li>
<li>聚集：整体和部分之间的联系
<ul>
<li>组合</li>
</ul>
</li>
<li>泛化：类之间的继承关系</li>
<li>实现：类与接口的关系</li>
</ul>
<h1>封装</h1>
<ul>
<li>将对象的属性和方法看成一个整体</li>
<li>就信息进行隐藏，赋予一定的权限</li>
</ul>
<p>一般情况下，给<strong>所有的成员变量</strong>加入<code>private</code>权限限制，写相关属性的<code>get和set</code>方法，将这些方法设置为<code>public</code>，从而通过方法访问私有属性</p>
<ul>
<li><code>private</code>仅仅在本类中可见，提升数据的安全性</li>
<li><code>public</code>权限最低，其它类中也可以访问，减少代码冗余</li>
<li><code>protected</code>向子类和同一个包中的类公开</li>
<li>默认权限，向同一个包中的类公开</li>
</ul>
<p><code>protected</code>修饰规则详解：</p>
<ol>
<li>基类（父类）的protected成员（包括成员变量和成员方法）对本包内可见，并且对子类可见；</li>
<li>若子类与基类（父类）不在同一包中，那么在子类中，只有子类实例可以访问其从基类继承而来的protected方法，而在子类中不能访问基类实例（对象）（所调用）的protected方法。</li>
<li>不论是否在一个包内，父类中可以访问子类实例（对象）继承的父类protected修饰的方法。（子父类访问权限特点：父类访问域大于子类）</li>
<li>若子类与基类（父类）不在同一包中,子类只能在自己的类（域）中访问父类继承而来的protected成员，无法访问别的子类实例（即便同父类的亲兄弟）所继承的protected修饰的方法。</li>
<li>若子类与基类（父类）不在同一包中，父类中不可以使用子类实例调用（父类中没有）子类中特有的（自己的）protected修饰的成员。（毕竟没有满足同一包内和继承获得protected成员的关系）</li>
</ol>
<h2 id="封装的单实例模式">封装的单实例模式</h2>
<h3 id="“懒汉式”单例">“懒汉式”单例</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">//静态的。保留自身的引用。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">test</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//必须是私有的构造函数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//公共的静态的方法。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (test == <span class="literal">null</span>) &#123;</span><br><span class="line">            test = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> test;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>• 是否 Lazy 初始化：是，只有需要的时候才会初始化</p>
<p>• 是否多线程安全：否</p>
<p>• 描述：这种方式是最基本的实现方式，这种实现最大的问题就是不支持多线程。因为没有加锁 synchronized，所以严格意义上它并不算单例模式。</p>
<p>• 特点这种方式 lazy loading 很明显，不要求线程安全，在多线程不能正常工作只有一个实例，共享的数据，便于频繁查询修改</p>
<h3 id="“饿汉式”单例">“饿汉式”单例</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">//静态的,保留自身的引用,类加载时就初始化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//必须是私有的构造函数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//公共的静态的方法。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> test;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>• 是否 Lazy 初始化：否，不论需不需要，类加载的时候就直接创建实例初始化</p>
<p>• 是否多线程安全：是</p>
<p>• 优点：没有加锁，执行效率会提高。</p>
<p>• 缺点：类加载时就初始化，容易产生垃圾对象，浪费内存。</p>
<p>• 特点：它基于 classloder 机制避免了多线程的同步问题，不过，instance 在类装载时就实例化。</p>
<h1>常用集合框架设计</h1>
<h3 id="List列表">List列表</h3>
<p>有序性，可重复性</p>
<p>列表的三种类型，E为每个元素的类型</p>
<ul>
<li><code>List&lt;E&gt; list = new ArrayList&lt;&gt;()</code>，基于数组实现的动态数组，增删慢，查询快</li>
<li><code>List&lt;E&gt; list = new LinkedList&lt;&gt;()</code>，基于链表实现的双向链表，增删快，查询慢</li>
<li><code>List&lt;E&gt; list = new Vector&lt;&gt;()</code>，类似于<code>ArrayList</code>，多线程安全，性能较差</li>
</ul>
<p>常用方法：</p>
<ul>
<li><code>list.size()</code>，返回元素个数</li>
<li><code>list.add(&#123;int index ,&#125;E element)</code>，可选参数<code>index</code>，默认在列表尾部添加元素</li>
<li><code>list.get(int index)</code>，获取对应下标的元素</li>
<li><code>list.set(int index, E element)</code>，设置对应下标的值</li>
<li><code>list.remove(int index)</code>，移除指定下标的元素</li>
<li><code>list.isEmpty()</code>，检查列表是否为空</li>
<li><code>list.contains(Object o)</code>，是否包含某元素</li>
<li><code>list.indexOf(Object o)</code>，某个元素第一次出现的下标</li>
<li><code>list.subList(int fromIndex,int toIndex)</code>，获取子列表</li>
<li>待补充</li>
</ul>
<h4 id="列表初始化">列表初始化</h4>
<p>在已知列表即将被初始化后的每个元素类型时，使用一些已有的来构造列表</p>
<p>获取已有的列表的元素<code>List&lt;String&gt; newList = new ArrayList&lt;&gt;(existingList)</code></p>
<p>比如常用的<code>List&lt;Map.Entry&lt;String, Name&gt;&gt; list = new ArrayList&lt;&gt;(map.entrySet())</code></p>
<p><code>map.entrySet()</code>就是返回一个由键值对构成的集合</p>
<h3 id="Map键值对">Map键值对</h3>
<p>无序性，键的不可重复性</p>
<p>四种类型，<code>E1</code>为键的类型，<code>E2</code>为值的类型</p>
<ul>
<li><code>Map&lt;E1, E2&gt; map = new HashMap&lt;&gt;()</code>，基于哈希表实现，提供快速查找，插入，删除</li>
<li><code>Map&lt;E1, E2&gt; map = new TreeMap&lt;&gt;()</code>，基于红黑树实现，提供有序键值对，按照键的自然顺序或自定义顺序排序</li>
<li><code>Map&lt;E1, E2&gt; map = new LinkedHashMap&lt;&gt;()</code>，基于哈希表和链表实现，保持了插入顺序或者访问顺序，允许迭代时按顺序访问</li>
<li>待添加</li>
</ul>
<p>常用方法：</p>
<ul>
<li><code>map.put(E1 key, E2 value)</code>，向表中添加键值对</li>
<li><code>map.containsKey(E1 key)</code>，查询是否包含“键”</li>
<li><code>map.get(E1 key)</code>，返回对应键的值</li>
<li><code>map.remove(E1 key)</code>，删除对应键的值</li>
<li><code>map.size()</code>，获取map的大小</li>
<li><code>map.isEmpty()</code>，检查map是否为空</li>
<li><code>map.keySet()</code>，获取map的键的集合</li>
<li><code>map.values()</code>，获取map的值的集合</li>
<li><code>map.entrySet()</code>，获取map的键值对的集合，常常用于返回给列表进行排序</li>
<li><code>map.clear()</code>，清空所有键值对</li>
<li>待添加</li>
</ul>
<h3 id="HashSet集合">HashSet集合</h3>
<p>实现了<code>Set</code>接口，存储一组唯一元素，不允许元素的重复性，无序，基于哈希表实现</p>
<ul>
<li><code>hashSet.add(E e)</code>，添加元素，如果已经存在，不会重复添加</li>
<li><code>hashSet.remove(E e)</code>，移除元素</li>
<li><code>hashSet.contains(E e)</code>，检查是否包含</li>
<li><code>hashSet.size()</code>，元素数量，集合大小</li>
<li><code>hashSet.isEmpty()</code>是否为空</li>
<li><code>hashSet.clear()</code>，清空集合</li>
</ul>
<h3 id="Iterator迭代器">Iterator迭代器</h3>
<p><code>Iterator</code>是一个接口，用于遍历集合(如<code>List</code>, <code>Set</code>, <code>Map</code>)中的元素。</p>
<p><code>Iterator</code>提供了标准的迭代方式，不用知道底层逻辑，允许顺序访问集合中的元素</p>
<p>调用集合的<code>iterator()</code>方法获取实例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">Iterator&lt;String&gt; iterator = list.iterator();</span><br><span class="line"><span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">element</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">    <span class="comment">//对element进行操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于Java5之后有增强型的for-each，显式的iterator不再使用</p>
<h1>继承</h1>
<p>父类的属性和方法可以应用于子类，代码复用性高，可以轻松自定义子类</p>
<ul>
<li>父类superclass，子类subclass</li>
<li>单继承与多继承，多继承拥有多个父类</li>
</ul>
<p>抽象类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> stract <span class="title function_">sleep</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> stract <span class="title function_">eat</span><span class="params">()</span>;<span class="comment">//抽象类不能写&#123;&#125;，必须直接分号结尾</span></span><br><span class="line">    <span class="comment">//包含抽象方法，必须写成抽象类，抽象类不一定要写抽象方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>子类拥有父类所有的属性和方法，包括私有属性，但是无法直接访问私有属性，需要父类的get()方法间接访问</p>
<p>子类无法继承父类的构造方法，构造方法无法被继承，子类需要定义自身的构造方法</p>
<ul>
<li>java不支持类的多继承，但是支持接口的多继承，一个类只能有一个直接的父类，使用<code>extends</code>连接</li>
<li>子类调用父类都需要super()，super().方法名</li>
<li>将基类数据成员定义为private，使用相应的构造函数去访问，保证封装性，降低效率</li>
<li>基类仅仅对派生类提供服务时，可以设置为protected，如果有除了派生类以外的无关类，则建议private</li>
<li>派生类可以自动向基类进行类型转换，向上映射会丢失子类的独有的方法，但是如果是继承的方法，那么调用时依然调用子类重写的方法</li>
</ul>
<p><strong>运行时类型：由该变量指向的对象类型决定</strong></p>
<p><strong>编译时类型：由该变量声明时的类型决定</strong></p>
<p>覆盖：子类重写父类的方法，方法名和参数类型完全一样，覆盖是对于实例方法而言的</p>
<p>方法不能交叉覆盖：子类实例方法不能覆盖父类静态方法，子类静态方法也不能覆盖父类实例方法</p>
<p>隐藏：父类和子类具有相同的名字的属性或者方法（方法隐藏仅有一种可能，父类和子类都是静态方法），父类的同名属性或者方法在形式上不见了，实际还是存在的</p>
<ol>
<li>当发生隐藏时，声明类型是什么类，就调用对应类的属性或者方法，而不会有动态绑定(运行时)</li>
<li>属性只能被隐藏，无法被覆盖</li>
<li>变量允许交叉隐藏，即非静态的隐藏静态的，静态的隐藏非静态的</li>
</ol>
<p>隐藏与覆盖的区别：</p>
<ol>
<li>被隐藏的属性，在子类向上转型成父类时后，访问的是父类中的属性，</li>
<li>在没有转换时，子类访问父类的属性需要super关键字</li>
<li>被覆盖的方法，在子类向上转型成父类后，调用的还是子类自身的方法，如果想要访问父类还是可以用super关键字</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>  &#123;</span><br><span class="line">    	<span class="type">Circle</span> <span class="variable">circle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Circle</span>();<span class="comment">//本类引用指向本类对象</span></span><br><span class="line">        <span class="type">Shape</span> <span class="variable">shape</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Circle</span>();<span class="comment">//父类引用指向子类对象(会有隐藏和覆盖)</span></span><br><span class="line">        </span><br><span class="line">       System.out.println(circle.name);</span><br><span class="line">       circle.printType();</span><br><span class="line">       circle.printName();</span><br><span class="line">       <span class="comment">//以上都是调用Circle类的方法和引用</span></span><br><span class="line">       </span><br><span class="line">        System.out.println(shape.name);<span class="comment">//调用父类被隐藏的name属性</span></span><br><span class="line">        shape.printType();<span class="comment">//调用子类printType的方法</span></span><br><span class="line">        shape.printName();<span class="comment">//调用父类隐藏的printName方法 </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;shape&quot;</span>;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Shape</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;shape constructor&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printType</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;this is shape&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printName</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;shape&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;circle&quot;</span>; <span class="comment">//父类属性被隐藏</span></span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Circle</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;circle constructor&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//对父类实例方法的覆盖</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printType</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;this is circle&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">   <span class="comment">//对父类静态方法的隐藏  </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printName</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;circle&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>output</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">shape constructor</span><br><span class="line">circle constructor</span><br><span class="line"><span class="comment">//普通对象的创建</span></span><br><span class="line">shape constructor</span><br><span class="line">circle constructor</span><br><span class="line"><span class="comment">//普通对象的创建</span></span><br><span class="line">circle</span><br><span class="line"><span class="built_in">this</span> is circle</span><br><span class="line">circle</span><br><span class="line"><span class="comment">//普通对象的访问</span></span><br><span class="line">shape</span><br><span class="line"><span class="built_in">this</span> is circle</span><br><span class="line">shape</span><br><span class="line"><span class="comment">//类型向上强转，属性被隐藏，type方法被重写覆盖，name方法被隐藏</span></span><br><span class="line"><span class="comment">//隐藏的属性，调用声明时类型，输出shape</span></span><br><span class="line"><span class="comment">//覆盖的方法，调用子类的方法，输出this is circle</span></span><br><span class="line"><span class="comment">//被隐藏的方法，调用声明时类型，输出shape</span></span><br></pre></td></tr></table></figure>
<p>final用法</p>
<ol>
<li>final修饰变量，final变量被赋了初值就无法再改变</li>
<li>final修饰的方法不可被重写，比如某个父类的方法加入final，那么子类无法再重写该方法</li>
<li>final修饰的类无法被继承</li>
</ol>
<h1>多态</h1>
<p>静多态：编译时多态，静态联编，静绑定。<strong>方法重载，方法隐藏</strong></p>
<p>方法重载：方法同名，参数列表不同</p>
<p>方法重载特例：允许不同访问权限修饰，允许不同返回值，构造方法和静态方法也可以重载</p>
<p>动多态：运行时多态，动态联编，动绑定。条件：<strong>继承，覆盖，向上转型</strong></p>
<p>有继承的情况，继承中必须有方法覆盖(override)，通过父类调用被覆盖的方法</p>
<p>方法覆盖：方法名，参数列表一致，子类方法不能缩小访问权限</p>
<p>方法覆盖特例：私有方法，静态方法不能被覆盖，如果子类有同名方法，那就是执行方法隐藏(实际还是存在)，final方法不允许覆盖</p>
<h1>抽象</h1>
<p>关键字<code>abstract</code>修饰方法和类，表示“尚未实现”</p>
<p>抽象类：通常作为其它类的super类，父类</p>
<p>抽象方法：没有方法体，直接以分号结束，抽象类可以没有抽象方法，有抽象方法必须为抽象类</p>
<p>抽象类的引用：抽象类虽然不能实例化，但是可以引用，作为向上转型的桥梁，将子类实例传递给抽象类的引用实现多态</p>
<p>抽象方法的权限：抽象方法不能被<code>private, final, static</code>修饰，因为需要重写覆盖(override)，还有访问相关的问题</p>
<h1>接口</h1>
<p><code>Interface</code>关键字说明“接口”，接口中可以定义常量和方法，都是默认<code>public abstract</code>的</p>
<p>接口和类的区别：</p>
<ul>
<li>接口不能用于实例化对象</li>
<li>接口没有构造方法</li>
<li>接口所有的方法必须是<code>public abstract</code>，一般建议写上，不写也是默认这种</li>
<li>接口没有成员变量，其变量都是<code>public static final</code>的</li>
<li>接口需要被类实现</li>
<li>接口支持多继承，也就是一个类允许实现多个接口</li>
<li>JDK1.8之后，接口允许包含“默认方法”，使用default修饰</li>
<li>接口之间允许继承，越继承该接口需要实现的方法一般就越多</li>
</ul>
<p>class 类名 implements 接口1[,接口2，接口3…]</p>
<ul>
<li>在“实现类”实现接口时，类要实现接口中的所有方法，否则必须声明为抽象类</li>
<li>类在实现/重写接口的方法时，要保持一致的方法名和参数，返回值可以选择兼容的，权限修饰必须为public，不能缩小修饰范围，否则编译报错</li>
<li>一个类继承多个接口时，多个接口之间的同名方法的返回值需要互相兼容，否则无法同时实现多个接口中的方法，造成编译报错</li>
<li>一个类继承多个接口时，多个接口之间的变量不要同名，否则在实现类里面调用接口的常量时，编译器无法确定调用的是哪一个接口的常量。当然也可以在调用常量的时候说明调用的是哪一个接口的常量</li>
</ul>
<h1>内部类</h1>
<h2 id="成员内部类">成员内部类</h2>
<p>成员内部类是在一个类的内部定义的类，它与外部类之间有特殊关系，因为内部类实例依赖于外部类的实例</p>
<ul>
<li>定义方式：成员内部类是在外部类中定义的，可以像定义其它成员变量一样定义内部类</li>
<li>访问：成员内部类可以访问外部类的成员，包括私有成员</li>
<li>初始化：成员内部类的实例通常需要外部类的实例来初始化</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OuterClass</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> outerVar;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InnerClass</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">            outerVar = <span class="number">10</span>; <span class="comment">// 内部类可以访问外部类的成员</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="局部内部类">局部内部类</h2>
<p>局部内部类是在方法内定义的类，它的作用域仅限于它的方法。局部内部类通常用于需要实现某个接口或者继承某个类的情况</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OuterClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">someMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">LocalInnerClass</span> &#123;</span><br><span class="line">            <span class="comment">// 局部内部类的定义</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="匿名内部类">匿名内部类</h2>
<p>匿名内部类是一种没有显式名称的内部类，通常用于创建临时对象，实现接口或者继承类的情况。通常在创建对象的地方创建，并且可以包含类的定义和初始化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">MyInterface</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OuterClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">someMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">MyInterface</span> <span class="variable">anonymous</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyInterface</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="comment">// 实现接口方法</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>内部类的初始化过程：</strong> 内部类的初始化与外部类的初始化过程是相互独立的。在初始化内部类之前，外部类必须首先初始化。内部类的初始化可以在需要时进行，它不会随着外部类的加载而立即发生。</p>
<p><strong>内部类的调用情况：</strong> 内部类可以通过外部类的实例来访问，也可以通过创建内部类的实例来访问。外部类可以访问内部类的成员，前提是内部类的成员具有适当的可见性修饰符（例如，<code>public</code>、<code>protected</code>、<code>default</code> 或 <code>private</code>）。</p>
<p><strong>内部类的多重嵌套：</strong> Java支持内部类的多重嵌套，即一个内部类可以包含另一个内部类，可以嵌套多层次。这种多重嵌套通常用于创建复杂的数据结构或实现某些设计模式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OuterClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InnerClass1</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InnerClass2</span> &#123;</span><br><span class="line">            <span class="comment">// 多重嵌套的内部类</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还可以为内部类写一个私有的返回外部类对象的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="title function_">xxxxxxx</span><span class="params">(外部类名字)</span> getOuterClass()&#123;</span><br><span class="line">    <span class="keyword">return</span> xxxxxxx(外部类名字).<span class="built_in">this</span>.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="内部类的初始化过程">内部类的初始化过程</h3>
<ol>
<li><strong>加载外部类：</strong> 在使用内部类之前，首先要加载外部类。这包括查找外部类的字节码文件并加载它，但不会初始化内部类。</li>
<li><strong>初始化外部类：</strong> 如果外部类有静态成员，静态初始化块或静态方法，它们将在加载外部类时进行初始化。这不包括内部类的初始化。</li>
<li><strong>创建外部类的实例：</strong> 如果您需要使用非静态内部类，您需要首先创建外部类的实例。内部类通常与外部类实例相关联。</li>
<li><strong>加载内部类：</strong> 内部类的加载通常是在创建外部类的实例后才发生的。加载内部类时，与加载外部类一样，Java会查找内部类的字节码文件并加载它。内部类的字节码文件通常以外部类名$内部类名.class的形式存在。</li>
<li><strong>初始化内部类：</strong> 内部类的初始化是在加载内部类后，首次使用它之前进行的。这包括静态初始化块、静态成员和构造函数的执行。</li>
</ol>
<p>需要注意的是，内部类的初始化<strong>仅在需要使用内部类时才会发生</strong>。这意味着如果您从未实例化外部类或从未使用内部类，那么内部类可能永远不会初始化。</p>
<p>下面是一个示例代码，展示了内部类初始化的过程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">javaCopy codepublic <span class="keyword">class</span> <span class="title class_">OuterClass</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;OuterClass static block&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OuterClass</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;OuterClass constructor&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InnerClass</span> &#123;</span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;InnerClass static block&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">InnerClass</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;InnerClass constructor&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">OuterClass</span> <span class="variable">outer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OuterClass</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;Creating OuterClass instance&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        OuterClass.<span class="type">InnerClass</span> <span class="variable">inner</span> <span class="operator">=</span> outer.<span class="keyword">new</span> <span class="title class_">InnerClass</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;Creating InnerClass instance&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>泛型</h1>
<h2 id="泛型方法">泛型方法</h2>
<p>定义泛型方法的规则：</p>
<ul>
<li>所有泛型方法声明都有一个类型参数声明部分（由尖括号分隔），该类型参数声明部分在方法返回类型之前。</li>
<li>每一个类型参数声明部分包含一个或多个类型参数，参数间用逗号隔开。一个泛型参数，也被称为一个类型变量，是用于指定一个泛型类型名称的标识符。</li>
<li>类型参数能被用来声明返回值类型，并且能作为泛型方法得到的实际参数类型的占位符。</li>
<li>泛型方法体的声明和其他方法一样。注意类型参数只能代表引用型类型，不能是原始类型（像 <strong>int、double、char</strong> 等）。</li>
</ul>
<p><strong>java 中泛型标记符：</strong></p>
<ul>
<li><strong>E</strong> - Element (在集合中使用，因为集合中存放的是元素)</li>
<li><strong>T</strong> - Type（Java 类）</li>
<li><strong>K</strong> - Key（键）</li>
<li><strong>V</strong> - Value（值）</li>
<li><strong>N</strong> - Number（数值类型）</li>
<li><strong>？</strong> - 表示不确定的 java 类型</li>
</ul>
<p>泛型标记符是一种习惯上的标准，便于区别实际调用类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericMethodTest</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// 泛型方法 printArray                         </span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> &lt; E &gt; <span class="keyword">void</span> <span class="title function_">printArray</span><span class="params">( E[] inputArray )</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="comment">// 输出数组元素            </span></span><br><span class="line">         <span class="keyword">for</span> ( E element : inputArray )&#123;        </span><br><span class="line">            System.out.printf( <span class="string">&quot;%s &quot;</span>, element );</span><br><span class="line">         &#125;</span><br><span class="line">         System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">( String args[] )</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 创建不同类型数组： Integer, Double 和 Character</span></span><br><span class="line">        Integer[] intArray = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">        Double[] doubleArray = &#123; <span class="number">1.1</span>, <span class="number">2.2</span>, <span class="number">3.3</span>, <span class="number">4.4</span> &#125;;</span><br><span class="line">        Character[] charArray = &#123; <span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;L&#x27;</span>, <span class="string">&#x27;L&#x27;</span>, <span class="string">&#x27;O&#x27;</span> &#125;;</span><br><span class="line"> </span><br><span class="line">        System.out.println( <span class="string">&quot;整型数组元素为:&quot;</span> );</span><br><span class="line">        printArray( intArray  ); <span class="comment">// 传递一个整型数组</span></span><br><span class="line"> </span><br><span class="line">        System.out.println( <span class="string">&quot;\n双精度型数组元素为:&quot;</span> );</span><br><span class="line">        printArray( doubleArray ); <span class="comment">// 传递一个双精度型数组</span></span><br><span class="line"> </span><br><span class="line">        System.out.println( <span class="string">&quot;\n字符型数组元素为:&quot;</span> );</span><br><span class="line">        printArray( charArray ); <span class="comment">// 传递一个字符型数组</span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">整型数组元素为:</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> </span><br><span class="line"></span><br><span class="line">双精度型数组元素为:</span><br><span class="line"><span class="number">1.1</span> <span class="number">2.2</span> <span class="number">3.3</span> <span class="number">4.4</span> </span><br><span class="line"></span><br><span class="line">字符型数组元素为:</span><br><span class="line">H E L L O </span><br></pre></td></tr></table></figure>
<p>类型参数是可以有界的</p>
<ul>
<li>上界：<code>&lt;T extends balabla&gt;</code>，表示T代表的只能是<code>balabala</code>及其子类，同时可以声明多个上界，用<code>&amp;</code>分隔，不建议，有限制规则</li>
<li>下界：<code>&lt;T super balabala&gt;</code>，表示T代表的只能是<code>balabala</code>及其超类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MaximumTest</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// 比较三个值并返回最大值</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;T&gt;&gt; T <span class="title function_">maximum</span><span class="params">(T x, T y, T z)</span></span><br><span class="line">   &#123;                     </span><br><span class="line">      <span class="type">T</span> <span class="variable">max</span> <span class="operator">=</span> x; <span class="comment">// 假设x是初始最大值</span></span><br><span class="line">      <span class="keyword">if</span> ( y.compareTo( max ) &gt; <span class="number">0</span> )&#123;</span><br><span class="line">         max = y; <span class="comment">//y 更大</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ( z.compareTo( max ) &gt; <span class="number">0</span> )&#123;</span><br><span class="line">         max = z; <span class="comment">// 现在 z 更大           </span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> max; <span class="comment">// 返回最大对象</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">( String args[] )</span></span><br><span class="line">   &#123;</span><br><span class="line">      System.out.printf( <span class="string">&quot;%d, %d 和 %d 中最大的数为 %d\n\n&quot;</span>,</span><br><span class="line">                   <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, maximum( <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> ) );</span><br><span class="line"> </span><br><span class="line">      System.out.printf( <span class="string">&quot;%.1f, %.1f 和 %.1f 中最大的数为 %.1f\n\n&quot;</span>,</span><br><span class="line">                   <span class="number">6.6</span>, <span class="number">8.8</span>, <span class="number">7.7</span>, maximum( <span class="number">6.6</span>, <span class="number">8.8</span>, <span class="number">7.7</span> ) );</span><br><span class="line"> </span><br><span class="line">      System.out.printf( <span class="string">&quot;%s, %s 和 %s 中最大的数为 %s\n&quot;</span>,<span class="string">&quot;pear&quot;</span>,</span><br><span class="line">         <span class="string">&quot;apple&quot;</span>, <span class="string">&quot;orange&quot;</span>, maximum( <span class="string">&quot;pear&quot;</span>, <span class="string">&quot;apple&quot;</span>, <span class="string">&quot;orange&quot;</span> ) );</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>, <span class="number">4</span> 和 <span class="number">5</span> 中最大的数为 <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="number">6.6</span>, <span class="number">8.8</span> 和 <span class="number">7.7</span> 中最大的数为 <span class="number">8.8</span></span><br><span class="line"></span><br><span class="line">pear, apple 和 orange 中最大的数为 pear</span><br></pre></td></tr></table></figure>
<p>类型通配符<code>?</code>代表具体的类型参数。例如 <strong>List&lt;?&gt;</strong> 在逻辑上是 <code>List&lt;String&gt;,List&lt;Integer&gt;</code> 等所有 <strong>List&lt;具体类型实参&gt;</strong> 的父类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericTest</span> &#123;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;String&gt; name = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        List&lt;Integer&gt; age = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        List&lt;Number&gt; number = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Number&gt;();</span><br><span class="line">        </span><br><span class="line">        name.add(<span class="string">&quot;icon&quot;</span>);</span><br><span class="line">        age.add(<span class="number">18</span>);</span><br><span class="line">        number.add(<span class="number">314</span>);</span><br><span class="line"> </span><br><span class="line">        getData(name);</span><br><span class="line">        getData(age);</span><br><span class="line">        getData(number);</span><br><span class="line">       </span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">getData</span><span class="params">(List&lt;?&gt; data)</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;data :&quot;</span> + data.get(<span class="number">0</span>));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">data :icon</span><br><span class="line">data :<span class="number">18</span></span><br><span class="line">data :<span class="number">314</span></span><br></pre></td></tr></table></figure>
<h2 id="泛型类">泛型类</h2>
<p>泛型类的声明和非泛型类的声明类似，除了在类名后面添加了类型参数声明部分。<code>class &lt;T&gt;</code></p>
<p>和泛型方法一样，泛型类的类型参数声明部分也包含一个或多个类型参数，参数间用逗号隔开。一个泛型参数，也被称为一个类型变量，是用于指定一个泛型类型名称的标识符。因为他们接受一个或多个参数，这些类被称为参数化的类或参数化的类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Box</span>&lt;T&gt; &#123;</span><br><span class="line">   </span><br><span class="line">  <span class="keyword">private</span> T t;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(T t)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.t = t;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Box&lt;Integer&gt; integerBox = <span class="keyword">new</span> <span class="title class_">Box</span>&lt;Integer&gt;();</span><br><span class="line">    Box&lt;String&gt; stringBox = <span class="keyword">new</span> <span class="title class_">Box</span>&lt;String&gt;();</span><br><span class="line"> </span><br><span class="line">    integerBox.add(<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">10</span>));</span><br><span class="line">    stringBox.add(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;菜鸟教程&quot;</span>));</span><br><span class="line"> </span><br><span class="line">    System.out.printf(<span class="string">&quot;整型值为 :%d\n\n&quot;</span>, integerBox.get());</span><br><span class="line">    System.out.printf(<span class="string">&quot;字符串为 :%s\n&quot;</span>, stringBox.get());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>文件IO</h1>
<p><code>File file = new File(Path)</code>，创建新的文件对象，文件对象有很多方法</p>
<p><code>File.createNewFile</code>，需要有对应的目录，如果父目录不存在就会报错</p>
<p><code>File.getParentFile()</code>，获取父目录文件，如果文件不存在就需要创建父目录</p>
<p>创建父目录有两种</p>
<p><code>File.mkdir()</code>创建单级目录</p>
<p><code>File.mkdirs()</code>创建多级父目录，是一个递归过程</p>
<ul>
<li><code>File.exists()</code></li>
<li><code>File.isDirectory()</code>返回是否是目录</li>
<li><code>File.isFile()</code>是否是文件</li>
<li><code>File.delete()</code>，如果是文件就直接删除，如果是空目录就直接删除，否则需要递归删除文件</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">deleteDirectory</span><span class="params">(File directory)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (directory.isDirectory()) &#123;</span><br><span class="line">            File[] files = directory.listFiles();</span><br><span class="line">            <span class="keyword">if</span> (files != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (file.isDirectory()) &#123;</span><br><span class="line">                        <span class="comment">// 递归删除子目录</span></span><br><span class="line">                        deleteDirectory(file);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        file.delete(); <span class="comment">// 删除文件</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        directory.delete(); <span class="comment">// 删除空目录</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>文件复制</p>
<p>首先是普通的文件复制</p>
<p>给定源文件路径和目标文件路径，拷贝内容</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">copyFile</span><span class="params">(String sourceFile,String targetFile)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(targetFile);</span><br><span class="line">        file.createNewFile();</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(sourceFile));</span><br><span class="line">        <span class="type">BufferedWriter</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(targetFile));</span><br><span class="line">        <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span>((line = reader.readLine())!=<span class="literal">null</span>)&#123;</span><br><span class="line">            writer.write(line);</span><br><span class="line">            writer.newLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>然后是目录文件的递归复制</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">copyDirectory</span><span class="params">(String sourceDir,String targetDir)</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">file1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(sourceDir);</span><br><span class="line">        <span class="type">File</span> <span class="variable">file2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(targetDir,file1.getName());</span><br><span class="line">        <span class="keyword">if</span>(file1.isDirectory())&#123;</span><br><span class="line">            File files[]= file1.listFiles();</span><br><span class="line">            file2.mkdir();</span><br><span class="line">            <span class="keyword">for</span>(File fi:files)&#123;</span><br><span class="line">                <span class="keyword">if</span>(fi.isDirectory())&#123;</span><br><span class="line">                    copyDirectory(fi.toString(),file2.toString());</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;<span class="comment">//是文件</span></span><br><span class="line">                    <span class="type">File</span> <span class="variable">file3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(file2.toString(),fi.getName());</span><br><span class="line">                    copyFile(fi.toString(),file3.toString());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//是文件</span></span><br><span class="line">            copyFile(file1.toString(),file2.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="字节流Byte-Steams">字节流Byte Steams</h3>
<p><code>InputStream</code>和<code>OutputStream</code>是所有字节流的基类</p>
<ol>
<li><code>FileInputStream</code>从文件中读取字节</li>
<li><code>FileOutputStream</code>将字节写入文件</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;input.txt&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">data</span> <span class="operator">=</span> fis.read();</span><br><span class="line"><span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;output.txt&quot;</span>);</span><br><span class="line">fos.write(data);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol start="3">
<li><code>BufferedInputStream</code>和<code>BufferedOutputStream</code>提供缓冲，提升效率</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;input.txt&quot;</span>));</span><br><span class="line"><span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;output.txt&quot;</span>));</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol start="4">
<li><code>ByteArrayInputStream</code>从字节数组中读取数据</li>
<li><code>ByteArrayOtputStream</code>将数据写入字节数组</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">byte</span>[] data = &#123; <span class="number">65</span>, <span class="number">66</span>, <span class="number">67</span> &#125;;</span><br><span class="line"><span class="type">ByteArrayInputStream</span> <span class="variable">bais</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(data);</span><br><span class="line"><span class="type">ByteArrayOutputStream</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="字符流Character-Streams">字符流Character Streams</h3>
<p><code>Reader</code>和<code>Writer</code>是所有字符流的基类</p>
<ol>
<li><code>FileReader</code>从文件中读取字符</li>
<li><code>FileWriter</code>将字符写入文件</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">FileReader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;input.txt&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">data</span> <span class="operator">=</span> fr.read();</span><br><span class="line"><span class="type">FileWriter</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;output.txt&quot;</span>);</span><br><span class="line">fw.write(data);</span><br></pre></td></tr></table></figure>
<ol start="3">
<li><code>BufferedReader</code>和<code>BufferedWriter</code>提供了缓冲，提升xiaol</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Reader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;input.txt&quot;</span>));</span><br><span class="line"><span class="type">Writer</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;output.txt&quot;</span>));</span><br></pre></td></tr></table></figure>
<ol start="4">
<li><code>CharArrayReader</code>从字符数组里读取数据</li>
<li><code>CharArrayWriter</code>将数据写入字符数组</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span>[] data = &#123; <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span> &#125;;</span><br><span class="line"><span class="type">CharArrayReader</span> <span class="variable">car</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CharArrayReader</span>(data);</span><br><span class="line"><span class="type">CharArrayWriter</span> <span class="variable">caw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CharArrayWriter</span>();</span><br></pre></td></tr></table></figure>
<h3 id="序列化操作">序列化操作</h3>
<p><code>ObjectOutputStream</code>将对象序列化成字节流</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">FileOutputStream</span> <span class="variable">fileOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(path);</span><br><span class="line"><span class="type">ObjectOutputStream</span> <span class="variable">objectOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(fileOutputStream);</span><br><span class="line"><span class="type">FavoriteCommodityList</span> <span class="variable">favoriteCommodityList</span> <span class="operator">=</span> Variable.user.getFavoriteCommodityList();</span><br><span class="line"><span class="keyword">for</span> (FavoriteCommodity m : favoriteCommodityList.getList()) &#123;</span><br><span class="line">    objectOutputStream.writeObject(m);<span class="comment">//将对象转换成字节序列写入文件，但是这个对象仍然存在，只是备份了一份成字节</span></span><br><span class="line">&#125;</span><br><span class="line">fileOutputStream.close();</span><br><span class="line">objectOutputStream.close();</span><br></pre></td></tr></table></figure>
<p><code>ObjectInputStream</code>将字节流重新返回成对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(path);</span><br><span class="line"><span class="type">ObjectInputStream</span> <span class="variable">objectInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(fileInputStream);</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> objectInputStream.readObject();<span class="comment">//将字节流重新转化为对象，用Object</span></span><br><span class="line">        <span class="keyword">if</span>(obj <span class="keyword">instanceof</span> FavoriteCommodity)&#123;</span><br><span class="line">            <span class="type">FavoriteCommodity</span> <span class="variable">item</span> <span class="operator">=</span> (FavoriteCommodity) obj;<span class="comment">//将对象实例转型</span></span><br><span class="line">            Variable.user.getFavoriteCommodityList().addCommodity(item);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">fileInputStream.close();</span><br><span class="line">objectInputStream.close();</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>面向对象</category>
      </categories>
      <tags>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title>python学习</title>
    <url>/2023/04/25/python%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>开启一门新的语言学习是非常痛苦的，但是也充满着新奇与成就感，就像当初学习c的时候。</p>
<p>本文参照《python程序设计基础与应用》（董付国）的路线进行学习</p>
<span id="more"></span>
<h1>python 概述</h1>
<h1>内置对象、运算符、表达式、关键字</h1>
<h2 id="python-常用内置对象">python 常用内置对象</h2>
<p>数字（int，float，complex），字符串（str），字节串（bytes）</p>
<p>列表（list），元组（tuple），字典（dict），集合（set）</p>
<p>布尔类型（bool），空类型（None Type），异常（Error）</p>
<p>文件，其它可迭代对象，编程单元</p>
<h3 id="常量与变量">常量与变量</h3>
<p>常量：不能改变的字面值，比如<code>3</code>,<code>&quot;hello world&quot;</code>,<code>(3,4,5)</code></p>
<p>变量：一般值可以变化，数值和类型都可以改变，python创建变量不需要声明类型和变量名。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = <span class="number">5</span></span><br><span class="line">x = <span class="string">&quot;hello world&quot;</span></span><br><span class="line">x = (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p>Ps: 赋值语句的执行顺序是：先计算右侧表达式的值，然后在内存中寻找一个位置把这个值存进去，最后创建变量并<strong>引用</strong>这个内存地址。变量不直接存储值，而是<strong>存储了值的地址或者引用</strong>，因此变量类型随时可变。</p>
<h3 id="整数、实数、复数">整数、实数、复数</h3>
<p><code>python</code>的内置数字类型有整数，实数和复数。</p>
<p>整数的常见进制：</p>
<ul>
<li>二进制：以<code>0b</code>开头，每一位数字是<code>0~1</code></li>
<li>八进制：以<code>0o</code>开头，每一位数字是<code>0~7</code></li>
<li>十六进制：以<code>0x</code>开头，每一位数字是<code>0~9,a~f</code></li>
</ul>
<p><code>python</code>支持<strong>任意大</strong>的数字，不必担心数字溢出。实数运算有一定的误差（和c语言类似），因此实数的比较相同常常使用差值</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="built_in">abs</span>(<span class="number">0.4</span> - <span class="number">0.1</span> - <span class="number">0.3</span>) &lt; <span class="number">1e-6</span></span><br></pre></td></tr></table></figure>
<p><code>python</code>内置支持复数运算，形式上和数学上的复数一致</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = <span class="number">3</span> + <span class="number">4j</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y = <span class="number">5</span> + <span class="number">6j</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x + y</span><br><span class="line">(<span class="number">8</span>+<span class="number">10j</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x * y</span><br><span class="line">(-<span class="number">9</span>+<span class="number">38j</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">abs</span>(x)</span><br><span class="line"><span class="number">5.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x.imag</span><br><span class="line"><span class="number">4.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x.real</span><br><span class="line"><span class="number">5.0</span></span><br></pre></td></tr></table></figure>
<p><code>python</code>支持在数字之间插入下划线<code>_</code>以便于区分</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1_000_000</span></span><br><span class="line"><span class="number">1000000</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1_2_3_4</span></span><br><span class="line"><span class="number">1234</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1_2</span> + <span class="number">3_4j</span></span><br><span class="line">(<span class="number">12</span>+<span class="number">34j</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1_2.3_45</span></span><br><span class="line"><span class="number">12.345</span></span><br></pre></td></tr></table></figure>
<h3 id="字符串">字符串</h3>
<p><code>python</code>中没有字符常量与变量，只有字符串常量和变量，<strong>单个字符也是字符串</strong></p>
<p><code>python</code>使用单引号、双引号、三引号作为定界符表示字符串，不同定界符之间可以相互嵌套</p>
<p><code>python 3.x</code>之后支持中文，内置函数<code>len()</code>统计长度的时候，将中文和英文字母都视作一个字符</p>
<p>字符串支持<code>+</code>和<code>*</code>运算</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = <span class="string">&#x27;hello world&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = <span class="string">&quot;python is a good language&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = <span class="string">&#x27;&#x27;&#x27;Tom said, &quot;Let&#x27;s go.&quot;&#x27;&#x27;&#x27;</span>		<span class="comment">#不同定界符的嵌套</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(x)</span><br><span class="line">Tom said, <span class="string">&quot;Let&#x27;s go.&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = <span class="string">&#x27;good &#x27;</span> + <span class="string">&#x27;morning&#x27;</span>				<span class="comment">#字符串拼接</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line"><span class="string">&#x27;good morning&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = <span class="string">&#x27;good &#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = x + <span class="string">&#x27;morning&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line"><span class="string">&#x27;good morning&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x * <span class="number">3</span>								<span class="comment">#字符串重复</span></span><br><span class="line"><span class="string">&#x27;good morninggood morninggood morning&#x27;</span></span><br></pre></td></tr></table></figure>
<h3 id="列表、元组、字典、集合">列表、元组、字典、集合</h3>
<p>列表，元组，字典，集合是<code>python</code>内置的容器对象，其中可包含和持有多个元素</p>
<p>另外，map，zip，filter，enumerate 等迭代器对象是python中常用的内置对象</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]					<span class="comment">#创建列表对象</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x_tuple = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)					<span class="comment">#创建元组对象</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x_dict = &#123;<span class="string">&#x27;a&#x27;</span>:<span class="number">97</span>, <span class="string">&#x27;b&#x27;</span>:<span class="number">98</span>, <span class="string">&#x27;c&#x27;</span>:<span class="number">99</span>&#125;	<span class="comment">#创建字典对象，元素为“键:值”</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x_set = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;					<span class="comment">#创建集合对象</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(x_list[<span class="number">1</span>])					<span class="comment">#下标访问</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(x_tuple[<span class="number">1</span>])					<span class="comment">#下标访问</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(x_dict[<span class="string">&#x27;a&#x27;</span>])					<span class="comment">#下标访问，下标是“键”</span></span><br><span class="line"><span class="number">97</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x_set[<span class="number">1</span>]							<span class="comment">#集合不支持下标访问</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: <span class="string">&#x27;set&#x27;</span> <span class="built_in">object</span> <span class="keyword">is</span> <span class="keyword">not</span> subscriptable</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">3</span> <span class="keyword">in</span> x_set							<span class="comment">#测试成员是否包含在内</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>
<h2 id="python-运算符与表达式">python 运算符与表达式</h2>
<h3 id="算数运算符">算数运算符</h3>
<ol>
<li><code>+</code>不仅可以用于算数的加法，还可以用于列表，元组，字符串的拼接。（不支持不同内置类型的对象之间的相加或者相连）</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">3</span> + <span class="number">5</span> &lt;&lt; <span class="number">1</span>				<span class="comment">#算数优先级高于位运算</span></span><br><span class="line"><span class="number">16</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">3</span> + (<span class="number">5</span> &lt;&lt; <span class="number">1</span>)</span><br><span class="line"><span class="number">13</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] + [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]	<span class="comment">#两个列表的连接</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) + (<span class="number">4</span>,)		<span class="comment">#两个元组的连接</span></span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;abcd&#x27;</span> + <span class="string">&#x27;1234&#x27;</span>			<span class="comment">#两个字符串的连接</span></span><br><span class="line"><span class="string">&#x27;abcd1234&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;A&#x27;</span> + <span class="number">1</span>					<span class="comment">#不同类型的对象，报错</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: can only concatenate <span class="built_in">str</span> (<span class="keyword">not</span> <span class="string">&quot;int&quot;</span>) to <span class="built_in">str</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li><code>*</code>除了算数乘法，还可以用于列表，元组，字符串这几个类型和正整数的乘法，表示序列的重复，生成新的序列对象</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] * <span class="number">3</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) * <span class="number">3</span></span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;abc&#x27;</span> * <span class="number">3</span></span><br><span class="line"><span class="string">&#x27;abcabcabc&#x27;</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>运算符<code>/</code>和<code>//</code>在python中分别表示算数除法和算数整除</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">3</span> / <span class="number">2</span></span><br><span class="line"><span class="number">1.5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">15</span> / <span class="number">4</span></span><br><span class="line"><span class="number">3.75</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">15.0</span> / <span class="number">4</span>	</span><br><span class="line"><span class="number">3.75</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">15</span> // <span class="number">4</span>		<span class="comment">#如果有一个是实数，结果以实数的&quot;形式&quot;呈现</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">15.0</span> // <span class="number">4</span>	<span class="comment">#如果有一个是实数，结果以实数的&quot;形式&quot;呈现</span></span><br><span class="line"><span class="number">3.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>-<span class="number">15</span> // <span class="number">4</span>	<span class="comment">#向下取整</span></span><br><span class="line">-<span class="number">4</span></span><br></pre></td></tr></table></figure>
<ol start="4">
<li><code>%</code>用于取模，还可以用于字符串格式化</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">789</span> % <span class="number">23</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;%c,%d&#x27;</span> % (<span class="number">65</span>,<span class="number">65</span>)	<span class="comment">#将65分别格式化为字符和整数</span></span><br><span class="line"><span class="string">&#x27;A,65&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;%f,%s&#x27;</span> % (<span class="number">65</span>,<span class="number">65</span>)	<span class="comment">#将65分别格式化为实数和字符串</span></span><br><span class="line"><span class="string">&#x27;65.000000,65&#x27;</span></span><br></pre></td></tr></table></figure>
<ol start="5">
<li><code>**</code>表示幂运算</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">3</span> ** <span class="number">2</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">3</span> ** <span class="number">0.5</span></span><br><span class="line"><span class="number">3.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">3</span> ** <span class="number">3</span> ** <span class="number">3</span>		<span class="comment">#幂运算从右往左</span></span><br><span class="line"><span class="number">6561</span></span><br></pre></td></tr></table></figure>
<h3 id="关系运算符">关系运算符</h3>
<p>要求操作数之间可以比较大小，可以连用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1</span> &lt; <span class="number">3</span> &lt; <span class="number">5</span>		<span class="comment">#等价于1 &lt; 3 &amp;&amp; 3&lt; 5</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">3</span> &lt; <span class="number">5</span> &gt; <span class="number">2</span>		<span class="comment">#等价于3 &lt; 5 &amp;&amp; 5 &gt; 2</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;hello&#x27;</span> &gt; <span class="string">&#x27;world&#x27;</span>	<span class="comment">#比较字典序</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] &lt; [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]	<span class="comment">#列表比较类似于字符串</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;hello&#x27;</span> &gt; <span class="number">3</span>			<span class="comment">#不同类型无法比较</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: <span class="string">&#x27;&gt;&#x27;</span> <span class="keyword">not</span> supported between instances of <span class="string">&#x27;str&#x27;</span> <span class="keyword">and</span> <span class="string">&#x27;int&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125; == &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;	<span class="comment">#测试所有元素是否都相等</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>&#125; &gt; &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;	<span class="comment">#测试包含与被包含关系</span></span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>
<h3 id="成员测试运算符">成员测试运算符</h3>
<p><code>in</code>用于测试一个对象是否包含另一个对象</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">3</span> <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">5</span> <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>, <span class="number">1</span>)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;abc&#x27;</span> <span class="keyword">in</span> <span class="string">&#x27;abcdef&#x27;</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> (<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>):</span><br><span class="line">	<span class="built_in">print</span>(i, end=<span class="string">&#x27;\t&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="集合运算符">集合运算符</h3>
<p>集合的交集，并集，对称差集分别采用<code>&amp;, |, ^</code>实现，差集使用<code>-</code>实现</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125; | &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125; &amp; &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">&#123;<span class="number">3</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125; ^ &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125; - &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure>
<h3 id="逻辑运算符">逻辑运算符</h3>
<p>逻辑运算符<code>and, or, not</code>连接条件表达式（类似于c语言的&amp;&amp;，||，！），<code>and 和 or</code>具有逻辑短路，或者是惰性求值的特点，只计算一个表达式必须计算的值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">3</span> &gt; <span class="number">4</span> <span class="keyword">and</span> a &gt; <span class="number">3</span>		<span class="comment">#只求了第一个表达式</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">3</span> &gt; <span class="number">4</span> <span class="keyword">or</span> a &gt; <span class="number">3</span>		<span class="comment">#求了两个表达式，然后才发现a未定义</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">NameError: name <span class="string">&#x27;a&#x27;</span> <span class="keyword">is</span> <span class="keyword">not</span> defined</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">3</span> &lt; <span class="number">5</span> <span class="keyword">or</span> a &gt; <span class="number">3</span>		<span class="comment">#只求了第一个表达式</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">3</span> <span class="keyword">and</span> <span class="number">5</span>			</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">4</span> <span class="keyword">and</span> <span class="number">5</span>&gt;<span class="number">2</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">3</span> <span class="keyword">not</span> <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p><code>and 和 or</code> 的返回值不一定是<code>true 或者 false</code>，而是返回最后一个<strong>计算</strong>的表达式的值，作为整个表达式的值</p>
<p><code>not</code>返回结果一定是<code>true 或者 false</code></p>
<p>补充：<code>python</code>支持<code>访问符号'.'  和 +=，-=， *=， /=，//=， **=， ^=</code>，但是<strong>不支持++和–</strong></p>
<p>但是形式上可以写成<code>++ 和 --</code>， 但是一般有不同解释含义</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>i = <span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>++i			<span class="comment">#解释为两个正号</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>+(+i)		<span class="comment">#等价于++i</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>i++			<span class="comment">#不支持，报错</span></span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span></span><br><span class="line">    i++</span><br><span class="line">       ^</span><br><span class="line">SyntaxError: invalid syntax</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>--i			<span class="comment">#解释为两个负号</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>---i		<span class="comment">#解释为三个负号</span></span><br><span class="line">-<span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>i--			<span class="comment">#不支持，报错</span></span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span></span><br><span class="line">    i--</span><br><span class="line">       ^</span><br><span class="line">SyntaxError: invalid syntax</span><br></pre></td></tr></table></figure>
<h2 id="python-常用内置函数用法">python 常用内置函数用法</h2>
<p>内置函数不需要导入任何外部模块就可以直接使用，具有非常快的运行速度。</p>
<ul>
<li>通常使用<code>&gt;&gt;&gt; dir(__builtins__)</code>查看所有的内置函数和内置对象</li>
<li>使用<code>help(函数名)</code>可以查看某个函数的使用方法</li>
</ul>
<h3 id="类型转换与判断">类型转换与判断</h3>
<h4 id="bin-、oct-、hex">bin()、oct()、hex()</h4>
<p>内置函数<code>bin()、oct()、hex()</code>用来将整数转换成为二进制、八进制、十六进制，这三个函数都要求参数必须为<strong>整数</strong>，但是<strong>不要求一定是十进制</strong>，格式为<code>bin(x),oct(x),hex(x)</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">bin</span>(<span class="number">555</span>)</span><br><span class="line"><span class="string">&#x27;0b1000101011&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">oct</span>(<span class="number">555</span>)</span><br><span class="line"><span class="string">&#x27;0o1053&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">hex</span>(<span class="number">555</span>)</span><br><span class="line"><span class="string">&#x27;0x22b&#x27;</span></span><br></pre></td></tr></table></figure>
<h4 id="float-、complex">float()、complex()</h4>
<p><code>float()</code>用来将其它类型数据转换为实数，格式为<code>float(x)</code>，x为数字或字符串</p>
<p><code>complex()</code>函数可以用来生成复数，格式为<code>complex(x, y)</code>，x和y分别代表实部和虚部，如果只有一个数字<code>complex(x)</code>，x代表实部</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">float</span>(<span class="number">3</span>)		<span class="comment">#整数转换为实数</span></span><br><span class="line"><span class="number">3.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">float</span>(<span class="string">&#x27;3.5&#x27;</span>)	<span class="comment">#数字字符转换为实数</span></span><br><span class="line"><span class="number">3.5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)	<span class="comment">#无穷大，inf不区分大小写</span></span><br><span class="line">inf</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">complex</span>(<span class="number">3</span>)		<span class="comment">#指定实部，创建复数</span></span><br><span class="line">(<span class="number">3</span>+<span class="number">0j</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">complex</span>(<span class="number">3</span>, <span class="number">5</span>)	<span class="comment">#指定实部和虚部</span></span><br><span class="line">(<span class="number">3</span>+<span class="number">5j</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">complex</span>(<span class="string">&#x27;inf&#x27;</span>)	</span><br><span class="line">(inf+<span class="number">0j</span>)</span><br></pre></td></tr></table></figure>
<h4 id="int">int()</h4>
<p>内置函数<code>int()</code>用来获取实数的整体部分，或者把字符串按照指定的进制转换为十进制数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">int</span>(<span class="number">3.13</span>)			<span class="comment">#获取整数部分</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">int</span>(<span class="string">&#x27;111&#x27;</span>, <span class="number">2</span>)		<span class="comment">#按照二进制解析这个字符串，再换成十进制</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">int</span>(<span class="string">&#x27;1111&#x27;</span>, <span class="number">8</span>)		<span class="comment">#八进制解析，换成十进制</span></span><br><span class="line"><span class="number">585</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">int</span>(<span class="string">&#x27;1234&#x27;</span>, <span class="number">16</span>)		<span class="comment">#十六进制解析，换成十进制</span></span><br><span class="line"><span class="number">4660</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">int</span>(<span class="string">&#x27;0o1234&#x27;</span>, <span class="number">0</span>)	<span class="comment">#0表示按照字符串自身指定的进制解析，这里按照八进制</span></span><br><span class="line"><span class="number">668</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">int</span>(<span class="string">&#x27;   345\n\t&#x27;</span>)	<span class="comment">#忽略两侧空白符</span></span><br><span class="line"><span class="number">345</span></span><br></pre></td></tr></table></figure>
<h4 id="ord-、chr-、str">ord()、chr()、str()</h4>
<p><code>ord()</code>函数返回单个字符的ascll码，<code>chr()</code>函数返回asclll码对应的字符，<code>str()</code>函数直接将任意类型参数转换为字符串</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"><span class="number">97</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">chr</span>(<span class="number">65</span>)</span><br><span class="line"><span class="string">&#x27;A&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">str</span>(<span class="number">1234</span>)		<span class="comment">#直接变成字符串类型</span></span><br><span class="line"><span class="string">&#x27;1234&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">str</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"><span class="string">&#x27;[1, 2, 3, 4]&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">str</span>((<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>))</span><br><span class="line"><span class="string">&#x27;(1, 2, 3)&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">str</span>(&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;)</span><br><span class="line"><span class="string">&#x27;&#123;1, 2, 3&#125;&#x27;</span></span><br></pre></td></tr></table></figure>
<h4 id="list-、tuple-、dict-、set">list()、tuple()、dict()、set()</h4>
<p>同理，<code>list()、tuple()、dict()、set()</code>分别用来把参数指定的可迭代对象转换为列表、元组、字典、集合。或者不带参数的时候直接创建空列表、空元组、空字典、空集合。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">5</span>))</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">tuple</span>(_)			<span class="comment">#_代表上一次的正确输出</span></span><br><span class="line">(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">dict</span>(<span class="built_in">zip</span>(<span class="string">&#x27;1234&#x27;</span>, <span class="string">&#x27;abcde&#x27;</span>))</span><br><span class="line">&#123;<span class="string">&#x27;1&#x27;</span>: <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;2&#x27;</span>: <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;3&#x27;</span>: <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;4&#x27;</span>: <span class="string">&#x27;d&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">set</span>(<span class="string">&#x27;1112234&#x27;</span>)		<span class="comment">#自动去重</span></span><br><span class="line">&#123;<span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;1&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>
<h4 id="eval">eval()</h4>
<p>内置函数<code>eval()</code>用来计算字符串的值，有时也可以用来实现类型转换</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">eval</span>(<span class="string">&#x27;3+5&#x27;</span>)</span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">eval</span>(<span class="string">b&#x27;3+5&#x27;</span>)	<span class="comment">#引号前面加上b变成字节串</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">eval</span>(<span class="string">&#x27;9&#x27;</span>)</span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">eval</span>(<span class="string">&#x27;09&#x27;</span>)		<span class="comment">#不合法的前导0</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">  File <span class="string">&quot;&lt;string&gt;&quot;</span>, line <span class="number">1</span></span><br><span class="line">    09</span><br><span class="line">    ^</span><br><span class="line">SyntaxError: leading zeros <span class="keyword">in</span> decimal integer literals are <span class="keyword">not</span> permitted; use an 0o prefix <span class="keyword">for</span> octal integers</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">int</span>(<span class="string">&#x27;09&#x27;</span>)</span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">str</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]))</span><br><span class="line">[<span class="string">&#x27;[&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;,&#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;,&#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;,&#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;]&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">eval</span>(<span class="built_in">str</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]))</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure>
<h4 id="type-、isinstance">type()、isinstance()</h4>
<p>内置函数<code>type() 和 isinstance()</code>可以查看和判断数据类型</p>
<p><code>type(obj), isinstance(obj, type)</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>([<span class="number">2</span>])</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;list&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(&#123;<span class="number">3</span>&#125;) <span class="keyword">in</span> (<span class="built_in">list</span>, <span class="built_in">tuple</span>, <span class="built_in">dict</span>)</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>(<span class="number">3</span>, <span class="built_in">int</span>)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>(<span class="number">3j</span>, (<span class="built_in">int</span>, <span class="built_in">float</span>, <span class="built_in">complex</span>))</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>
<h4 id="max-、min-、sum">max()、min()、sum()</h4>
<p><code>max()、min()、sum()</code>分别用于计算列表、元组和其它包含有限个可迭代对象中所有元素最大值，最小值以及所有元素之和</p>
<p>​	下面代码生成十个随机数的列表，然后分别计算列表的最大值，最小值，所有元素之和，平均值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> choices</span><br><span class="line">a = choices(<span class="built_in">range</span>(<span class="number">1</span>,<span class="number">101</span>), k=<span class="number">10</span>)	<span class="comment">#10个1~100之间的随机数</span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">max</span>(a),<span class="built_in">min</span>(a),<span class="built_in">sum</span>(a))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sum</span>(a)/<span class="built_in">len</span>(a))</span><br></pre></td></tr></table></figure>
<p><code>max()、min()</code>函数还支持key参数，key就是比较规则，可以是函数、lambda表达式或者其它类型的可调用对象</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">max</span>(<span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;111&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;2&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">max</span>([<span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;111&#x27;</span>])		<span class="comment">#列表的元素是字符串，按照字典序比较</span></span><br><span class="line"><span class="string">&#x27;2&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">max</span>([<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;111&#x27;</span>], key=<span class="built_in">len</span>)</span><br><span class="line"><span class="string">&#x27;111&#x27;</span></span><br></pre></td></tr></table></figure>
<h3 id="基本输入和输出">基本输入和输出</h3>
<p><code>input() 和 output()</code>是python的基本输入输出函数，<code>input()</code>用于接收用户键盘输入，<code>output()</code>用于把数据按照指定的格式输出的指定位置。</p>
<p>不论输入什么内容，<code>input()</code>一律返回字符串，必要的时候需要用到<code>int()、float()、eval()</code>等函数进行输入转换</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = <span class="built_in">input</span>(<span class="string">&#x27;please input: &#x27;</span>)		<span class="comment">#输入提示</span></span><br><span class="line">please <span class="built_in">input</span>: <span class="number">345</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line"><span class="string">&#x27;345&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(x)</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;str&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">int</span>(x)</span><br><span class="line"><span class="number">345</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">eval</span>(x)</span><br><span class="line"><span class="number">345</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = <span class="built_in">input</span>(<span class="string">&#x27;please input: &#x27;</span>)</span><br><span class="line">please <span class="built_in">input</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line"><span class="string">&#x27;[1, 2, 3]&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(x)</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;str&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">eval</span>(x)			<span class="comment">#这里不要用list()转换，否则变成下面那样</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(x)</span><br><span class="line">[<span class="string">&#x27;[&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;,&#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;,&#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;]&#x27;</span>]</span><br></pre></td></tr></table></figure>
<p><code>print()</code>函数默认格式:</p>
<p><code>print(value1, value2, value3, ..., sep=' ', end='\n', file=sys.stdout, flush=False)</code></p>
<ul>
<li><code>sep</code>参数为分隔符，默认为空格，可以修改为指定样式</li>
<li><code>end</code>参数为结束符，默认为换行符</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, sep=<span class="string">&#x27;\t&#x27;</span>)	<span class="comment">#分隔为tab</span></span><br><span class="line"><span class="number">1</span>	<span class="number">3</span>	<span class="number">5</span>	<span class="number">7</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    <span class="built_in">print</span>(i, end=<span class="string">&#x27; &#x27;</span>)		<span class="comment">#每次打印不换行</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span></span><br></pre></td></tr></table></figure>
<h3 id="排序与逆序">排序与逆序</h3>
<p><code>sorted()</code>函数可以对列表，元组，字典，集合或者其它有限长度的可迭代对象进行排序并且返回新列表，支持<strong>key</strong>参数指定排序规则，</p>
<p><code>sorted()</code> 函数有三个参数：<code>iterable</code>、<code>key</code> 和 <code>reverse</code>。其中 <code>iterable</code> 是必需的序列，而 <code>key</code> 和 <code>reverse</code> 是可选的。</p>
<p><code>sorted(iterable, key = None, reverse = False)</code></p>
<ul>
<li><code>iterable</code>: 必需。要排序的序列（列表、元组、字符串）或集合（字典、集合、冻结集合）或任何其他迭代器。</li>
<li><code>key</code>: 可选。用于确定排序顺序的函数。默认值为 <code>None</code>。</li>
<li><code>reverse</code>: 可选。布尔值。如果为 <code>False</code>，则按升序排列；如果为 <code>True</code>，则按降序排列。默认值为 <code>False</code>。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">11</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> random</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>random.shuffle(x)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line">[<span class="number">8</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">10</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sorted</span>(x)</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sorted</span>(x, key=<span class="keyword">lambda</span> item:<span class="built_in">len</span>(<span class="built_in">str</span>(item)), reverse=<span class="literal">True</span>)</span><br><span class="line"><span class="comment">#转换为字符串长度之后，按照降序排列</span></span><br><span class="line">[<span class="number">10</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sorted</span>(x,key=<span class="built_in">str</span>)	<span class="comment">#字符串升序</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x		<span class="comment">#排序之后并不会改变原本的序列</span></span><br><span class="line">[<span class="number">8</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">10</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = [<span class="string">&#x27;aaaa&#x27;</span>, <span class="string">&#x27;bc&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;ba&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sorted</span>(x, key=<span class="keyword">lambda</span> item: (<span class="built_in">len</span>(item), item))</span><br><span class="line"><span class="comment">#多关键字排序，先长度，再正常比较（字典序）</span></span><br><span class="line">[<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;ba&#x27;</span>, <span class="string">&#x27;bc&#x27;</span>, <span class="string">&#x27;aaaa&#x27;</span>]</span><br></pre></td></tr></table></figure>
<p><code>reversed()</code>函数可以对可迭代对象（生成器对象和zip、map、filter、enumerate等类似迭代器对象除外）进行翻转（首尾交换）并返回可迭代的reversed对象，不会改变原始序列</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = [<span class="string">&#x27;aaaa&#x27;</span>, <span class="string">&#x27;bc&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;ba&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">reversed</span>(x))		<span class="comment">#reversed对象是迭代器对象，返回值</span></span><br><span class="line">[<span class="string">&#x27;ba&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;bc&#x27;</span>, <span class="string">&#x27;aaaa&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">reversed</span>(x)</span><br><span class="line">&lt;list_reverseiterator <span class="built_in">object</span> at <span class="number">0x00000241DFBD6980</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> item <span class="keyword">in</span> <span class="built_in">reversed</span>(x):		<span class="comment">#这里有点类似c语言的指针和数组？（不是很懂，但是感觉可以类比）</span></span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(item, end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">...</span><br><span class="line">ba b d bc aaaa</span><br></pre></td></tr></table></figure>
<h3 id="枚举与迭代">枚举与迭代</h3>
<p><code>enumerate()</code>函数可以用来枚举可迭代对象中的元素，返回可迭代的enumerate对象，其中每个元素都是包含索引和值的元组。</p>
<p>既可以把enumerate转换成为列表，元组 ，集合，也可以直接用for循环遍历其中的元素</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">enumerate</span>(<span class="string">&#x27;abcd&#x27;</span>)</span><br><span class="line">&lt;<span class="built_in">enumerate</span> <span class="built_in">object</span> at <span class="number">0x00000241DF814F80</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">enumerate</span>(<span class="string">&#x27;abcd&#x27;</span>))</span><br><span class="line">[(<span class="number">0</span>, <span class="string">&#x27;a&#x27;</span>), (<span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>), (<span class="number">2</span>, <span class="string">&#x27;c&#x27;</span>), (<span class="number">3</span>, <span class="string">&#x27;d&#x27;</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">enumerate</span>([<span class="string">&#x27;your&#x27;</span>, <span class="string">&#x27;name&#x27;</span>]))</span><br><span class="line">[(<span class="number">0</span>, <span class="string">&#x27;your&#x27;</span>), (<span class="number">1</span>, <span class="string">&#x27;name&#x27;</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> index, value <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="built_in">range</span>(<span class="number">10</span>,<span class="number">15</span>)):</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>((index,value), end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">...</span><br><span class="line">(<span class="number">0</span>, <span class="number">10</span>) (<span class="number">1</span>, <span class="number">11</span>) (<span class="number">2</span>, <span class="number">12</span>) (<span class="number">3</span>, <span class="number">13</span>) (<span class="number">4</span>, <span class="number">14</span>)</span><br></pre></td></tr></table></figure>
<h3 id="map-、reduce-、filter-函数">map()、reduce()、filter()函数</h3>
<p>内置函数<code>map()</code>把一个可调用对象<code>func</code>依次映射到一个或者多个可迭代对象的每个元素上，返回一个<code>map</code>对象，<code>map</code>对象属于迭代器类型，其中每个元素是原可迭代对象元素经过<code>func</code>处理后的结果，不对原可迭代对象做任何修改</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">str</span>, <span class="built_in">range</span>(<span class="number">5</span>)))		<span class="comment">#把range对象中的元素转换为字符串</span></span><br><span class="line">[<span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;4&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">add5</span>(<span class="params">v</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> v+<span class="number">5</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">map</span>(add5,<span class="built_in">range</span>(<span class="number">10</span>)))		<span class="comment">#把单参数函数映射到一个可迭代对象的所有元素</span></span><br><span class="line">[<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">x, y</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> x+y</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">map</span>(add, <span class="built_in">range</span>(<span class="number">5</span>), <span class="built_in">range</span>(<span class="number">5</span>, <span class="number">10</span>)))	<span class="comment">#把双参数函数映射到两个可迭代对象上</span></span><br><span class="line">[<span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">11</span>, <span class="number">13</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x, y: x+y, <span class="built_in">range</span>(<span class="number">5</span>), <span class="built_in">range</span>(<span class="number">5</span>, <span class="number">10</span>)))</span><br><span class="line"><span class="comment">#使用lambda同样实现功能，这个lambda表达式相当于一个函数</span></span><br><span class="line">[<span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">11</span>, <span class="number">13</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> random</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = random.randint(<span class="number">1</span>, <span class="number">1e30</span>)		<span class="comment">#生成指定范围内的随机数</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line"><span class="number">666450695718944706028625082522</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">str</span>(x)))		<span class="comment">#提取大整数每位上的数字</span></span><br><span class="line">[<span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">2</span>]</span><br></pre></td></tr></table></figure>
<p>标准库<code>functools</code>中的函数<code>reduce()</code>可以将一个接收<strong>两个参数的函数</strong>以迭代的方式<strong>从左往右</strong>依次作用到一个<strong>序列</strong>或者<strong>迭代器对象</strong>的所有元素上，并且允许指定一个初始值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>reduce(<span class="keyword">lambda</span> x, y: x+y, <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">8</span>))	<span class="comment">#lambda表达式相当于函数</span></span><br><span class="line">这个程序的执行等效于	((((((<span class="number">1</span>+<span class="number">2</span>)+<span class="number">3</span>)+<span class="number">4</span>)+<span class="number">5</span>)+<span class="number">6</span>)+<span class="number">7</span>)</span><br></pre></td></tr></table></figure>
<p>内置函数<code>filter()</code>将一个单参数函数作用到一个可迭代对象上，返回其中使得该函数返回值等价于<code>True</code>的那些元素组成的filter对象，如果指定函数为<code>None</code>，则返回可迭代对象中等价于<code>True</code>的元素。filter对象是迭代器对象，在使用时可以把filter对象转换为列表，元组，集合，也可以使用for循环直接遍历其中的元素</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>seq = [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;x41&#x27;</span>, <span class="string">&#x27;?!&#x27;</span>, <span class="string">&#x27;***&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">x</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> x.isalnum()		<span class="comment">#isalnum()是字符串的方法，用于测试x是否包含字母或者数字</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">filter</span>(func, seq)</span><br><span class="line">&lt;<span class="built_in">filter</span> <span class="built_in">object</span> at <span class="number">0x000001F5CDE06EC0</span>&gt;	<span class="comment">#返回filter对象</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">filter</span>(func, seq))</span><br><span class="line">[<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;x41&#x27;</span>]							<span class="comment">#filter对象转换为列表</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">filter</span>(<span class="built_in">str</span>.isalnum, seq))		<span class="comment">#也可以这样直接使用isalnum</span></span><br><span class="line">[<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;x41&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>seq							<span class="comment">#不改变原有的列表</span></span><br><span class="line">[<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;x41&#x27;</span>, <span class="string">&#x27;?!&#x27;</span>, <span class="string">&#x27;***&#x27;</span>]</span><br></pre></td></tr></table></figure>
<h3 id="range-函数">range()函数</h3>
<p><code>range()</code>是python常用的一个内置函数，有三种用法，下面的step解释为<strong>步数</strong></p>
<ol>
<li><code>range(stop)</code>，默认起始数字为<strong>0</strong>，结束数字为<strong>stop-1</strong>，步数默认为<strong>1</strong></li>
<li><code>range(start, stop)</code>，起始数字<strong>start</strong>，结束数字<strong>stop-1</strong>，步数默认为<strong>1</strong></li>
<li><code>range(start, stop, step)</code>，起始数字<strong>start</strong>，结束数字<strong>stop-1</strong>，步数默认为<strong>step</strong></li>
</ol>
<p>ps：当<code>step &lt; 0</code>时，start应该比stop大</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">range</span>(<span class="number">5</span>)</span><br><span class="line"><span class="built_in">range</span>(<span class="number">0</span>, <span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(_)		<span class="comment">#_代表上一次的正确输出</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>, <span class="number">2</span>))</span><br><span class="line">[<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">9</span>, <span class="number">0</span>, -<span class="number">2</span>))	<span class="comment">#step是负数，start比stop大</span></span><br><span class="line">[<span class="number">9</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(<span class="number">3</span>,end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">...</span><br><span class="line"><span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>
<h3 id="zip-函数">zip()函数</h3>
<p><code>zip()</code>函数用来把多个可迭代对象中对应位置上的元素组合到一起，返回一个zip对象，其中每个元素都是包含原来多个可迭代对象对应位置上元素的<strong>元组</strong>，最终结果zip对象中包含的元素个数取决于所有参数可迭代对象中<strong>最短</strong>的那个</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">zip</span>(<span class="string">&#x27;abcd&#x27;</span>, <span class="string">&#x27;1234&#x27;</span>)			<span class="comment">#返回zip对象，形成元组</span></span><br><span class="line">&lt;<span class="built_in">zip</span> <span class="built_in">object</span> at <span class="number">0x000001F5CDE33F00</span>&gt;		</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">zip</span>(<span class="string">&#x27;abcd&#x27;</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]))	<span class="comment">#取可迭代对象中最短的那个</span></span><br><span class="line">[(<span class="string">&#x27;a&#x27;</span>, <span class="number">1</span>), (<span class="string">&#x27;b&#x27;</span>, <span class="number">2</span>), (<span class="string">&#x27;c&#x27;</span>, <span class="number">3</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">zip</span>(<span class="string">&#x27;abcd&#x27;</span>))</span><br><span class="line">[(<span class="string">&#x27;a&#x27;</span>,), (<span class="string">&#x27;b&#x27;</span>,), (<span class="string">&#x27;c&#x27;</span>,), (<span class="string">&#x27;d&#x27;</span>,)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">zip</span>(<span class="string">&#x27;123&#x27;</span>,  <span class="string">&#x27;abc&#x27;</span>, <span class="string">&#x27;,.!&#x27;</span>))</span><br><span class="line">[(<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;,&#x27;</span>), (<span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;.&#x27;</span>), (<span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;!&#x27;</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> item <span class="keyword">in</span> <span class="built_in">zip</span>(<span class="string">&#x27;abcd&#x27;</span>, <span class="built_in">range</span>(<span class="number">3</span>)):</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(item, end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">...</span><br><span class="line">(<span class="string">&#x27;a&#x27;</span>, <span class="number">0</span>) (<span class="string">&#x27;b&#x27;</span>, <span class="number">1</span>) (<span class="string">&#x27;c&#x27;</span>, <span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = <span class="built_in">zip</span>(<span class="string">&#x27;abcd&#x27;</span>, <span class="string">&#x27;1234&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(x)</span><br><span class="line">[(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;1&#x27;</span>), (<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;2&#x27;</span>), (<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;3&#x27;</span>), (<span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;4&#x27;</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(x)			<span class="comment">#zip对象只能遍历一次，访问过的元素就不复存在了</span></span><br><span class="line">[]</span><br></pre></td></tr></table></figure>
<p>ps：zip、enumerate、filter、map对象，以及生成器对象都有上述特点，遍历一次之后，访问过的元素不复存在，这里的访问指的是访问到元素，而不是访问对象</p>
<h1>python序列结构</h1>
<h2 id="python序列结构概述">python序列结构概述</h2>
<p>python序列属于容器类结构，类似于其他语言中的数组</p>
<p>有序序列：列表，元组，字符串------可以直接使用整数<strong>索引</strong>取访问指定位置，支持切片</p>
<p>无序序列：字典，集合</p>
<p>可变序列：列表，字典，集合-------可以修改元素的<strong>引用</strong>，可以增加或者删除元素</p>
<h2 id="列表">列表</h2>
<p>列表是包含若干元素的<strong>有序连续内存</strong>空间。同一个列表可以同时包含多种数据类型，同时含义整数，实数，字符串，列表，元组，字典，集合，函数以及其他的任意对象。<code>[]</code>表示空列表</p>
<h3 id="列表的创建与删除">列表的创建与删除</h3>
<p>使用 <code>=</code> 直接赋值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a_list = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a_list = []</span><br></pre></td></tr></table></figure>
<p>使用<code>list()</code>函数把元组、range对象、字符串、字典、集合或其它有限长度的<strong>可迭代对象</strong>转换为列表</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>((<span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">9</span>))		<span class="comment">#元组转列表</span></span><br><span class="line">[<span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">9</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>, <span class="number">2</span>))		<span class="comment">#range对象转列表</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="string">&#x27;hello world&#x27;</span>)			<span class="comment">#字符串转列表</span></span><br><span class="line">[<span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;w&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;d&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(&#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>&#125;)				<span class="comment">#集合转列表</span></span><br><span class="line">[<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(&#123;<span class="string">&#x27;a&#x27;</span>:<span class="number">3</span>, <span class="string">&#x27;b&#x27;</span>:<span class="number">4</span>, <span class="string">&#x27;c&#x27;</span>:<span class="number">5</span>&#125;)	<span class="comment">#字典中的“键”转列表</span></span><br><span class="line">[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(&#123;<span class="string">&#x27;a&#x27;</span>:<span class="number">3</span>, <span class="string">&#x27;b&#x27;</span>:<span class="number">4</span>, <span class="string">&#x27;c&#x27;</span>:<span class="number">6</span>&#125;.items())	<span class="comment">#字典中的元素转列表</span></span><br><span class="line">[(<span class="string">&#x27;a&#x27;</span>, <span class="number">3</span>), (<span class="string">&#x27;b&#x27;</span>, <span class="number">4</span>), (<span class="string">&#x27;c&#x27;</span>, <span class="number">6</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = <span class="built_in">list</span>()					<span class="comment">#创建空列表</span></span><br></pre></td></tr></table></figure>
<p>当一个列表不再使用，可以使用del命令删除</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> x			<span class="comment">#删除列表对象</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x				<span class="comment">#删除后无法再访问，报错</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">NameError: name <span class="string">&#x27;x&#x27;</span> <span class="keyword">is</span> <span class="keyword">not</span> defined</span><br></pre></td></tr></table></figure>
<h3 id="列表元素访问">列表元素访问</h3>
<p>列表属于有序序列，可以使用整数作为下标随机访问任意位置上的元素，0下标表示第一个元素（以此类推，和c语言数组类似）</p>
<p>列表还支持<strong>负整数</strong>作为下标，-1表示最后一个元素，-2表示最后第二个元素，以此类推，支持反向索引</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = <span class="built_in">list</span>(<span class="string">&#x27;python&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line">[<span class="string">&#x27;p&#x27;</span>, <span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;t&#x27;</span>, <span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;n&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x[<span class="number">1</span>]</span><br><span class="line"><span class="string">&#x27;y&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x[-<span class="number">3</span>]</span><br><span class="line"><span class="string">&#x27;h&#x27;</span></span><br></pre></td></tr></table></figure>
<h3 id="列表常用方法">列表常用方法</h3>
<p>列表常用方法（method）（这里对method进行解释：python中，属性是对象的状态，方法是对象的行为，属性是对象的变量，方法是对象的函数）</p>
<h4 id="append-、insert-、extend">append()、insert()、extend()</h4>
<p><code>append()</code>方法用于向列表尾部<strong>追加</strong>一个元素（强调<strong>元素整体</strong>），格式<code>list.append(x)</code></p>
<p><code>insert()</code>方法用于向列表<strong>任意指定位置</strong>插入一个元素，<code>list.insert(index, obj)</code>，这里也强调<strong>元素</strong></p>
<p><code>extend()</code>方法用于将另一个<strong>可迭代对象</strong>中的<strong>所有元素</strong>追加至当前列表尾部（强调其中的元素），<code>list.extend(可迭代对象)</code></p>
<p>三个方法都没有返回值，但是会修改原本的列表</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x.append(<span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x.insert(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x.extend([<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x.append(&#123;<span class="number">1</span>, <span class="number">2</span>&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, &#123;<span class="number">1</span>, <span class="number">2</span>&#125;]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x.extend(&#123;<span class="number">1</span>, <span class="number">2</span>&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, &#123;<span class="number">1</span>, <span class="number">2</span>&#125;, <span class="number">1</span>, <span class="number">2</span>]</span><br></pre></td></tr></table></figure>
<h4 id="pop-、remove-、del">pop()、remove() 、del</h4>
<p><code>pop()</code>方法用于<strong>删除并返回</strong>指定位置（默认最后一个）的元素，如果指定位置不是合法索引则抛出异常，格式为<code>list.pop(index)</code>，如果不填写index，那么默认为-1，也就是最后一个元素</p>
<p><code>remove()</code>方法用于删除列表中<strong>第一个值与参数相等的元素</strong>，如果列表中<strong>不存在</strong>该元素则抛出异常，格式为<code>list.remove(obj)</code>，<code>obj</code>是元素，可以任意指定类型（应该）</p>
<p><code>del</code><strong>命令</strong>（不是方法）用于删除列表指定位置的<strong>单个元素</strong>，格式为<code>del listname[index]</code>，如果要删除多个元素可以用切片</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x.pop()</span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x.pop(<span class="number">0</span>)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x.remove(<span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line">[<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> x[<span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line">[<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<h4 id="count-、index">count()、index()</h4>
<p><code>count()</code>方法用于返回列表中指定元素出现的次数，格式为<code>list.count(obj)</code>（如果列表中不存在就返回0）</p>
<p><code>index()</code>方法用于返回指定<strong>元素</strong>在列表中<strong>首次</strong>出现的位置，如果该元素不在列表中就抛出异常，格式为<code>list.index(x[,start[,end]])</code></p>
<ul>
<li>没有start和end参数，范围默认整个列表</li>
<li>只有start参数<code>list.index(x, start)</code>，从start开始到列表尾部（包括start下标）</li>
<li>不能只有end参数，而没有start参数。同时start和end参数格式为<code>list.index(x, start, end)</code></li>
<li>区间搜索范围<code>[start, end)</code>左闭右开</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x.count(<span class="number">3</span>)</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x.index(<span class="number">2</span>)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x.index(<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x.index(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">ValueError: <span class="number">2</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">in</span> <span class="built_in">list</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x.index(<span class="number">4</span>)</span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x.index(<span class="number">4</span>,<span class="number">0</span>,<span class="number">5</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">ValueError: <span class="number">4</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">in</span> <span class="built_in">list</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x.index(<span class="number">4</span>, <span class="number">0</span>, <span class="number">6</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">ValueError: <span class="number">4</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">in</span> <span class="built_in">list</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x.index(<span class="number">4</span>, <span class="number">0</span> ,<span class="number">7</span>)</span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure>
<h3 id="列表对象支持的运算符">列表对象支持的运算符</h3>
<p><code>+</code>可以连接两个列表</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = x + [<span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line">[<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure>
<p><code>*</code>可以用于正整数和列表相乘，表示序列的重复</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = x * <span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure>
<p><code>in</code>进行成员测试，是否包含某个元素</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">3</span> <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">3</span> <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="string">&#x27;3&#x27;</span>]</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p>关系运算符可以用来比较两个列表大小</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>] &gt; [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>]</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>] == [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>]</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>
<h3 id="内置函数对列表的操作（举例集合）">内置函数对列表的操作（举例集合）</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">11</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> random</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>random.shuffle(x)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line">[<span class="number">3</span>, <span class="number">6</span>, <span class="number">10</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">9</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">all</span>(x)</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">any</span>(x)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">max</span>(x)</span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">min</span>(x)</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">max</span>(x, key=<span class="built_in">str</span>)</span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sum</span>(x)</span><br><span class="line"><span class="number">55</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">len</span>(x)</span><br><span class="line"><span class="number">11</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">zip</span>(x, [<span class="number">1</span>]*<span class="number">11</span>))</span><br><span class="line">[(<span class="number">3</span>, <span class="number">1</span>), (<span class="number">6</span>, <span class="number">1</span>), (<span class="number">10</span>, <span class="number">1</span>), (<span class="number">8</span>, <span class="number">1</span>), (<span class="number">4</span>, <span class="number">1</span>), (<span class="number">2</span>, <span class="number">1</span>), (<span class="number">0</span>, <span class="number">1</span>), (<span class="number">5</span>, <span class="number">1</span>), (<span class="number">7</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">1</span>), (<span class="number">9</span>, <span class="number">1</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">zip</span>(<span class="built_in">range</span>(<span class="number">1</span>, <span class="number">4</span>)))</span><br><span class="line">[(<span class="number">1</span>,), (<span class="number">2</span>,), (<span class="number">3</span>,)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">zip</span>([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>], [<span class="number">1</span>, <span class="number">2</span>]))</span><br><span class="line">[(<span class="string">&#x27;a&#x27;</span>, <span class="number">1</span>), (<span class="string">&#x27;b&#x27;</span>, <span class="number">2</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">enumerate</span>(x))</span><br><span class="line">[(<span class="number">0</span>, <span class="number">3</span>), (<span class="number">1</span>, <span class="number">6</span>), (<span class="number">2</span>, <span class="number">10</span>), (<span class="number">3</span>, <span class="number">8</span>), (<span class="number">4</span>, <span class="number">4</span>), (<span class="number">5</span>, <span class="number">2</span>), (<span class="number">6</span>, <span class="number">0</span>), (<span class="number">7</span>, <span class="number">5</span>), (<span class="number">8</span>, <span class="number">7</span>), (<span class="number">9</span>, <span class="number">1</span>), (<span class="number">10</span>, <span class="number">9</span>)]</span><br></pre></td></tr></table></figure>
<h3 id="列表推导式">列表推导式</h3>
<p>列表推导式可以使用非常简洁的方式对列表或其它可迭代对象的元素进行遍历，过滤或者再次计算，快速生成满足特定需求的新列表</p>
<p>列表推导式逻辑上等价于一个循环语句，只是形式上更加简洁</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>aList = [x+x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">30</span>)]</span><br><span class="line">相当于</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>aList = []</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">30</span>):</span><br><span class="line"><span class="meta">... </span>    aList.append(x+x)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>freshFruit = [<span class="string">&#x27; banana&#x27;</span>, <span class="string">&#x27;loganberry &#x27;</span>, <span class="string">&#x27;passion fruit &#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>aList = [w.strip() <span class="keyword">for</span> w <span class="keyword">in</span> freshFruit]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>aList</span><br><span class="line">[<span class="string">&#x27;banana&#x27;</span>, <span class="string">&#x27;loganberry&#x27;</span>, <span class="string">&#x27;passion fruit&#x27;</span>]</span><br><span class="line">相当于</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>aList = []</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> item <span class="keyword">in</span> freshFruit:</span><br><span class="line"><span class="meta">... </span>    aList.append(item.strip())	<span class="comment">#字符串方法strip()用来删除两侧空白符</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>aList</span><br><span class="line">[<span class="string">&#x27;banana&#x27;</span>, <span class="string">&#x27;loganberry&#x27;</span>, <span class="string">&#x27;passion fruit&#x27;</span>]</span><br></pre></td></tr></table></figure>
<p>eg1：使用列表推导式实现嵌套列表的平铺</p>
<p>先遍历列表中嵌套的子列表，然后遍历子列表中的元素进行展开</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>vec = [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[num <span class="keyword">for</span> elem <span class="keyword">in</span> vec <span class="keyword">for</span> num <span class="keyword">in</span> elem]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>result = []</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> elem <span class="keyword">in</span> vec:</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">for</span> num <span class="keyword">in</span> elem:</span><br><span class="line"><span class="meta">... </span>            result.append(num)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>result</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br></pre></td></tr></table></figure>
<p>eg2：在列表推导式中使用<code>if</code>过滤掉不符号要求的元素，例子过于复杂就不写了（写了也无法理解，后面会学吧应该）</p>
<h3 id="切片">切片</h3>
<p>切片也可以适用于元组，字符串，range对象等，但是列表的切片具有非常强大的功能</p>
<p>切片形式<code>[start:end:step]</code>-----貌似和列表的index方法很像，<code>list.index(x[,start[,end]])</code></p>
<p>start表示起始位置，默认为0（step&gt;0时）或者-1（step&lt;0时）</p>
<p>end默认为列表长度（step&gt;0时），区间为<code>[start,end)</code>，左闭右开</p>
<p>start为0时可以省略，end为列表长度时可以省略，step为1时可以省略（省略步长时要省略最后一个冒号）</p>
<p>step为负整数时，表示负切片，此时start需要在end右侧</p>
<p>一：使用切片获取列表中部分元素</p>
<p>使用切片可以返回列表中部分元素组成的新列表，切片超出原列表范围时不会报错，系统会自行截断</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>aList = [<span class="number">3</span>, <span class="number">4</span> ,<span class="number">5</span> ,<span class="number">6</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">15</span>, <span class="number">17</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>aList[::]			<span class="comment">#返回原列表中所有元素组成的新列表</span></span><br><span class="line">[<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">15</span>, <span class="number">17</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>aList[::-<span class="number">1</span>]			<span class="comment">#返回逆向的新列表</span></span><br><span class="line">[<span class="number">17</span>, <span class="number">15</span>, <span class="number">13</span>, <span class="number">11</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>aList[::<span class="number">2</span>]			<span class="comment">#每隔一个取一个元素</span></span><br><span class="line">[<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>aList[<span class="number">3</span>:<span class="number">6</span>]			<span class="comment">#范围下标从3~5</span></span><br><span class="line">[<span class="number">6</span>, <span class="number">7</span>, <span class="number">9</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>aList[<span class="number">0</span>:<span class="number">100</span>]		<span class="comment">#越界自动截断</span></span><br><span class="line">[<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">15</span>, <span class="number">17</span>]</span><br></pre></td></tr></table></figure>
<p>二：使用切片为列表增加元素</p>
<p>使用切片为列表任意位置添加新元素，<strong>不影响列表对象的存储地址，属于原地操作</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>aList = [<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>aList[<span class="built_in">len</span>(aList):]			<span class="comment">#取的范围越界了，返回空列表</span></span><br><span class="line">[]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>aList[<span class="built_in">len</span>(aList):] = [<span class="number">9</span>]	<span class="comment">#在新位置直接赋值</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>aList[:<span class="number">0</span>] = [<span class="number">1</span>, <span class="number">2</span>]			<span class="comment">#直接插入到下标为0的位置</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>aList[<span class="number">3</span>:<span class="number">3</span>] = [<span class="number">4</span>]			<span class="comment">#直接插入到下标为3的位置</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>aList</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>]</span><br></pre></td></tr></table></figure>
<p>相应的还有替换，修改，删除列表中的元素，用法都很相似，都是利用切片返回一个位置，对某个位置进行修改，也可以和<code>del</code>命令结合使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; aList = [3, 5, 7, 9, 11]</span><br><span class="line">&gt;&gt;&gt; del aList[:3]</span><br><span class="line">&gt;&gt;&gt; aList</span><br><span class="line">[9, 11]</span><br><span class="line">&gt;&gt;&gt; aList = [3, 5, 6, 7, 9]</span><br><span class="line">&gt;&gt;&gt; del aList[::2]</span><br><span class="line">&gt;&gt;&gt; aList</span><br><span class="line">[5, 7]</span><br></pre></td></tr></table></figure>
<h2 id="元组和生成器表达式">元组和生成器表达式</h2>
<h3 id="元组创建与元素访问">元组创建与元素访问</h3>
<p>可以把元组看作是轻量级的列表，支持和列表中类似的操作，但是功能更加强大</p>
<p>形式上，所有元素放在一对圆括号内，元素之间使用逗号相隔，只有一个元素时必须在最后位置加上一个逗号</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(x)</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;tuple&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x[<span class="number">0</span>]		<span class="comment">#支持下标的双向访问</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x[-<span class="number">1</span>]</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x[<span class="number">1</span>] = <span class="number">4</span>	<span class="comment">#元组中元素的引用不可变</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: <span class="string">&#x27;tuple&#x27;</span> <span class="built_in">object</span> does <span class="keyword">not</span> support item assignment</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = (<span class="number">3</span>,)	<span class="comment">#一个元素必须有一个逗号</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line">(<span class="number">3</span>,)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = ()		<span class="comment">#空元组</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = <span class="built_in">tuple</span>()	<span class="comment">#空元组</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">tuple</span>(<span class="built_in">range</span>(<span class="number">5</span>))		<span class="comment">#把其它可迭代对象转换为元组</span></span><br><span class="line">(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure>
<h3 id="元组和列表的异同点">元组和列表的异同点</h3>
<p><strong>相同点</strong>：都是有序序列，支持下标的双向索引，可以使用<code>count(),index()</code>方法，可以使用<code>len(),map(),filter()</code>等大量内置函数，以及<code>+,*,in</code>运算符操作</p>
<p><strong>不同点</strong>：元组是不可变序列，不能改变顺序，不能修改元素的引用，<strong>无法增添或者删除元素</strong>，支持切片访问，但是切片不能用来修改访问。</p>
<p>因此元组可以视作“常量列表”，“静态列表”</p>
<p>作为不可变序列，元组和整数，字符串一样，可以<strong>作为字典的键</strong>，或者作为集合的元素</p>
<h3 id="生成器表达式">生成器表达式</h3>
<p>生成器表达式（generator expression）的语法与列表推导式非常相似，形式上使用圆括号作为定界符。</p>
<p>生成器表达式的结果是一个生成器对象，具有<strong>惰性求值</strong>的特点，只在需要时生成新元素（每个元素只生成一次），比列表推导式效率更高，占用空间非常少，适合大数据处理</p>
<p>对于生成器对象，可以转化为列表或者元组，也可以使用生成器对象的<code>__next()__</code>方法或者内置函数<code>next()</code>进行遍历，或者直接使用for循环遍历，但是只能从前往后，没有任何方法访问已经访问过的元素，也不支持下标访问。</p>
<hr>
<p><strong>当所有元素都被访问过后，如果需要再次访问，需要重新创建生成器对象，</strong><code>enumerate、filter、map、zip</code><strong>等其它迭代器对象也具有同样的特点</strong></p>
<hr>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>g = ((i+<span class="number">2</span>)**<span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>))					<span class="comment">#创建生成器对象</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g</span><br><span class="line">&lt;generator <span class="built_in">object</span> &lt;genexpr&gt; at <span class="number">0x000001D98DDE9A10</span>&gt;		<span class="comment">#at后面是地址</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">tuple</span>(g)		<span class="comment">#转换为元组，</span></span><br><span class="line">(<span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>, <span class="number">100</span>, <span class="number">121</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(g)			<span class="comment">#不可二次访问</span></span><br><span class="line">[]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g = ((i+<span class="number">2</span>)**<span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>))					<span class="comment">#重新创建</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(g)</span><br><span class="line">[<span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>, <span class="number">100</span>, <span class="number">121</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g = ((i+<span class="number">2</span>)**<span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>))	</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g.__next__()		<span class="comment">#使用__next__()方法访问</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g.__next__()</span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(g)				<span class="comment">#使用next()函数访问</span></span><br><span class="line"><span class="number">16</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g = ((i+<span class="number">2</span>)**<span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> item <span class="keyword">in</span> g:		<span class="comment">#使用for循环访问</span></span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(item, end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">...</span><br><span class="line"><span class="number">4</span> <span class="number">9</span> <span class="number">16</span> <span class="number">25</span> <span class="number">36</span> <span class="number">49</span> <span class="number">64</span> <span class="number">81</span> <span class="number">100</span> <span class="number">121</span> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g = <span class="built_in">map</span>(<span class="built_in">str</span>, <span class="built_in">range</span>(<span class="number">20</span>))	<span class="comment">#构造map迭代器对象</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;2&#x27;</span> <span class="keyword">in</span> g		<span class="comment">#一次&#x27;in&#x27;判断会把整个对象访问一遍</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;2&#x27;</span> <span class="keyword">in</span> g		<span class="comment">#访问过一次没了</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;8&#x27;</span> <span class="keyword">in</span> g		<span class="comment">#没了</span></span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>
<h2 id="字典">字典</h2>
<p>字典是包含若干个“键:值”元素的无序可变序列，每个元素包含“键”和“值”两个部分，表示一种映射或者是对应关系，也称作关联数组，不同元素以逗号分隔</p>
<p>“键”可以是python中任意<strong>不可变数据</strong>，比如整数，实数，复数，字符串，元组等类型作为散列数据</p>
<p>其它可变类型比如列表，集合，字典等不能作为“键”</p>
<p>“键”不允许重复，但是“值”允许重复，类似于一个hash映射</p>
<h3 id="字典的创建与删除">字典的创建与删除</h3>
<p>使用<code>=</code>直接赋值给一个变量，或者使用内置类<code>dict</code>以不同形式创建字典，可以使用del命令直接删除</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>aDict = &#123;<span class="string">&#x27;server&#x27;</span>: <span class="string">&#x27;db.diver&#x27;</span>, <span class="string">&#x27;database&#x27;</span>: <span class="string">&#x27;mysql&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>aDict</span><br><span class="line">&#123;<span class="string">&#x27;server&#x27;</span>: <span class="string">&#x27;db.diver&#x27;</span>, <span class="string">&#x27;database&#x27;</span>: <span class="string">&#x27;mysql&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = <span class="built_in">dict</span>()		<span class="comment">#空字典</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = &#123;&#125;			<span class="comment">#空字典</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>keys = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = <span class="built_in">dict</span>(<span class="built_in">zip</span>(keys, values))		<span class="comment">#使用zip进行映射</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d</span><br><span class="line">&#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;d&#x27;</span>: <span class="number">4</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = <span class="built_in">dict</span>(name=<span class="string">&#x27;Dong&#x27;</span>, age=<span class="number">39</span>)	<span class="comment">#以关键参数的形式创建字典</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d</span><br><span class="line">&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Dong&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">39</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>aDict = <span class="built_in">dict</span>.fromkeys([<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;age&#x27;</span>, <span class="string">&#x27;sex&#x27;</span>])<span class="comment">#创建”值“为空的字典</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>aDict</span><br><span class="line">&#123;<span class="string">&#x27;name&#x27;</span>: <span class="literal">None</span>, <span class="string">&#x27;age&#x27;</span>: <span class="literal">None</span>, <span class="string">&#x27;sex&#x27;</span>: <span class="literal">None</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> aDict		<span class="comment">#del命令直接删除</span></span><br></pre></td></tr></table></figure>
<h3 id="字典元素的访问">字典元素的访问</h3>
<p>字典使用”键“进行索引，如果字典中不存在某个”键“，会抛出异常</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>aDict = &#123;<span class="string">&#x27;age&#x27;</span>: <span class="number">39</span>, <span class="string">&#x27;score&#x27;</span>: [<span class="number">98</span>,<span class="number">97</span>], <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Dong&#x27;</span>, <span class="string">&#x27;sex&#x27;</span>: <span class="string">&#x27;male&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>aDict[<span class="string">&#x27;age&#x27;</span>]</span><br><span class="line"><span class="number">39</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>aDict[<span class="string">&#x27;address&#x27;</span>]	<span class="comment">#不存在对应”键“，异常</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">KeyError: <span class="string">&#x27;address&#x27;</span></span><br></pre></td></tr></table></figure>
<p>字典特有的<code>get()</code>方法，指定“键”返回特定的“值”，并且允许不存在该“键”时返回特定的“值”，（默认为None）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>aDict.get(<span class="string">&#x27;address&#x27;</span>,<span class="string">&#x27;Not exist&#x27;</span>)	<span class="comment">#指定”键“，如果不存在就返回指定的默认值</span></span><br><span class="line"><span class="string">&#x27;Not exist&#x27;</span></span><br></pre></td></tr></table></figure>
<p>可以对字典对象进行迭代或者遍历，默认遍历字典的“键”，如果需要遍历字典的元素，必须使用字典对象的<code>items()</code>方法明确说明，如果需要遍历字典的“值”，必须使用字典对象的<code>values()</code>方法进行说明。当使用<code>len(),max(),min(),sum(),sorted()</code>等内置函数时，也遵循同样的规定</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>aDict = &#123;<span class="string">&#x27;age&#x27;</span>: <span class="number">39</span>, <span class="string">&#x27;score&#x27;</span>: [<span class="number">98</span>,<span class="number">97</span>], <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Dong&#x27;</span>, <span class="string">&#x27;sex&#x27;</span>: <span class="string">&#x27;male&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> item <span class="keyword">in</span> aDict:</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(item, end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">...</span><br><span class="line">age score name sex </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> item <span class="keyword">in</span> aDict.items():</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(item,end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">...</span><br><span class="line">(<span class="string">&#x27;age&#x27;</span>, <span class="number">39</span>) (<span class="string">&#x27;score&#x27;</span>, [<span class="number">98</span>, <span class="number">97</span>]) (<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;Dong&#x27;</span>) (<span class="string">&#x27;sex&#x27;</span>, <span class="string">&#x27;male&#x27;</span>) </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> item <span class="keyword">in</span> aDict.values():</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(item,end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">...</span><br><span class="line"><span class="number">39</span> [<span class="number">98</span>, <span class="number">97</span>] Dong male </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>aDict</span><br><span class="line">&#123;<span class="string">&#x27;age&#x27;</span>: <span class="number">39</span>, <span class="string">&#x27;score&#x27;</span>: [<span class="number">98</span>, <span class="number">97</span>], <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Dong&#x27;</span>, <span class="string">&#x27;sex&#x27;</span>: <span class="string">&#x27;male&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>aDict.items()</span><br><span class="line">dict_items([(<span class="string">&#x27;age&#x27;</span>, <span class="number">39</span>), (<span class="string">&#x27;score&#x27;</span>, [<span class="number">98</span>, <span class="number">97</span>]), (<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;Dong&#x27;</span>), (<span class="string">&#x27;sex&#x27;</span>, <span class="string">&#x27;male&#x27;</span>)])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>aDict.values()</span><br><span class="line">dict_values([<span class="number">39</span>, [<span class="number">98</span>, <span class="number">97</span>], <span class="string">&#x27;Dong&#x27;</span>, <span class="string">&#x27;male&#x27;</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>aDict.keys()</span><br><span class="line">dict_keys([<span class="string">&#x27;age&#x27;</span>, <span class="string">&#x27;score&#x27;</span>, <span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;sex&#x27;</span>])</span><br></pre></td></tr></table></figure>
<h3 id="字典元素的添加、修改与删除">字典元素的添加、修改与删除</h3>
<p>如果使用指定的“键”为字典元素赋值时，有两种含义</p>
<ul>
<li>如果该“键”存在，则表示修改该“键”对应的“值”</li>
<li>如果该“键”不存在，则表示重新添加一个新的“键:值”</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>aDict = &#123;<span class="string">&#x27;age&#x27;</span>: <span class="number">39</span>, <span class="string">&#x27;score&#x27;</span>: [<span class="number">98</span>,<span class="number">97</span>], <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Dong&#x27;</span>, <span class="string">&#x27;sex&#x27;</span>: <span class="string">&#x27;male&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>aDict[<span class="string">&#x27;age&#x27;</span>]=<span class="number">28</span>		<span class="comment">#原本存在则修改</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>aDict</span><br><span class="line">&#123;<span class="string">&#x27;age&#x27;</span>: <span class="number">28</span>, <span class="string">&#x27;score&#x27;</span>: [<span class="number">98</span>, <span class="number">97</span>], <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Dong&#x27;</span>, <span class="string">&#x27;sex&#x27;</span>: <span class="string">&#x27;male&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>aDict[<span class="string">&#x27;address&#x27;</span>] = <span class="string">&#x27;beijing&#x27;</span>	<span class="comment">#原本不存在则添加</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>aDict</span><br><span class="line">&#123;<span class="string">&#x27;age&#x27;</span>: <span class="number">28</span>, <span class="string">&#x27;score&#x27;</span>: [<span class="number">98</span>, <span class="number">97</span>], <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Dong&#x27;</span>, <span class="string">&#x27;sex&#x27;</span>: <span class="string">&#x27;male&#x27;</span>, <span class="string">&#x27;address&#x27;</span>: <span class="string">&#x27;beijing&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>
<p>使用字典对象的<code>updata()</code>方法可以将另一个字典的全部”键：值“全部更新到原字典中，更新规则和上方两个一样</p>
<p>使用<code>pop()</code>和<code>popitem()</code>方法弹出并删除指定元素</p>
<p><code>pop(key[,default])</code>，弹出对应键‘key’的值，可以设置default参数作为不存在key时的返回值</p>
<p><code>popitem()</code>无参数，返回最后插入的键值，返回形式为一个元组</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>aDict = &#123;<span class="string">&#x27;age&#x27;</span>: <span class="number">37</span>, <span class="string">&#x27;score&#x27;</span>: [<span class="number">98</span>, <span class="number">97</span>], <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Dong&#x27;</span>, <span class="string">&#x27;sex&#x27;</span>: <span class="string">&#x27;male&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>aDict.update(&#123;<span class="string">&#x27;age&#x27;</span>: <span class="number">39</span>, <span class="string">&#x27;a&#x27;</span>: <span class="number">80</span>&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>aDict</span><br><span class="line">&#123;<span class="string">&#x27;age&#x27;</span>: <span class="number">39</span>, <span class="string">&#x27;score&#x27;</span>: [<span class="number">98</span>, <span class="number">97</span>], <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Dong&#x27;</span>, <span class="string">&#x27;sex&#x27;</span>: <span class="string">&#x27;male&#x27;</span>, <span class="string">&#x27;a&#x27;</span>: <span class="number">80</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>aDict.popitem()</span><br><span class="line">(<span class="string">&#x27;a&#x27;</span>, <span class="number">80</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>aDict.pop(<span class="string">&#x27;age&#x27;</span>)</span><br><span class="line"><span class="number">39</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>aDict</span><br><span class="line">&#123;<span class="string">&#x27;score&#x27;</span>: [<span class="number">98</span>, <span class="number">97</span>], <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Dong&#x27;</span>, <span class="string">&#x27;sex&#x27;</span>: <span class="string">&#x27;male&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>
<h2 id="集合">集合</h2>
<p>集合中元素不可变，比如整数，实数，复数，字符串，元组等，元素不可重复</p>
<h3 id="集合的创建和删除">集合的创建和删除</h3>
<p>直接赋值或者使用<code>set()</code>函数将可迭代对象转换为集合，同样可以使用del命令删除集合</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = &#123;<span class="number">3</span>, <span class="number">5</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a_set = <span class="built_in">set</span>(<span class="built_in">range</span>(<span class="number">4</span>,<span class="number">14</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a_set</span><br><span class="line">&#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b_set = ([<span class="number">0</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b_set</span><br><span class="line">[<span class="number">0</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure>
<h3 id="集合操作与运算">集合操作与运算</h3>
<h4 id="集合元素的增加与删除">集合元素的增加与删除</h4>
<p><code>add(elem)</code>方法增添新元素，如果元素已经存在就会异常</p>
<p><code>update(another_set)</code>方法更新集合，类似字典的更新，自动去重，添加原本没有的元素</p>
<p><code>pop()</code>方法删除集合中<strong>任意元素</strong>，如果集合为空就异常，返回的元素作为返回值</p>
<p><code>remove(elem)</code>方法删除<strong>指定元素</strong>，不存在就抛出异常</p>
<p><code>discard(elem)</code>方法删除<strong>指定元素</strong>，不存在则忽略</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>trie树</title>
    <url>/2023/05/04/trie%E6%A0%91/</url>
    <content><![CDATA[<h1>引入</h1>
<p>在大规模的文本中，查询一个单词，通常我们选择从前往后依次查询所有单词，但是在大规模文本中，这样的查询效率过于低下。</p>
<p>我们思考一个问题，我们通常在英文词典中查询单词的时候，是怎么做的呢？</p>
<p>比如单词<code>invalid</code>，首先你会去查找字母<code>i</code>开头的那部分，紧接着查找<code>n</code>，以此类推，最终快速找到这个单词，而不是把字典从前往后翻一遍，依次查看所有单词</p>
<p>因此我们引入树形结构<code>trie树</code></p>
<h1>性质</h1>
<p>trie树主要利用公共前缀来节约空间，同时提升查找和插入效率</p>
<p>trie结构主要基于两个原则：</p>
<ul>
<li>根节点不包含字符，除根节点外每一个节点都只包含一个字符。</li>
<li>从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串。</li>
<li>每个节点的所有子节点包含的字符都不相同。</li>
</ul>
<h1>构造与代码</h1>
<p>我们需要构建出一颗类似于我们查词典一样的树，比如查询字符串<code>abcd</code>，我们首先只需要考虑字母<code>a</code>，而对于以<code>b, c, d</code>开头的就不需要考虑了。</p>
<p>对于单词<code>abcd</code>、<code>ackf</code>、<code>ahbd</code>、<code>abce</code>、<code>acdk</code>、<code>ab</code>、<code>abcm</code>、<code>ah</code>，我们可以构建如下一棵树：</p>
<p><img src="https://soybeanlittlecar.oss-cn-beijing.aliyuncs.com/blog/trie/00001.png" alt=""></p>
<p>其中用黄圈标记的表示存在以此结点为结尾的单词，对于每一个单词，我们只需要查询到其最后一个字母，看最后一个字母对应的结点是否被标记（黄圈），标记了代表该树中以及存在这个单词。</p>
<p>这里我们只考虑统计字母（不区分大小写），那么trie树每一层是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>h</mi><mn>26</mn></msup></mrow><annotation encoding="application/x-tex">h^{26}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">26</span></span></span></span></span></span></span></span></span></span></span></span>量级，因此我们可以使用链表或者数组模拟来存储trie树，空间的花费不会超过单词书*单词的长度</p>
<p>代码实现如下（使用数组模拟）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1000050</span>;<span class="comment">//总边数量&gt;=单词数*单词长度</span></span><br><span class="line"><span class="type">int</span> trie[N][<span class="number">26</span>];</span><br><span class="line"><span class="type">int</span> cnt[N];</span><br><span class="line"><span class="type">int</span> id;<span class="comment">//结点的编号，按照先后顺序记录</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">char</span> s[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; s[i] != <span class="string">&#x27;\0&#x27;</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> x = s[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (trie[p][x] == <span class="number">0</span>) trie[p][x] = ++id;</span><br><span class="line">        p = trie[p][x];</span><br><span class="line">    &#125;</span><br><span class="line">    cnt[p]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">char</span> s[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; s[i] != <span class="string">&#x27;\0&#x27;</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> x = s[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (trie[p][x] == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        p = trie[p][x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt[p];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面来解释这段代码，</p>
<p><code>id</code>表示一条边的对应关系，比如<code>trie[i][3]=5;</code>第<strong>i</strong>号结点连接了字符<code>d</code>，因为<code>3 = 'd'-'a'</code>；并且这个<strong>d</strong>字符结点的标号是5;</p>
<p>每次通过标号索引到最终结束的结点，假设最终结点标号是<strong>p</strong>，<code>cnt[p]++</code>，<strong>cnt</strong>存取所有结点作为结束结点的个数，<code>cnt[p]&gt;0</code>就代表标号<strong>p</strong>的结点是结束结点</p>
<p>我们再次以上述的trie树构造图来说明，插入的顺序为<code>abcd</code>、<code>ackf</code>、<code>ahbd</code>、<code>abce</code>、<code>acdk</code>、<code>ab</code>、<code>abcm</code>、<code>ah</code></p>
<p>起初，树空，我们插入<code>abcd</code>，</p>
<p><code>trie[0]['a'-'a']=1;--trie[1]['b'-'a']=2;--trie[2]['c'-'a']=3;--trie[3]['d'-'a']=4;</code></p>
<p><img src="https://soybeanlittlecar.oss-cn-beijing.aliyuncs.com/blog/trie/00002.png" alt=""></p>
<p>接着插入<code>ackf</code>，得到</p>
<p><img src="https://soybeanlittlecar.oss-cn-beijing.aliyuncs.com/blog/trie/00003.png" alt=""></p>
<p>接着插入<code>ahbd</code>，得到</p>
<p><img src="https://soybeanlittlecar.oss-cn-beijing.aliyuncs.com/blog/trie/00004.png" alt=""></p>
<p>接着插入<code>abce</code>，得到</p>
<p><img src="https://soybeanlittlecar.oss-cn-beijing.aliyuncs.com/blog/trie/00005.png" alt=""></p>
<p>接着插入<code>acdk</code>，得到</p>
<p><img src="https://soybeanlittlecar.oss-cn-beijing.aliyuncs.com/blog/trie/00006.png" alt=""></p>
<p>接着插入<code>ab</code>，得到</p>
<p><img src="https://soybeanlittlecar.oss-cn-beijing.aliyuncs.com/blog/trie/00007.png" alt=""></p>
<p>接着插入<code>abcm</code>，得到</p>
<p><img src="https://soybeanlittlecar.oss-cn-beijing.aliyuncs.com/blog/trie/00008.png" alt=""></p>
<p>接着插入<code>ah</code>，得到</p>
<p><img src="https://soybeanlittlecar.oss-cn-beijing.aliyuncs.com/blog/trie/00009.png" alt=""></p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>trie树</tag>
      </tags>
  </entry>
  <entry>
    <title>c语言模板</title>
    <url>/2023/03/20/c%E8%AF%AD%E8%A8%80%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<ul>
<li>
<p>本文主要是一些常用的c语言代码模板，包含部分简单算法，提供的代码解释也仅限于代码注释，请读者自行理解使用</p>
<span id="more"></span>
<h1>数据结果模板</h1>
<h2 id="链表">链表</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">element</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line"></span><br><span class="line">&#125; ElemType; <span class="comment">//创建元素类型；</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">link</span>;</span><span class="comment">//自引用指针；</span></span><br><span class="line"></span><br><span class="line">&#125; Node, *Nodeprt; <span class="comment">//创建链表和自引用指针类型；</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Nodeprt <span class="title function_">createList</span><span class="params">(<span class="type">int</span> n)</span>;<span class="comment">//创建n个结点的链表；</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getLength</span><span class="params">(Nodeprt <span class="built_in">list</span>)</span>;<span class="comment">//获得链表长度；</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">destroyList</span><span class="params">(Nodeprt <span class="built_in">list</span>)</span>;<span class="comment">//销毁一个表；</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printList</span><span class="params">(Nodeprt <span class="built_in">list</span>)</span>;<span class="comment">//输出一个表；</span></span><br><span class="line">Nodeprt <span class="title function_">insertFirst</span><span class="params">(Nodeprt <span class="built_in">list</span>, ElemType elem)</span>;<span class="comment">//链表开头插入一个元素；</span></span><br><span class="line">Nodeprt <span class="title function_">insertList_rank</span><span class="params">(Nodeprt <span class="built_in">list</span>, ElemType elem)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//有序链表插入相应结点；</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">insertNode1</span><span class="params">(Nodeprt <span class="built_in">list</span>, <span class="type">int</span> n, ElemType elem)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第n个结点之后插入一个结点</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">insertList</span><span class="params">(Nodeprt <span class="built_in">list</span>, Nodeprt p, ElemType elem)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//链表某一结点后面插入带某个元素的结点；</span></span><br><span class="line">Nodeprt <span class="title function_">searchNode</span><span class="params">(Nodeprt <span class="built_in">list</span>, ElemType elem)</span>; <span class="comment">//链表里查找某个元素，返回地址；</span></span><br><span class="line">Nodeprt <span class="title function_">deleteNode</span><span class="params">(Nodeprt <span class="built_in">list</span>, Nodeprt p)</span>; <span class="comment">//链表里面删除某一元素和结点p；</span></span><br><span class="line">ElemType <span class="title function_">read</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">buildlist</span><span class="params">(<span class="type">int</span> n)</span>;<span class="comment">//构建循环链表； </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//p=p-&gt;link;指向下一个结点；</span></span><br><span class="line">    <span class="comment">/*q-&gt;link=p-&gt;link;</span></span><br><span class="line"><span class="comment">    p-&gt;link=q;</span></span><br><span class="line"><span class="comment">    在p后面插入结点q*/</span></span><br><span class="line">    <span class="comment">/*q=p-&gt;link;</span></span><br><span class="line"><span class="comment">    p-&gt;link=q-&gt;link;</span></span><br><span class="line"><span class="comment">    free(q);</span></span><br><span class="line"><span class="comment">    删除p的下一个结点*/</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Nodeprt <span class="title function_">createList</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    Nodeprt p, q, <span class="built_in">list</span> = <span class="literal">NULL</span>;</span><br><span class="line">    p = (Nodeprt) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node)); <span class="comment">//Node结构大小的指针</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        q = (Nodeprt) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">        q-&gt;data = read(); <span class="comment">//读取一个元素；read自己写</span></span><br><span class="line">        <span class="comment">//根据题目的输入方法自己写合适的输入函数；</span></span><br><span class="line">        q-&gt;link = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">list</span> == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">list</span> = p = q;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            p-&gt;link = q;</span><br><span class="line">        &#125;</span><br><span class="line">        p = q; <span class="comment">//时间复杂度为n</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">getLength</span><span class="params">(Nodeprt <span class="built_in">list</span>)</span> &#123;</span><br><span class="line">    Nodeprt p;<span class="comment">//p为遍历所有结点的指针；</span></span><br><span class="line">    <span class="type">int</span> n = <span class="number">0</span>; <span class="comment">//长度初值；</span></span><br><span class="line">    <span class="keyword">for</span> (p = <span class="built_in">list</span>; p != <span class="literal">NULL</span>; p-&gt;link = p) &#123;</span><br><span class="line">        n++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Nodeprt <span class="title function_">insertFirst</span><span class="params">(Nodeprt <span class="built_in">list</span>, ElemType elem)</span> &#123;</span><br><span class="line">    Nodeprt p = (Nodeprt) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    p-&gt;data = elem; <span class="comment">//读入新的数据结点到开头；</span></span><br><span class="line">    p-&gt;link = <span class="built_in">list</span>;</span><br><span class="line">    <span class="keyword">return</span> p;<span class="comment">//p是新的起点；</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">insertNode</span><span class="params">(Nodeprt <span class="built_in">list</span>, Nodeprt p, ElemType elem)</span> &#123;<span class="comment">//p之后插入 </span></span><br><span class="line">    Nodeprt q = (Nodeprt) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    q-&gt;data = elem;</span><br><span class="line">    q-&gt;link = p-&gt;link;</span><br><span class="line">    p-&gt;link = q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">insertNode1</span><span class="params">(Nodeprt <span class="built_in">list</span>, <span class="type">int</span> n, ElemType elem)</span> &#123;</span><br><span class="line">    <span class="comment">//在第n个结点之后插入</span></span><br><span class="line">    Nodeprt p = <span class="built_in">list</span>, q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;link == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        p = p-&gt;link; <span class="comment">//n-1次后，p表示指向n的指针;</span></span><br><span class="line">        <span class="comment">//list算作第一个结点;</span></span><br><span class="line">    &#125;</span><br><span class="line">    q = (Nodeprt) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    q-&gt;data = elem;</span><br><span class="line">    q-&gt;link = p-&gt;link; <span class="comment">//新元素指向</span></span><br><span class="line">    p-&gt;link = q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Nodeprt <span class="title function_">insertList_rank</span><span class="params">(Nodeprt <span class="built_in">list</span>, ElemType elem)</span> &#123;</span><br><span class="line">    Nodeprt p, q, r;</span><br><span class="line">    r = (Nodeprt) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    r-&gt;data = elem;</span><br><span class="line">    r-&gt;link = <span class="literal">NULL</span>; <span class="comment">//创建新数据点</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">list</span> == <span class="literal">NULL</span>) &#123; <span class="comment">//空表</span></span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (p = <span class="built_in">list</span>; p != <span class="literal">NULL</span> &amp;&amp; elem &gt; p-&gt;data; q = p, p = p-&gt;link); <span class="comment">//找到插入点</span></span><br><span class="line">    <span class="comment">// 应该data是升序排列 q就是插入点指针</span></span><br><span class="line">    <span class="comment">//这里的比较大小，如果是单个元素可以直接比较，</span></span><br><span class="line">    <span class="comment">//如果是结构体,比较元素或者//需要另外写比较函数； </span></span><br><span class="line">    <span class="comment">//插入点在q后，p前 </span></span><br><span class="line">    <span class="keyword">if</span> (p == <span class="built_in">list</span>) &#123; <span class="comment">//没有q，在头指针前插入 </span></span><br><span class="line">        r-&gt;link = p;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        q-&gt;link = r;</span><br><span class="line">        r-&gt;link = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Nodeprt <span class="title function_">deleteNode</span><span class="params">(Nodeprt <span class="built_in">list</span>, Nodeprt p)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="built_in">list</span>) &#123;<span class="comment">//删除首结点 </span></span><br><span class="line">        <span class="built_in">list</span> = p-&gt;link;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Nodeprt q = (Nodeprt) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">        q = p-&gt;link;</span><br><span class="line">        p-&gt;link = q-&gt;link;</span><br><span class="line">        <span class="built_in">free</span>(q);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">buildlist</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line"></span><br><span class="line">    Nodeprt p, <span class="built_in">list</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        Nodeprt r = (Nodeprt) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">        r-&gt;data = read();</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">list</span> == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">list</span> = p = r;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            p-&gt;link = r;</span><br><span class="line">            p = p-&gt;link;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;link = <span class="built_in">list</span>;<span class="comment">//循环链表，把结尾和开头接上 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="栈">栈</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 1000</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">elem</span> &#123;</span></span><br><span class="line"></span><br><span class="line">&#125; ElemType;</span><br><span class="line">ElemType STACK[MAXSIZE];</span><br><span class="line"><span class="type">int</span> top = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化堆栈 </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">initStack</span><span class="params">()</span> &#123;</span><br><span class="line">    top = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试堆栈是否为空</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> top == <span class="number">-1</span>;<span class="comment">//栈空返回1，否则返回0 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试栈是否已满</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isFull</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> top == MAXSIZE - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//进栈</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Error</span><span class="params">(<span class="type">char</span> s[])</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, s);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">push</span><span class="params">(ElemType s[], ElemType item)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isFull()) &#123;</span><br><span class="line">        Error(<span class="string">&quot;Full Stack!&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        s[++top] = item;<span class="comment">//先++再赋值 </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出栈</span></span><br><span class="line">ElemType <span class="title function_">pop</span><span class="params">(ElemType s[])</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">        Error(<span class="string">&quot;Empty Stack!&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> s[top--];<span class="comment">//弹出s[top],再-- </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h2 id="队列">队列</h2>
<h3 id="一般队列">一般队列</h3>
<h3 id="优先队列-基于堆实现">优先队列(基于堆实现)</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MinData -1001</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElementType;<span class="comment">//自定义数据类型； </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">HeapStruct</span> &#123;</span></span><br><span class="line">    ElementType *Elements;<span class="comment">//存储堆元素的数组，指针数组</span></span><br><span class="line">    <span class="type">int</span> size;    <span class="comment">//堆的当前元素个数； </span></span><br><span class="line">    <span class="type">int</span> capacity;<span class="comment">//堆的最大容量 </span></span><br><span class="line">&#125; MinHeap, *MinHeapPrt;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">IsFull</span><span class="params">(MinHeapPrt H)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (H-&gt;size == Maxsize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">IsEmpty</span><span class="params">(MinHeapPrt H)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (H-&gt;size == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MinHeapPrt <span class="title function_">Create</span><span class="params">(<span class="type">int</span> Maxsize)</span> &#123;</span><br><span class="line">    <span class="comment">//创建容量为Maxsize的空的最小堆</span></span><br><span class="line">    <span class="comment">//从1开始插入元素，0留给哨兵； </span></span><br><span class="line">    MinHeapPrt H = (MinHeapPrt) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(MinHeap));</span><br><span class="line">    H-&gt;Elements = (ElementType *) <span class="built_in">malloc</span>((Maxsize + <span class="number">1</span>) * <span class="keyword">sizeof</span>(ElementType));</span><br><span class="line">    H-&gt;size = <span class="number">0</span>;</span><br><span class="line">    H-&gt;capacity = Maxsize;</span><br><span class="line">    H-&gt;Elements[<span class="number">0</span>] = MinData;<span class="comment">//随便找一个特别小，比所有输入数据小的元素就行； </span></span><br><span class="line">    <span class="comment">//MinData.定义哨兵为小于堆中所有可能元素的值，便于以后更快操作</span></span><br><span class="line">    <span class="keyword">return</span> H;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">insert</span><span class="params">(MinHeapPrt H, ElementType item)</span> &#123;</span><br><span class="line">    <span class="comment">//将元素item插入最小堆H，其中H-&gt;Elements[0]已经定义为哨兵；</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">if</span> (IsFull(H)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;最小堆已满&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    i = ++H-&gt;size;<span class="comment">//i指向插入后的最后一个元素位置； </span></span><br><span class="line">    <span class="keyword">for</span> (; H-&gt;Elements[i / <span class="number">2</span>] &gt; item; i /= <span class="number">2</span>)<span class="comment">//完全二叉树有i/2表示父结点的性质；如果父结点比目标item大，</span></span><br><span class="line">        <span class="comment">//这里会有i=1的情况，但是有哨兵存在，哨兵保证了所有输入数据都比哨兵大，如果没有哨兵，可以加一句i&gt;1; </span></span><br><span class="line">        <span class="comment">//哨兵效率更高； </span></span><br><span class="line">        H-&gt;Elements[i] = H-&gt;Elements[i / <span class="number">2</span>];<span class="comment">//保证有序性，把大小不符合的往下过滤， </span></span><br><span class="line">    H-&gt;Elements[i] = item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ElementType <span class="title function_">deleteMin</span><span class="params">(MinHeapPrt H)</span> &#123;</span><br><span class="line">    <span class="comment">//从最小堆中去除键值最小的元素，删除结点</span></span><br><span class="line">    <span class="type">int</span> parent, child;</span><br><span class="line">    ElementType MinItem, temp;</span><br><span class="line">    <span class="keyword">if</span> (IsEmpty(H)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;最小堆已空&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    MinItem = H-&gt;Elements[<span class="number">1</span>];<span class="comment">//从根结点找最小值；</span></span><br><span class="line">    <span class="comment">//用最小堆中最后一个元素从根结点开始向上过滤下层结点，就是先把最后一个元素放到根的位置</span></span><br><span class="line">    temp = H-&gt;Elements[H-&gt;size--];<span class="comment">//先赋值，再减减 </span></span><br><span class="line">    <span class="keyword">for</span> (parent = <span class="number">1</span>; parent * <span class="number">2</span> &lt;= H-&gt;size; parent = child) &#123;<span class="comment">//判断保证存在左子； </span></span><br><span class="line">        child = parent * <span class="number">2</span>;<span class="comment">//左子</span></span><br><span class="line">        <span class="keyword">if</span> ((child != H-&gt;size) &amp;&amp; (H-&gt;Elements[child] &gt; H-&gt;Elements[child + <span class="number">1</span>])) <span class="comment">//判断保证有左子的同时还有右子； </span></span><br><span class="line">            child++;<span class="comment">//左子比右子大 </span></span><br><span class="line">        <span class="keyword">if</span> (temp &lt;= H-&gt;Elements[child])<span class="keyword">break</span>;<span class="comment">//调整值比左右子都小；那就放在父的位置 </span></span><br><span class="line">        <span class="keyword">else</span><span class="comment">//移动temp元素到下一层 </span></span><br><span class="line">            H-&gt;Elements[parent] = H-&gt;Elements[child];<span class="comment">//向上过滤，往上移 </span></span><br><span class="line">    &#125;</span><br><span class="line">    H-&gt;Elements[parent] = temp;</span><br><span class="line">    <span class="keyword">return</span> MinItem;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">adjust_MinHeap</span><span class="params">(MinHeapPrt H, <span class="type">int</span> p)</span> &#123;</span><br><span class="line">    <span class="comment">//保证数据已经形成了一颗完全二叉树，根是H，需要调整第p个结点为根的最小堆；</span></span><br><span class="line">    <span class="type">int</span> parent, child;</span><br><span class="line">    ElementType temp;</span><br><span class="line">    temp = H-&gt;Elements[p];<span class="comment">//以p为根的最小堆；,前提是p的左右子树都是最小堆；一般模型，某个根的左右子树都是最大堆或者最小堆，通过调整根让其整体成为最大/最小堆； </span></span><br><span class="line">    <span class="keyword">for</span> (parent = p; parent * <span class="number">2</span> &lt;= H-&gt;size; parent = child) &#123;</span><br><span class="line">        child = parent * <span class="number">2</span>;<span class="comment">//左</span></span><br><span class="line">        <span class="keyword">if</span> ((child != H-&gt;size) &amp;&amp; (H-&gt;Elements[child] &gt; H-&gt;Elements[child + <span class="number">1</span>])) &#123;</span><br><span class="line">            child++;<span class="comment">//左比右大 </span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (temp &lt;= H-&gt;Elements[child])<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            H-&gt;Elements[parent] = H-&gt;Elements[child];<span class="comment">//向下过滤，向上移动； </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    H-&gt;Elements[parent] = temp;<span class="comment">//调整了堆 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Build_MinHeap</span><span class="params">(MinHeapPrt H)</span> &#123; <span class="comment">/* 调整H-&gt;Data[]中的元素，使满足最小堆的有序性  */</span></span><br><span class="line">    <span class="comment">/* 这里假设所有H-&gt;Size个元素已经存在H-&gt;Elements[]中 */</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="comment">/* 从最后一个结点的父节点开始，到根结点1 */</span></span><br><span class="line">    <span class="comment">//所有叶结点已经是最大堆或者最小堆；从最后一个满足（根不符合，但是根的左右子树都满足最大堆，最小堆的结构开始调整） </span></span><br><span class="line">    <span class="keyword">for</span> (i = H-&gt;size / <span class="number">2</span>; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">        adjust_MinHeap(H, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="单调队列-以递减为例">单调队列(以递减为例)</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Maxsize 10000</span></span><br><span class="line"><span class="type">int</span> queue_num[Maxsize], queue_site[Maxsize];</span><br><span class="line"><span class="comment">//num存储队列数值，site存取对应数值在原先的数组里面的位置；</span></span><br><span class="line"><span class="type">int</span> head = <span class="number">0</span>, rear = <span class="number">0</span>;<span class="comment">//rear-1表示当前队尾的位置，head表示当前对头的位置 </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> n, x, k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">        <span class="keyword">if</span> (head != rear) &#123;<span class="comment">//队列非空</span></span><br><span class="line">            <span class="comment">//单调队列的单调情况有：增，减，自定义</span></span><br><span class="line">            <span class="comment">//下面以递减为例子</span></span><br><span class="line">            <span class="keyword">while</span> (head != rear &amp;&amp; queue_site[head] &lt;= i - k)head++;<span class="comment">//如果队首元素不在扫描区间内部，从队首弹出</span></span><br><span class="line">            <span class="keyword">while</span> (head != rear &amp;&amp; queue_num[rear - <span class="number">1</span>] &lt;= x)rear--;<span class="comment">//队尾元素比新元素小或者等于，从队尾弹出</span></span><br><span class="line">            queue_num[rear] = x;</span><br><span class="line">            queue_site[rear++] = i;<span class="comment">//新元素入队 </span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//队列空了，</span></span><br><span class="line">            queue_num[rear] = x;</span><br><span class="line">            queue_site[rear++] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="树">树</h2>
<h3 id="哈夫曼树-基于最小堆实现最小加权">哈夫曼树(基于最小堆实现最小加权)</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">HuffmanTree</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> weight;</span><br><span class="line">    HuffmanTree left, right;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//需要最小堆实现； </span></span><br><span class="line">HuffmanTree <span class="title function_">Huffman</span><span class="params">(MinHeapPrt H)</span> &#123;</span><br><span class="line">    <span class="comment">//假设H-&gt;size个权值已经存在H-&gt;Elements[]-&gt;weight里面了</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    HuffmanTree T;</span><br><span class="line">    BuildMinHeap(H);<span class="comment">//将H-&gt;Elements[]按照权值调整为最小堆</span></span><br><span class="line">    <span class="type">int</span> k = H-&gt;size;<span class="comment">//在下面合并过程中size会被改变，需要维持不变 </span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; k; i++) &#123;<span class="comment">//做H-&gt;size-1次合并</span></span><br><span class="line">        T = (HuffmanTree) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> TreeNode));</span><br><span class="line">        T-&gt;left = deleteMin(H);<span class="comment">//从最小堆里面删除一个结点作为新T的左子</span></span><br><span class="line">        T-&gt;right = deleteMin(H);<span class="comment">//从最小堆里面删除一个结点作为新T的右子；</span></span><br><span class="line">        T-&gt;weight = T-&gt;left-&gt;weight + T-&gt;right-&gt;weight;</span><br><span class="line">        <span class="comment">//计算新权值；</span></span><br><span class="line">        insert(H, T);<span class="comment">//将新T插入最小堆； </span></span><br><span class="line">    &#125;</span><br><span class="line">    T = deleteMin(H);</span><br><span class="line">    <span class="keyword">return</span> T;<span class="comment">///时间复杂度为nlogn；</span></span><br><span class="line">    <span class="comment">//构造一颗哈夫曼树； </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="图">图</h2>
<h3 id="最小生成树">最小生成树</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXVER  512</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INFINITY   32767<span class="comment">//定义无穷大 </span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Prim</span><span class="params">(<span class="type">int</span> weights[][MAXVER], <span class="type">int</span> n, <span class="type">int</span> src, <span class="type">int</span> edges[])</span> &#123; <span class="comment">//weights为权重数组、n为顶点个数、src为最小树的第一个顶点、edge为最小生成树边</span></span><br><span class="line">    <span class="comment">//定义edge[i]为顶点i的前序顶点，就是edge[i]顶点之后就是i顶点 </span></span><br><span class="line">    <span class="type">int</span> minweight[MAXVER], min;</span><br><span class="line">    <span class="type">int</span> i, j, k;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;  <span class="comment">//初始化相关数组</span></span><br><span class="line">        minweight[i] = weights[src][i];  <span class="comment">//将src顶点与之有边的权值存入数组</span></span><br><span class="line">        <span class="comment">//采用邻接矩阵，不存在的边采用无穷大存取； </span></span><br><span class="line">        edges[i] = src;  <span class="comment">//初始时所有顶点的前序顶点设为src，(src,i）//edge数组其实就是在保存最小生成树的结构； </span></span><br><span class="line">    &#125;</span><br><span class="line">    minweight[src] = <span class="number">0</span>;   <span class="comment">//将第一个顶点src顶点加入生成树</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        min = INFINITY;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>, k = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            <span class="keyword">if</span> (minweight[j] != <span class="number">0</span> &amp;&amp; minweight[j] &lt; min) &#123;  <span class="comment">//在数组中找最小值，其下标为k</span></span><br><span class="line">                <span class="comment">//找距离最小生成树最近的结点，就是最小权值 </span></span><br><span class="line">                min = minweight[j];</span><br><span class="line">                k = j;</span><br><span class="line">            &#125;</span><br><span class="line">        minweight[k] = <span class="number">0</span>;  <span class="comment">//找到最小树的一个顶点，</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            <span class="keyword">if</span> (minweight[j] != <span class="number">0</span> &amp;&amp; weights[k][j] &lt; minweight[j]) &#123;  <span class="comment">//根据最新加入的点k去更新minweight数组； </span></span><br><span class="line">                minweight[j] = weights[k][j];    <span class="comment">//将小于当前权值的边(k,j)权值加入数组中</span></span><br><span class="line">                edges[j] = k;   <span class="comment">//将边(j,k)信息存入边数组中</span></span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//kruskal算法 </span></span><br></pre></td></tr></table></figure>
<h1>动态规划</h1>
<h2 id="01背包">01背包</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> max_num 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> max_weight 200</span></span><br><span class="line"><span class="type">int</span> weight[<span class="number">202</span>], value[<span class="number">202</span>];</span><br><span class="line"><span class="type">int</span> dp[max_num][max_weight];<span class="comment">//dp[i][j]表示考虑前i件商品，有j的容量能取到的最大价值 </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> n, m;<span class="comment">//m就是定义的最大容量 </span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;weight[i], &amp;value[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &lt; weight[i])dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = max(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - weight[i]] + value[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//考虑第i件物品时，当前容量j，商品weight[i]</span></span><br><span class="line"><span class="comment">//如果j能够装下第i件商品，dp[i][j]=dp[i-1][j-weight[i]]+value[i],这是拿下该商品的价值</span></span><br><span class="line"><span class="comment">//如果能装下，但是不买，dp[i][j]=dp[i-1][j],等价于考虑前i-1件商品的情况j容量</span></span><br><span class="line"><span class="comment">//对于内外层循环的参数选择，以及从大到小，或者从小到大的顺序选择,</span></span><br><span class="line"><span class="comment">//以设置的二维dp数组的第一个参数作为行，第二个作为列，画出二维对应图表</span></span><br><span class="line"><span class="comment">//那么dp[i][j]的数值与dp[i-1][j]或者dp[i-1][j-weight[i]]有关，也就是上一行有关，</span></span><br><span class="line"><span class="comment">//而j的取值与j或者j-weight[i]有关，所以确定循环方式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//超级优化：一维滚动数组，详细参考csdn文章 </span></span><br><span class="line"><span class="comment">/*int dp[max_weight];</span></span><br><span class="line"><span class="comment">    for(int i=1;i&lt;=n;i++)&#123;</span></span><br><span class="line"><span class="comment">        for(int j=m;j&gt;=weight[i];j--)&#123;</span></span><br><span class="line"><span class="comment">            dp[j]=max(dp[j],dp[j-weight[i]]+value[i]);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br></pre></td></tr></table></figure>
<h2 id="多重背包-二进制优化">多重背包(二进制优化)</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> max_num 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> max_weight 200</span></span><br><span class="line"><span class="type">int</span> weight[<span class="number">202</span>], value[<span class="number">202</span>];</span><br><span class="line"><span class="type">int</span> dp[max_num][max_weight];<span class="comment">//dp[i][j]表示考虑前i件商品，有j的容量能取到的最大价值 </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="type">int</span> v, w, num;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;v, &amp;w, &amp;num);</span><br><span class="line">        <span class="comment">//对num进行2进制拆解，1，2，4，8，16 .........以及一个无法继续取到的余数</span></span><br><span class="line">        <span class="comment">//10=1,2,4,3</span></span><br><span class="line">        <span class="comment">//58=1,2,4,8,16,27,</span></span><br><span class="line">        <span class="type">int</span> k = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (k &lt;= num) &#123;</span><br><span class="line">            value[cnt] = v * k;</span><br><span class="line">            weight[cnt++] = w * k;</span><br><span class="line">            num -= k;</span><br><span class="line">            k &lt;&lt;= <span class="number">1</span>;<span class="comment">//k乘以2 </span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            value[cnt] = v * num;</span><br><span class="line">            weight[cnt++] = w * num;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//那么就是前cnt件商品</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= cnt - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &lt; weight[i])dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = max(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - weight[i]] + value[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对于n件商品，最大容量是m，每件商品价值value，对应weight，</span></span><br><span class="line"><span class="comment">//(与01背包不同点，每件商品数量是x件，把x件全部拆解开，转换成01背包问题 </span></span><br><span class="line"><span class="comment">//拆解之后，对于数组容量需要适当进行扩大 </span></span><br></pre></td></tr></table></figure>
<h2 id="分组背包">分组背包</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> max_num 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> max_weight 200</span></span><br><span class="line"><span class="type">int</span> weight[<span class="number">100</span>][max_weight], value[<span class="number">100</span>][max_num];</span><br><span class="line"><span class="type">int</span> s[<span class="number">100</span>];<span class="comment">//表示每一组有多少个物品</span></span><br><span class="line"><span class="type">int</span> dp[<span class="number">100</span>][max_weight];<span class="comment">//前i组，最大价值 </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;s[i]);<span class="comment">//有很多个组，每个组最多只能选择一个物品 </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= s[i]; j++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;value[i][j], &amp;weight[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            dp[i][j] = dp[i - <span class="number">1</span>][j];<span class="comment">//不选第i组，从前i-1组里面选择</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= s[i]; k++) &#123;<span class="comment">//遍历第i组的所有物品 </span></span><br><span class="line">                <span class="keyword">if</span> (j &gt;= weight[i][k])</span><br><span class="line">                    dp[i][j] = max(dp[i][j], dp[i - <span class="number">1</span>][j - weight[i][k]] + value[i][k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//滚动数组优化，一维</span></span><br><span class="line"><span class="comment">//滚动数组逆向枚举，具体思想还是得画出二维表格进行推导</span></span><br><span class="line"><span class="comment">/*int f[100];</span></span><br><span class="line"><span class="comment">            for(int i=1;i&lt;=n;i++)&#123;</span></span><br><span class="line"><span class="comment">                for(int j=m;j&gt;=0;j--)&#123;</span></span><br><span class="line"><span class="comment">                    for(int k=1;k&lt;=s[i];k++)&#123;</span></span><br><span class="line"><span class="comment">                        if(j&gt;=weight[i][k])f[j]=max(f[j],f[j-weight[i][k]]+value[i][k]);</span></span><br><span class="line"><span class="comment">                    &#125;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            &#125; */</span> </span><br><span class="line">			</span><br></pre></td></tr></table></figure>
<h2 id="完全背包">完全背包</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> max_num 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> max_weight 200</span></span><br><span class="line"><span class="type">int</span> weight[<span class="number">202</span>], value[<span class="number">202</span>];</span><br><span class="line"><span class="type">int</span> dp[<span class="number">100</span>][<span class="number">200</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &lt; weight[i])dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = max(dp[i - <span class="number">1</span>][j], dp[i][j - weight[i]] + value[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*		分析完全背包问题，每个物品有无限个，求最大价值</span></span><br><span class="line"><span class="comment">	1.暴力解法</span></span><br><span class="line"><span class="comment">		for(int i=1;i&lt;=n;i++)&#123;</span></span><br><span class="line"><span class="comment">			for(int j=0;j&lt;=max_weight;j++)&#123;</span></span><br><span class="line"><span class="comment">				for(int k=0;k*weight[i]&lt;=j;k++)&#123;</span></span><br><span class="line"><span class="comment">				dp[i][j]=max(dp[i][j],dp[i-1][j-k*weight[i]]+k*value[i]);</span></span><br><span class="line"><span class="comment">				&#125;//去遍历对于每件商品的所有取值情况，取最大的价值的情况作为结果 </span></span><br><span class="line"><span class="comment">			&#125;</span></span><br><span class="line"><span class="comment">		&#125;		*/</span></span><br><span class="line"><span class="comment">/*分析：dp[i][j]=max(dp[i-1][j],dp[i-1][j-k*weight[i]]+value[i]*k);</span></span><br><span class="line"><span class="comment">        其中k取很多很多值，这里只是一个缩写,这里把j替换一下，可以实现递归整体替换 </span></span><br><span class="line"><span class="comment">        dp[i][j-weight[i]]=max(dp[i-1][j-weight[i]],dp[i-1][j-weight[i]*k]+k*value[i]);</span></span><br><span class="line"><span class="comment">        把两个式子整合在一起</span></span><br><span class="line"><span class="comment">        dp[i][j]=max(dp[i-1][j],dp[i][j-weight[i]]);</span></span><br><span class="line"><span class="comment">        只要循环的时候j从小到大遍历就行</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">    优化1：</span></span><br><span class="line"><span class="comment">    for(int i=1;i&lt;=n;i++)&#123;</span></span><br><span class="line"><span class="comment">        for(int j=0;j&lt;=max_weight;j++)&#123;</span></span><br><span class="line"><span class="comment">            if(j&lt;weight[i])dp[i][j]=dp[i-1][j];</span></span><br><span class="line"><span class="comment">            else&#123;</span></span><br><span class="line"><span class="comment">                dp[i][j]=max(dp[i-1][j],dp[i][j-weight[i]]+value[i]);</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;	</span></span><br><span class="line"><span class="comment">    超级优化,滚动数组：详细参考csdn文章 </span></span><br><span class="line"><span class="comment">        for(int i=1;i&lt;=n;i++)&#123;</span></span><br><span class="line"><span class="comment">            for(int j=weight[i];j&lt;=max_weight;j++)&#123;</span></span><br><span class="line"><span class="comment">                f[j]=max(f[j],f[j-weight[i]]+value[i]);</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            直接优化成为一维了*/</span></span><br></pre></td></tr></table></figure>
<h1>排序</h1>
<h2 id="二路归并">二路归并</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//归并排序 非递归版本</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MergeSortNonR</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> *tmp = (<span class="type">int</span> *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * n);</span><br><span class="line">    <span class="keyword">if</span> (tmp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;申请空间失败\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> gap = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (gap &lt; n) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i += <span class="number">2</span> * gap) &#123; <span class="comment">//每次跨越两组</span></span><br><span class="line">            <span class="type">int</span> begin1 = i, end1 = i + gap - <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> begin2 = i + gap, end2 = i + <span class="number">2</span> * gap - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (end1 &gt;= n || begin2 &gt;= n) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (end2 &gt;= n) &#123;</span><br><span class="line">                end2 = n - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//归并</span></span><br><span class="line">            <span class="type">int</span> j = begin1;</span><br><span class="line">            <span class="type">int</span> m = end2 - begin1 + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (begin1 &lt;= end1 &amp;&amp; begin2 &lt;= end2) &#123;</span><br><span class="line">                <span class="keyword">if</span> (a[begin1] &lt;= a[begin2]) &#123;</span><br><span class="line">                    tmp[j++] = a[begin1++];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    tmp[j++] = a[begin2++];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (begin1 &lt;= end1) &#123;</span><br><span class="line">                tmp[j++] = a[begin1++];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (begin2 &lt;= end2) &#123;</span><br><span class="line">                tmp[j++] = a[begin2++];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">memcpy</span>(a + i, tmp + i, <span class="keyword">sizeof</span>(<span class="type">int</span>) * m);<span class="comment">//局部复制，end2 - begin1 + 1</span></span><br><span class="line">        &#125;</span><br><span class="line">        gap *= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(tmp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//归并排序的递归///////数据不能太大，不然会爆栈</span></span><br><span class="line"><span class="comment">//////////////////////////</span></span><br><span class="line"><span class="comment">//辅助归并排序递归的子函数</span></span><br><span class="line"><span class="type">void</span> _MergeSort(<span class="type">int</span> *a, <span class="type">int</span> *tmp, <span class="type">int</span> begin, <span class="type">int</span> end) &#123;</span><br><span class="line">    <span class="keyword">if</span> (begin &gt;= end)</span><br><span class="line">        <span class="keyword">return</span>;<span class="comment">//单个或者不存在其区间就结束递归</span></span><br><span class="line">    <span class="comment">//类似于后序：</span></span><br><span class="line">    <span class="type">int</span> middle = (begin + end) / <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> begin1 = begin;</span><br><span class="line">    <span class="type">int</span> end1 = middle;</span><br><span class="line">    <span class="type">int</span> begin2 = middle + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> end2 = end;</span><br><span class="line">    _MergeSort(a, tmp, begin1, end1);</span><br><span class="line">    _MergeSort(a, tmp, begin2, end2);</span><br><span class="line">    <span class="comment">//此时认为 [begin1, end1] 和 [begin2, end2]两段区间上有序</span></span><br><span class="line">    <span class="comment">//归并算法</span></span><br><span class="line">    <span class="type">int</span> i = begin;</span><br><span class="line">    <span class="keyword">while</span> (begin1 &lt;= end1 &amp;&amp; begin2 &lt;= end2) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[begin1] &lt;= a[begin2]) &#123;</span><br><span class="line">            tmp[i++] = a[begin1++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tmp[i++] = a[begin2++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (begin1 &lt;= end1) &#123;</span><br><span class="line">        tmp[i++] = a[begin1++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (begin2 &lt;= end2) &#123;</span><br><span class="line">        tmp[i++] = a[begin2++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memcpy</span>(a + begin, tmp + begin, <span class="keyword">sizeof</span>(<span class="type">int</span>) * (end - begin + <span class="number">1</span>));<span class="comment">//内存操作函数，可以将整个数组的数复制过去</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//归并排序 递归版本</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MergeSort</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> *tmp = (<span class="type">int</span> *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * n);<span class="comment">//首先malloc一个数组</span></span><br><span class="line">    <span class="keyword">if</span> (tmp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;未能申请到内存\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//第一次传入 0 和 n - 1 传入闭区间</span></span><br><span class="line">    _MergeSort(a, tmp, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">free</span>(tmp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="手写快排">手写快排</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE 6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//快速排序</span></span><br><span class="line"><span class="comment">//升序排列，tmp=num[low]</span></span><br><span class="line"><span class="comment">//降序排列，tmp=num[high] </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">quick_sort</span><span class="params">(<span class="type">int</span> num[], <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i, j, temp;</span><br><span class="line">    <span class="type">int</span> tmp;</span><br><span class="line">    i = low;</span><br><span class="line">    j = high;<span class="comment">//快排区间； </span></span><br><span class="line">    tmp = num[low];   <span class="comment">//任命为中间分界线，左边比他小，右边比他大,通常第一个元素是基准数</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt; j) &#123;  <span class="comment">//如果下标i大于下标j，函数结束运行</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i != j) &#123;</span><br><span class="line">        <span class="keyword">while</span> (num[j] &gt;= tmp &amp;&amp; j &gt; i) &#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (num[i] &lt;= tmp &amp;&amp; j &gt; i) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j &gt; i) &#123;</span><br><span class="line">            temp = num[j];</span><br><span class="line">            num[j] = num[i];</span><br><span class="line">            num[i] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">//调整完基准数，分为三分区域，i，比i小的，比i大的； 如果有特数需求，可以只排某位后面的，或者前面的； </span></span><br><span class="line">    num[low] = num[i];</span><br><span class="line">    num[i] = tmp;</span><br><span class="line">    quick_sort(num, low, i - <span class="number">1</span>);</span><br><span class="line">    quick_sort(num, i + <span class="number">1</span>, high);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>其它</h1>
<h2 id="KMP">KMP</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">getnext</span><span class="params">(<span class="type">char</span> T[], <span class="type">int</span> next[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">-1</span>;</span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (T[i] != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">-1</span> || T[i] == T[j]) &#123;</span><br><span class="line">            <span class="comment">// i为后缀位置；j为前缀位置</span></span><br><span class="line">            <span class="comment">//如果新的位置匹配成功，那么说明next[k+1]= j+1;</span></span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            j = next[j]; <span class="comment">//若字符不同，则j值回溯</span></span><br><span class="line">        <span class="comment">//这里的回溯是在前j项里面找最大前后缀，而原串在j位置已经匹配了最大前后缀，所以</span></span><br><span class="line">        <span class="comment">//在前缀里面找最大前后缀，等价于找整个原串的新最大前后缀（类似于递归） </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">KMPindex</span><span class="params">(<span class="type">char</span> S[], <span class="type">char</span> T[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, *next;</span><br><span class="line">    next = (<span class="type">int</span> *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * (<span class="built_in">strlen</span>(T) + <span class="number">1</span>));</span><br><span class="line">    getnext(T, next); <span class="comment">//求next</span></span><br><span class="line">    <span class="keyword">while</span> (S[i] != <span class="string">&#x27;\0&#x27;</span> &amp;&amp; T[j] != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (S[i] == T[j]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line"><span class="comment">//j回退到相应位置开始匹配，i不变</span></span><br><span class="line">            (j == <span class="number">0</span>) ? i++ : (j = next[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(next);</span><br><span class="line">    <span class="keyword">if</span> (T[j] == <span class="string">&#x27;\0&#x27;</span>) <span class="comment">//匹配成功，返回匹配位置</span></span><br><span class="line">        <span class="keyword">return</span> i - j;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="快速幂">快速幂</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> <span class="title function_">low_mul</span><span class="params">(<span class="type">long</span> <span class="type">long</span> x, <span class="type">long</span> <span class="type">long</span> y, <span class="type">long</span> <span class="type">long</span> mod)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (y) &#123;</span><br><span class="line">        <span class="keyword">if</span> (y &amp; <span class="number">1</span>)</span><br><span class="line">            sum = (sum + x) % mod;</span><br><span class="line">        x = (x + x) % mod;</span><br><span class="line">        y &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对x*y拆分成为x+x+x。。。。，进行一个加速的取模，</span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> <span class="title function_">quick_mul</span><span class="params">(<span class="type">long</span> <span class="type">long</span> base, <span class="type">long</span> <span class="type">long</span> power, <span class="type">long</span> <span class="type">long</span> p)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> result = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld%lld&quot;</span>, &amp;base, &amp;power, &amp;p);</span><br><span class="line">    <span class="keyword">while</span> (power) &#123;</span><br><span class="line">        <span class="keyword">if</span> (power &amp; <span class="number">1</span>)<span class="comment">//power%2==1</span></span><br><span class="line">            result = (low_mul(result, base, p)) % p;</span><br><span class="line">        base = low_mul(base, base, p) % p;</span><br><span class="line">        power &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//base是底数，power是幂次，p是模数 </span></span><br></pre></td></tr></table></figure>
<h2 id="欧拉筛">欧拉筛</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> not_prime[<span class="number">1005</span>], prime[<span class="number">1005</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= max_num; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!not_prime[i])</span><br><span class="line">            prime[++cnt] = i;</span><br><span class="line">        <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= cnt &amp;&amp; prime[j] &lt;= max_num / i; j++) &#123;</span><br><span class="line">            not_prime[i * prime[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % prime[j] == <span class="number">0</span>)<span class="comment">//注意</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="简易计算器-单位数">简易计算器(单位数)</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 205</span></span><br><span class="line"><span class="type">char</span> stack_ch[MAXSIZE];</span><br><span class="line"><span class="type">char</span> stack_later[MAXSIZE];</span><br><span class="line"><span class="type">char</span> s[MAXSIZE];</span><br><span class="line"><span class="type">int</span> stack_cal[MAXSIZE];</span><br><span class="line"><span class="type">int</span> top_ch = <span class="number">-1</span>, top_la = <span class="number">-1</span>, top_cal = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">priority</span><span class="params">(<span class="type">char</span> c)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="string">&#x27;^&#x27;</span>)<span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;*&#x27;</span> || c == <span class="string">&#x27;/&#x27;</span> || c == <span class="string">&#x27;%&#x27;</span>)<span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;+&#x27;</span> || c == <span class="string">&#x27;-&#x27;</span>)<span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;(&#x27;</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;#&#x27;</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">isEmpty</span><span class="params">(<span class="type">int</span> top)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (top == <span class="number">-1</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">push</span><span class="params">(<span class="type">char</span> <span class="built_in">stack</span>[], <span class="type">int</span> *top, <span class="type">char</span> item)</span> &#123;</span><br><span class="line">    <span class="built_in">stack</span>[++(*top)] = item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">push_int</span><span class="params">(<span class="type">int</span> <span class="built_in">stack</span>[], <span class="type">int</span> *top, <span class="type">int</span> item)</span> &#123;</span><br><span class="line">    <span class="built_in">stack</span>[++(*top)] = item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> <span class="title function_">pop</span><span class="params">(<span class="type">char</span> <span class="built_in">stack</span>[], <span class="type">int</span> *top)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(*top)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error!&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">stack</span>[(*top)--];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pop_int</span><span class="params">(<span class="type">int</span> <span class="built_in">stack</span>[], <span class="type">int</span> *top)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(*top)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error!&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">stack</span>[(*top)--];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">my_power</span><span class="params">(<span class="type">int</span> base, <span class="type">int</span> power)</span> &#123;</span><br><span class="line">    <span class="type">int</span> k = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; power; i++) &#123;</span><br><span class="line">        k *= base;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s);<span class="comment">//读取中缀表达式；</span></span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    top_ch++;</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line"></span><br><span class="line">    stack_ch[top_ch] = <span class="string">&#x27;#&#x27;</span>;<span class="comment">//作为结束符； </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&#x27;0&#x27;</span> &lt;= s[i] &amp;&amp; s[i] &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">            push(stack_later, &amp;top_la, s[i]);<span class="comment">//数字直接入栈； </span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//操作符 </span></span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;(&#x27;</span>) &#123;<span class="comment">//入栈； </span></span><br><span class="line">                push(stack_ch, &amp;top_ch, s[i]);<span class="comment">//左括号直接入栈； </span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;)&#x27;</span>) &#123;<span class="comment">//依次弹出直到&#x27;(&#x27;,而且删除左括号； </span></span><br><span class="line">                ch = pop(stack_ch, &amp;top_ch);<span class="comment">//从符号栈弹出 </span></span><br><span class="line">                <span class="keyword">while</span> (ch != <span class="string">&#x27;(&#x27;</span> &amp;&amp; ch != <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">                    push(stack_later, &amp;top_la, ch);<span class="comment">//进入后缀栈； </span></span><br><span class="line">                    ch = pop(stack_ch, &amp;top_ch);<span class="comment">//当它是左括号时退出，top_ch指向左括号前面一个位置 </span></span><br><span class="line">                &#125;</span><br><span class="line">                stack_ch[top_ch + <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;<span class="comment">//删除左括号（不知道这样需不需要） </span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;^&#x27;</span>) &#123;<span class="comment">//幂直接入符号栈 </span></span><br><span class="line">                push(stack_ch, &amp;top_ch, s[i]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//最难部分，各种不同优先级操作字符； </span></span><br><span class="line">                <span class="keyword">if</span> (priority(s[i]) &gt; priority(stack_ch[top_ch])) &#123;<span class="comment">//新操作符优先级高于栈顶，直接入栈； </span></span><br><span class="line">                    push(stack_ch, &amp;top_ch, s[i]);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;<span class="comment">//否则依次弹出，直至优先级比它低，或者左括号；然后再进栈； </span></span><br><span class="line">                    ch = pop(stack_ch, &amp;top_ch);</span><br><span class="line">                    <span class="keyword">while</span> (priority(ch) &gt;= priority(s[i]) || ch != <span class="string">&#x27;(&#x27;</span>) &#123;<span class="comment">//低，或者左括号作为退出条件； </span></span><br><span class="line">                        push(stack_later, &amp;top_la, ch);</span><br><span class="line">                        ch = stack_ch[top_ch];</span><br><span class="line">                        <span class="keyword">if</span> (ch == <span class="string">&#x27;(&#x27;</span>) &#123;<span class="comment">//；入栈新操作符，然后跳出 </span></span><br><span class="line">                            push(stack_ch, &amp;top_ch, s[i]);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (priority(ch) &lt; priority(s[i])) &#123;</span><br><span class="line">                            push(stack_ch, &amp;top_ch, s[i]);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;<span class="comment">//说明无法跳出； </span></span><br><span class="line">                            ch = pop(stack_ch, &amp;top_ch);<span class="comment">//继续弹出操作符； </span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (stack_ch[top_ch] != <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">        ch = pop(stack_ch, &amp;top_ch);</span><br><span class="line">        push(stack_later, &amp;top_la, ch);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">///到这里就是后缀表达式； </span></span><br><span class="line">    <span class="comment">//printf(&quot;%s&quot;,stack_later);</span></span><br><span class="line">    <span class="comment">//遍历一遍后缀表达式 </span></span><br><span class="line">    <span class="type">int</span> len_la = <span class="built_in">strlen</span>(stack_later);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len_la; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&#x27;0&#x27;</span> &lt;= stack_later[i] &amp;&amp; stack_later[i] &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;<span class="comment">//是数字，入数字栈 </span></span><br><span class="line">            push_int(stack_cal, &amp;top_cal, stack_later[i] - <span class="string">&#x27;0&#x27;</span>);<span class="comment">//入栈 </span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//遇到操作符，第二个出栈数字   操作。。。 第一个出栈数字 </span></span><br><span class="line">            <span class="type">int</span> num1 = pop_int(stack_cal, &amp;top_cal);</span><br><span class="line">            <span class="type">int</span> num2 = pop_int(stack_cal, &amp;top_cal);<span class="comment">//弹出两个数字； </span></span><br><span class="line">            <span class="keyword">switch</span> (stack_later[i]) &#123;<span class="comment">//计算结果入栈 </span></span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                    push_int(stack_cal, &amp;top_cal, num2 + num1);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                    push_int(stack_cal, &amp;top_cal, num2 - num1);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                    push_int(stack_cal, &amp;top_cal, num2 * num1);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">                    push_int(stack_cal, &amp;top_cal, num2 / num1);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;%&#x27;</span>:</span><br><span class="line">                    push_int(stack_cal, &amp;top_cal, num2 % num1);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;^&#x27;</span>:</span><br><span class="line">                    push_int(stack_cal, &amp;top_cal, my_power(num2, num1));</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, stack_cal[top_cal]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="简易计算器-多位数">简易计算器(多位数)</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 205</span></span><br><span class="line"><span class="type">char</span> stack_ch[MAXSIZE];<span class="comment">//操作符临时栈 </span></span><br><span class="line"><span class="type">char</span> stack_later[MAXSIZE];<span class="comment">//操作符号最终栈； </span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> stack_num[MAXSIZE];<span class="comment">//数字栈； </span></span><br><span class="line"><span class="type">char</span> s[MAXSIZE];<span class="comment">//初始读取数组； </span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> stack_cal[MAXSIZE];<span class="comment">//计算栈；</span></span><br><span class="line"><span class="type">int</span> flag_sign[MAXSIZE];<span class="comment">//记录顺序数组，1表示这里使用数字栈，2表示使用符号栈 </span></span><br><span class="line"><span class="type">int</span> top_ch = <span class="number">-1</span>, top_num = <span class="number">-1</span>, top_cal = <span class="number">-1</span>, top_la = <span class="number">-1</span>;</span><br><span class="line"><span class="type">int</span> cnt_sign = <span class="number">0</span>;<span class="comment">//记录对应使用的栈的种类； </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">priority</span><span class="params">(<span class="type">char</span> c)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="string">&#x27;^&#x27;</span>)<span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;*&#x27;</span> || c == <span class="string">&#x27;/&#x27;</span> || c == <span class="string">&#x27;%&#x27;</span>)<span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;+&#x27;</span> || c == <span class="string">&#x27;-&#x27;</span>)<span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;(&#x27;</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;#&#x27;</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">isEmpty</span><span class="params">(<span class="type">int</span> top)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (top == <span class="number">-1</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">push_ch</span><span class="params">(<span class="type">char</span> <span class="built_in">stack</span>[], <span class="type">int</span> *top, <span class="type">char</span> item)</span> &#123;<span class="comment">//入字符栈 </span></span><br><span class="line">    <span class="built_in">stack</span>[++(*top)] = item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">push_num</span><span class="params">(<span class="type">long</span> <span class="type">long</span> <span class="built_in">stack</span>[], <span class="type">int</span> *top, <span class="type">long</span> <span class="type">long</span> item)</span> &#123;<span class="comment">//入数字栈 </span></span><br><span class="line">    <span class="built_in">stack</span>[++(*top)] = item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> <span class="title function_">pop_ch</span><span class="params">(<span class="type">char</span> <span class="built_in">stack</span>[], <span class="type">int</span> *top)</span> &#123;<span class="comment">//弹出符号栈 </span></span><br><span class="line">    <span class="keyword">if</span> (isEmpty(*top)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error!&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">stack</span>[(*top)--];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> <span class="title function_">pop_num</span><span class="params">(<span class="type">long</span> <span class="type">long</span> <span class="built_in">stack</span>[], <span class="type">int</span> *top)</span> &#123;<span class="comment">//弹出数字栈 </span></span><br><span class="line">    <span class="keyword">if</span> (isEmpty(*top)) &#123;</span><br><span class="line">        <span class="comment">//printf(&quot;error!&quot;);</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//解决负号问题； </span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">stack</span>[(*top)--];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">my_power</span><span class="params">(<span class="type">long</span> <span class="type">long</span> base, <span class="type">long</span> <span class="type">long</span> power)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> k = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; power; i++) &#123;</span><br><span class="line">        k *= base;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s);<span class="comment">//读取中缀表达式；//此处不修改 </span></span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    top_ch++;</span><br><span class="line">    stack_ch[top_ch] = <span class="string">&#x27;#&#x27;</span>;<span class="comment">//作为结束符；//不修改 </span></span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> tmp = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> flag_num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;<span class="comment">//b遍历所有输入的字符； </span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&#x27;0&#x27;</span> &lt;= s[i] &amp;&amp; s[i] &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;<span class="comment">//读取到数字，准备转换这个字符，变成多位（单位）数字； </span></span><br><span class="line">            tmp *= <span class="number">10</span>;</span><br><span class="line">            tmp += s[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            flag_num = <span class="number">1</span>; <span class="comment">//标记数字； </span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//操作符</span></span><br><span class="line">            <span class="comment">//说明要中断数字读取</span></span><br><span class="line">            <span class="keyword">if</span> (flag_num == <span class="number">1</span>) &#123;<span class="comment">//标记成功，之前有数字需要转换； </span></span><br><span class="line">                push_num(stack_num, &amp;top_num, tmp); <span class="comment">//入数字栈，并且清除各种标记；</span></span><br><span class="line">                flag_num = <span class="number">0</span>;</span><br><span class="line">                tmp = <span class="number">0</span>;</span><br><span class="line">                flag_sign[cnt_sign++] = <span class="number">1</span>;<span class="comment">//是数字标记 </span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;(&#x27;</span>) &#123;<span class="comment">//入临时符号栈 </span></span><br><span class="line">                push_ch(stack_ch, &amp;top_ch, s[i]);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;)&#x27;</span>) &#123;<span class="comment">//依次弹出直到&#x27;(&#x27;,而且删除左括号； </span></span><br><span class="line">                ch = pop_ch(stack_ch, &amp;top_ch);<span class="comment">//从临时符号栈弹出， </span></span><br><span class="line">                <span class="keyword">while</span> (ch != <span class="string">&#x27;(&#x27;</span> &amp;&amp; ch != <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">                    push_ch(stack_later, &amp;top_la, ch);<span class="comment">//进入最终栈；</span></span><br><span class="line">                    flag_sign[cnt_sign++] = <span class="number">2</span>;<span class="comment">//是操作符标记  </span></span><br><span class="line">                    ch = pop_ch(stack_ch, &amp;top_ch);<span class="comment">//当它是左括号时退出，top_ch指向左括号前面一个位置 </span></span><br><span class="line">                &#125;</span><br><span class="line">                stack_ch[top_ch + <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;<span class="comment">//删除左括号（不知道这样需不需要） </span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;^&#x27;</span>) &#123;<span class="comment">//幂直接入临时符号栈 </span></span><br><span class="line">                push_ch(stack_ch, &amp;top_ch, s[i]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//最难部分，各种不同优先级操作字符； </span></span><br><span class="line">                <span class="keyword">if</span> (priority(s[i]) &gt; priority(stack_ch[top_ch])) &#123;<span class="comment">//新操作符优先级高于临时栈栈顶，直接入临时栈； </span></span><br><span class="line">                    push_ch(stack_ch, &amp;top_ch, s[i]);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;<span class="comment">//否则依次弹出到最终栈，直至优先级比它低，或者左括号；然后再进临时栈； </span></span><br><span class="line">                    ch = pop_ch(stack_ch, &amp;top_ch);</span><br><span class="line">                    <span class="keyword">while</span> (priority(ch) &gt;= priority(s[i]) || ch != <span class="string">&#x27;(&#x27;</span>) &#123;<span class="comment">//低，或者左括号作为退出条件； </span></span><br><span class="line">                        push_ch(stack_later, &amp;top_la, ch);</span><br><span class="line">                        flag_sign[cnt_sign++] = <span class="number">2</span>;<span class="comment">//是操作符标记 </span></span><br><span class="line">                        ch = stack_ch[top_ch];</span><br><span class="line">                        <span class="keyword">if</span> (ch == <span class="string">&#x27;(&#x27;</span>) &#123;<span class="comment">//；入栈新操作符，然后跳出 </span></span><br><span class="line">                            push_ch(stack_ch, &amp;top_ch, s[i]);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (priority(ch) &lt; priority(s[i])) &#123;</span><br><span class="line">                            push_ch(stack_ch, &amp;top_ch, s[i]);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;<span class="comment">//说明无法跳出； </span></span><br><span class="line">                            ch = pop_ch(stack_ch, &amp;top_ch);<span class="comment">//继续弹出操作符； </span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//可能有末尾数字没录进去，</span></span><br><span class="line">    <span class="keyword">if</span> (flag_num == <span class="number">1</span>) &#123;</span><br><span class="line">        push_num(stack_num, &amp;top_num, tmp);</span><br><span class="line">        flag_sign[cnt_sign++] = <span class="number">1</span>;<span class="comment">//是数字标记 </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (stack_ch[top_ch] != <span class="string">&#x27;#&#x27;</span>) &#123;<span class="comment">//临时字符栈里面全部弹出到最终栈，并且标记顺序； </span></span><br><span class="line">        ch = pop_ch(stack_ch, &amp;top_ch);</span><br><span class="line">        push_ch(stack_later, &amp;top_la, ch);</span><br><span class="line">        flag_sign[cnt_sign++] = <span class="number">2</span>;<span class="comment">//是操作符标记 </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//到这里所有操作符都在stack_la里面，所有数字都在stack_num里面，有flag_sign数组存取各个操作符应该出现的顺序 </span></span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>, k = <span class="number">0</span>;<span class="comment">//j代表数字栈的下标，k代表符号栈的下标； </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; cnt_sign; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (flag_sign[i] == <span class="number">1</span>) &#123;<span class="comment">//是数字，入数字栈 </span></span><br><span class="line">            push_num(stack_cal, &amp;top_cal, stack_num[j++]);<span class="comment">//入计算栈 </span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (flag_sign[i] == <span class="number">2</span>) &#123;<span class="comment">//遇到操作符，第二个出栈数字   操作。。。 第一个出栈数字 </span></span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> num1 = pop_num(stack_cal, &amp;top_cal);</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> num2 = pop_num(stack_cal, &amp;top_cal);<span class="comment">//弹出两个数字； </span></span><br><span class="line">            <span class="keyword">switch</span> (stack_later[k++]) &#123;<span class="comment">//计算结果入栈 </span></span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                    push_num(stack_cal, &amp;top_cal, num2 + num1);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                    push_num(stack_cal, &amp;top_cal, num2 - num1);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                    push_num(stack_cal, &amp;top_cal, num2 * num1);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">                    push_num(stack_cal, &amp;top_cal, num2 / num1);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;%&#x27;</span>:</span><br><span class="line">                    push_num(stack_cal, &amp;top_cal, num2 % num1);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;^&#x27;</span>:</span><br><span class="line">                    push_num(stack_cal, &amp;top_cal, my_power(num2, num1));</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>, stack_cal[top_cal]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>c语言</category>
      </categories>
      <tags>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>typedef介绍</title>
    <url>/2023/03/23/typedef%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<span id="more"></span>
<ul>
<li>
<p><em><strong>typedef解释</strong></em></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">link</span>;</span></span><br><span class="line">&#125;<span class="comment">//通常使用这种方法创建链表结点，但是每次使用&quot;结点&quot;，我们都需要敲出&quot;struct node&quot;</span></span><br><span class="line"> <span class="comment">//同样，使用自引用指针需要&quot;struct node *&quot;，非常的麻烦，而且在一个c语言文件中不只有一类结点时非常混乱</span></span><br></pre></td></tr></table></figure>
<p>基于此我们引入&quot;typedef&quot;,typedef 类似于重命名操作，和&quot;define&quot;非常相似</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> max 1000 <span class="comment">//这里我们把max&quot;转换&quot;成1000(本人菜菜，想不到专业的话来解释，因此使用“转换”一词)</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> elementType <span class="comment">//这里我们使用 typedef 重命名 int 为 elementType</span></span><br><span class="line"><span class="comment">//typedef 的作用对象一般是&quot;类型&quot;，</span></span><br><span class="line">    <span class="comment">//类型包含系统自带的类型：char, short, int, long, long long, float, double等等</span></span><br><span class="line">    <span class="comment">//也包含用户自定义的类型：结构体</span></span><br><span class="line"><span class="comment">//考虑链表结点的创建</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">link</span>;</span></span><br><span class="line">&#125;<span class="comment">//这里的struct node就是用户自定义类型，因此可以使用typedef进行&quot;改名&quot;操作</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">link</span>;</span><span class="comment">//到这一步还未完成重命名操作，因此不可以用重命名之后的指针来替换struct node *</span></span><br><span class="line">&#125;Node,*Nodeptr;<span class="comment">//一般把重命名的名字写在大括号后面。</span></span><br><span class="line"><span class="comment">//这里的操作可以解释为以下两条语句</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> <span class="title">Node</span>;</span><span class="comment">//Node 表示struct node</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> * <span class="title">Nodeptr</span>;</span><span class="comment">//Nodeptr 表示struct node *</span></span><br><span class="line"><span class="comment">//考虑如下代码</span></span><br><span class="line"><span class="type">int</span> *a, b;<span class="comment">//这里的a是int*型的指针，而b是int整型</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">a</span>, <span class="title">b</span>;</span><span class="comment">//这里a是struct node *型的指针，b却是自定义类型struct node;</span></span><br><span class="line">Nodeptr a, b;<span class="comment">//这里用Nodeptr表示struct node *,不是简单的替换关系，a和b都是struct node* 型的指针。</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>c语言</category>
      </categories>
      <tags>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构</title>
    <url>/2023/03/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<ul>
<li>本文所有内容均出自微信公众号&quot;labuladong&quot;,公众号本身代码均以java代码块形式呈现，本文将以c语言呈现。文章类似转载，但是已经声明出处，并修改代码为c语言，此内容主要是记录博主自身学习过程，有疑惑建议翻看原文</li>
</ul>
<span id="more"></span>
<h1>数据结构</h1>
<h2 id="链表">链表</h2>
<h3 id="合并两个有序链表">合并两个有序链表</h3>
<p><img src="https://soybeanlittlecar.oss-cn-beijing.aliyuncs.com/blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E5%8D%95%E9%93%BE%E8%A1%A8.jpg" alt="两个链表合并"></p>
<p>采用双指针实现，这里封装函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">link</span>;</span></span><br><span class="line">&#125; Node, *Nodeprt;</span><br><span class="line"></span><br><span class="line">Nodeprt <span class="title function_">mergeTwoLists</span><span class="params">(Nodeprt l1, Nodeprt l2)</span> &#123;</span><br><span class="line">    <span class="comment">//这里用两个指针分别指向两条链表的头结点，最终返回链表头节点,默认单增</span></span><br><span class="line">    Nodeprt head = (Nodeprt) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    Nodeprt p = head;<span class="comment">//虚拟头结点</span></span><br><span class="line">    <span class="keyword">while</span> (l1 != <span class="literal">NULL</span> &amp;&amp; l2 != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p1-&gt;data &gt; p2-&gt;data) &#123;</span><br><span class="line">            p-&gt;link = l2;</span><br><span class="line">            l2 = l2-&gt;link;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            p-&gt;link = l1;</span><br><span class="line">            l1 = l1-&gt;link;</span><br><span class="line">        &#125;</span><br><span class="line">        p = p-&gt;link;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p1 != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        p-&gt;link = l1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p2 != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        p-&gt;link = l2;</span><br><span class="line">    &#125;</span><br><span class="line">    p = head-&gt;link;<span class="comment">//重新指向头结点</span></span><br><span class="line">    <span class="built_in">free</span>(head);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="合并k个有序链表">合并k个有序链表</h3>
<p><img src="https://soybeanlittlecar.oss-cn-beijing.aliyuncs.com/blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%90%88%E5%B9%B6k%E4%B8%AA%E5%8D%95%E9%93%BE%E8%A1%A8.jpg" alt="合并k个有序链表"></p>
<p>合并k个有序链表的难点在于如何快速得到k个链表当中的最小节点并且接到链表上</p>
<p>这里采用<strong>优先队列(二叉堆)</strong>，把链表节点放到一个最小堆里面，每次获得k个节点中的最小节点。最开始堆中都是k条链表的头，每次弹出一个元素的同时，对应链表需要后移一位，然后将新的头插入到最小堆中，然后调整堆</p>
<p>最小堆模板</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MinData -1001</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElementType;<span class="comment">//自定义数据类型； </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">HeapStruct</span> &#123;</span></span><br><span class="line">    ElementType *Elements;<span class="comment">//存储堆元素的数组，指针数组</span></span><br><span class="line">    <span class="type">int</span> size;    <span class="comment">//堆的当前元素个数； </span></span><br><span class="line">    <span class="type">int</span> capacity;<span class="comment">//堆的最大容量 </span></span><br><span class="line">&#125; MinHeap, *MinHeapPrt;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">IsFull</span><span class="params">(MinHeapPrt H)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (H-&gt;size == Maxsize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">IsEmpty</span><span class="params">(MinHeapPrt H)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (H-&gt;size == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MinHeapPrt <span class="title function_">Create</span><span class="params">(<span class="type">int</span> Maxsize)</span> &#123;</span><br><span class="line">    <span class="comment">//创建容量为Maxsize的空的最小堆</span></span><br><span class="line">    <span class="comment">//从1开始插入元素，0留给哨兵； </span></span><br><span class="line">    MinHeapPrt H = (MinHeapPrt) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(MinHeap));</span><br><span class="line">    H-&gt;Elements = (ElementType *) <span class="built_in">malloc</span>((Maxsize + <span class="number">1</span>) * <span class="keyword">sizeof</span>(ElementType));</span><br><span class="line">    H-&gt;size = <span class="number">0</span>;</span><br><span class="line">    H-&gt;capacity = Maxsize;</span><br><span class="line">    H-&gt;Elements[<span class="number">0</span>] = MinData;<span class="comment">//随便找一个特别小，比所有输入数据小的元素就行； </span></span><br><span class="line">    <span class="comment">//MinData.定义哨兵为小于堆中所有可能元素的值，便于以后更快操作</span></span><br><span class="line">    <span class="keyword">return</span> H;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">insert</span><span class="params">(MinHeapPrt H, ElementType item)</span> &#123;</span><br><span class="line">    <span class="comment">//将元素item插入最小堆H，其中H-&gt;Elements[0]已经定义为哨兵；</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">if</span> (IsFull(H)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;最小堆已满&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    i = ++H-&gt;size;<span class="comment">//i指向插入后的最后一个元素位置； </span></span><br><span class="line">    <span class="keyword">for</span> (; H-&gt;Elements[i / <span class="number">2</span>] &gt; item; i /= <span class="number">2</span>)<span class="comment">//完全二叉树有i/2表示父结点的性质；如果父结点比目标item大，</span></span><br><span class="line">        <span class="comment">//这里会有i=1的情况，但是有哨兵存在，哨兵保证了所有输入数据都比哨兵大，如果没有哨兵，可以加一句i&gt;1; </span></span><br><span class="line">        <span class="comment">//哨兵效率更高； </span></span><br><span class="line">        H-&gt;Elements[i] = H-&gt;Elements[i / <span class="number">2</span>];<span class="comment">//保证有序性，把大小不符合的往下过滤， </span></span><br><span class="line">    H-&gt;Elements[i] = item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ElementType <span class="title function_">deleteMin</span><span class="params">(MinHeapPrt H)</span> &#123;</span><br><span class="line">    <span class="comment">//从最小堆中去除键值最小的元素，删除结点</span></span><br><span class="line">    <span class="type">int</span> parent, child;</span><br><span class="line">    ElementType MinItem, temp;</span><br><span class="line">    <span class="keyword">if</span> (IsEmpty(H)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;最小堆已空&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    MinItem = H-&gt;Elements[<span class="number">1</span>];<span class="comment">//从根结点找最小值；</span></span><br><span class="line">    <span class="comment">//用最小堆中最后一个元素从根结点开始向上过滤下层结点，就是先把最后一个元素放到根的位置</span></span><br><span class="line">    temp = H-&gt;Elements[H-&gt;size--];<span class="comment">//先赋值，再减减 </span></span><br><span class="line">    <span class="keyword">for</span> (parent = <span class="number">1</span>; parent * <span class="number">2</span> &lt;= H-&gt;size; parent = child) &#123;<span class="comment">//判断保证存在左子； </span></span><br><span class="line">        child = parent * <span class="number">2</span>;<span class="comment">//左子</span></span><br><span class="line">        <span class="keyword">if</span> ((child != H-&gt;size) &amp;&amp; (H-&gt;Elements[child] &gt; H-&gt;Elements[child + <span class="number">1</span>])) <span class="comment">//判断保证有左子的同时还有右子； </span></span><br><span class="line">            child++;<span class="comment">//左子比右子大 </span></span><br><span class="line">        <span class="keyword">if</span> (temp &lt;= H-&gt;Elements[child])<span class="keyword">break</span>;<span class="comment">//调整值比左右子都小；那就放在父的位置 </span></span><br><span class="line">        <span class="keyword">else</span><span class="comment">//移动temp元素到下一层 </span></span><br><span class="line">            H-&gt;Elements[parent] = H-&gt;Elements[child];<span class="comment">//向上过滤，往上移 </span></span><br><span class="line">    &#125;</span><br><span class="line">    H-&gt;Elements[parent] = temp;</span><br><span class="line">    <span class="keyword">return</span> MinItem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现合并k个链表</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Nodeprt <span class="title function_">mergerKLists</span><span class="params">(Nodeprt lists[], <span class="type">int</span> k)</span> &#123;<span class="comment">//传入一个指针数组，里面是k个头节点指针</span></span><br><span class="line">    Nodeprt head = (Nodeprt) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    Nodeprt p = head;</span><br><span class="line">    MinHeapPrt H = Create(k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">        insert(H, lists[i]-&gt;data);<span class="comment">//k个头节点插入最小堆</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!IsEmpty(H)) &#123;<span class="comment">//堆非空</span></span><br><span class="line">        Nodeprt q = (Nodeprt) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">        q-&gt;data = deleteMin(H);<span class="comment">//弹出堆顶元素</span></span><br><span class="line">        q-&gt;link = <span class="literal">NULL</span>;</span><br><span class="line">        p-&gt;link = q;</span><br><span class="line">        p = p-&gt;link;</span><br><span class="line">    &#125;</span><br><span class="line">    p = head-&gt;link;<span class="comment">//p作为链表头节点</span></span><br><span class="line">    <span class="built_in">free</span>(head);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="寻找单链表的倒数第k个结点">寻找单链表的倒数第k个结点</h3>
<p>从前往后找第k个节点非常简单，从后往前找k个节点也只是需要遍历两次，但是有没有更好的方法只遍历一次呢</p>
<p>有个非常巧妙的思路，当从前往后遍历k个时，拿一个指针指向头节点，那么当第一个指针到末尾时，第二个指针就指向倒数第k个节点了</p>
<p><img src="https://soybeanlittlecar.oss-cn-beijing.aliyuncs.com/blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%AF%BB%E6%89%BE%E9%93%BE%E8%A1%A8%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9-1.jpg" alt=""></p>
<p><img src="https://soybeanlittlecar.oss-cn-beijing.aliyuncs.com/blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%AF%BB%E6%89%BE%E9%93%BE%E8%A1%A8%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9-2.jpg" alt=""></p>
<p><img src="https://soybeanlittlecar.oss-cn-beijing.aliyuncs.com/blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%AF%BB%E6%89%BE%E9%93%BE%E8%A1%A8%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9-3.jpg" alt=""></p>
<h3 id="寻找单链表的中点">寻找单链表的中点</h3>
<p>单链表终点的一次遍历方法与上文类似，使用双指针(快慢指针)</p>
<h2 id="数组">数组</h2>
<h3 id="最长连续回文子串">最长连续回文子串</h3>
<p>对于一个给定的字符串，寻找其最长的连续的回文子串</p>
<p>难点：回文串的长度可能是奇数也可能是偶数，假如是奇数，那么有中心字符，如果是偶数，得从两个相邻的字符去向两侧寻找；因此先实现一个对于某个确定点找回文串的函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">palindrome</span><span class="params">(<span class="type">char</span> s[], <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (l &gt;= <span class="number">0</span> &amp;&amp; r &lt;= len - <span class="number">1</span> &amp;&amp; s[l] == s[r]) &#123;</span><br><span class="line">        l--;</span><br><span class="line">        r++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//具体细节可以使用指针来实现返回值</span></span><br><span class="line"><span class="comment">//然后就可寻找任意以s[i]为中心的回文串，或者以s[i]和s[i+1]为中心的回文串</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line"><span class="comment">//考虑所有情况，每次对于返回的长度进行比较，保留最长的即可</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="前缀和数组">前缀和数组</h3>
<p>前缀和用于速快频繁的计算一个索引区间内的元素之和</p>
<h4 id="一维前缀和">一维前缀和</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//我们可以定义一个类似于一维前缀和的二维数组</span></span><br><span class="line"><span class="comment">//预处理的时候将每一位累加起来</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">s[i] = s[i - <span class="number">1</span>] + x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这样对于任何原数组的区间和，例如区间[l,r];</span></span><br><span class="line"><span class="comment">//我们可以快速用s[r]-s[l-1]实现</span></span><br></pre></td></tr></table></figure>
<h4 id="二维矩阵的前缀和">二维矩阵的前缀和</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> sum[<span class="number">100</span>][<span class="number">100</span>];<span class="comment">//sum[i][j]表示从左上角(0,0)到(i,j)构成的矩形区域的和</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">		sum[i][j] = x + sum[i - <span class="number">1</span>][j] + sum[i][j - <span class="number">1</span>] - sum[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="差分数组">差分数组</h3>
<h4 id="一维差分">一维差分</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//对于正常的对一个广义连续的区间进行统一的加或者减去一个数字，常常使用循环遍历这个区间</span></span><br><span class="line"><span class="comment">//但是对于多次的加减操作非常麻烦，因此引出差分数组</span></span><br><span class="line"><span class="comment">//对于正常数组nums[],我们定义差分数组diff[100],diff[i]=nums[i]-nums[i-1];</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;nums[i]);</span><br><span class="line">    diff[i]=nums[i]-nums[i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于原来的<code>nums[]</code>数组，每次修改区间<code>[left,right]</code>，修改值为k，这里以加法为例子，我们只需在差分数组的<code>diff[left]+=k;	diff[right+1]-=k</code>;这样操作，这样有什么用处呢？</p>
<p>对于diff[left]+=k；我们累加的时候，从<code>nums[left]~nums[right]</code>之间的每一个数字，都加上了k，但是<code>nuns[right+1]</code>以及之后的数字不需要＋k了，因此在<code>diff[right+1]-=k</code>；进行弥补，使得这个<code>-k</code>和前面的<code>+k</code>抵消，从而实现了修改区间<code>[left,right]</code>，区间的每个数字都加上了k。</p>
<p>在最后访问第i个位置的数字<code>nums[i]</code>的时候（是经过很多次修改之后的nums[i])，我们累加<code>diff[1]，diff[2].......diff[i]</code>,将i个数字加起来作为修改后的<code>nums[i]</code>数值。</p>
<ul>
<li>
<p>写在结尾: 再次鸣谢公众号&quot;labuladong&quot;,公众号中有很多写的优质的文章和资源，对于部分算法也有着非常透彻的分析，对于本菜菜的学习有着非常大的帮助。</p>
<p><a href="https://mp.weixin.qq.com/s/GOOgO5Wp48jM9jSPzqJwOQ">原作者laluladong</a></p>
</li>
</ul>
]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划</title>
    <url>/2023/03/27/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<ul>
<li>本文为作者的动态规划学习的历程，部分内容选自公众号labuladong，部分来自洛谷刷题时或者是平常作业中遇到的问题，进而在csdn的优质文章中学习或者是洛谷的题解中学习。文中各种dp并不按照广义的学习路线设置，属于作者自身的一个学习过程</li>
</ul>
<span id="more"></span>
<h3 id="四维dp问题">四维dp问题</h3>
<p>动态规划问题通常为一维或者二维，很少出现四维。</p>
<p>对于四维dp，有如下几个特点，</p>
<ul>
<li>dp范围非常小，通常在10~50左右，保证在O(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>n</mi><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">n^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span>)时间内能够解决。</li>
<li>无法拆分成为两个二维，第一个二维能取到最优解，但是在此前提下，第二个二维dp只能取到局部最优，两者的和并不一定是全局最优解。</li>
<li>根据题目信息可以归纳出四维之间的特殊关系</li>
</ul>
<p>下面举两个例子来进行说明</p>
<ol>
<li><a href="https://www.luogu.com.cn/problem/P1004">洛谷p1004</a></li>
</ol>
<p>题目要求在<code>n*n</code>的方格中从左上角取到左下角取两次，计算两次取数的最大结果</p>
<p>分析：定义<code>dp[i][j][k][p]</code>为第一次到达ij，第二次到达kp位置时的总数值，对于每一个点，只能从其左侧一格或者上侧一格到达。对于两次取数的两种状态，一共有四种综合转移情况</p>
<p>因此我们可以考虑状态转移方程</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>p</mi><mo stretchy="false">]</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>k</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>p</mi><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>p</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>k</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>p</mi><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>p</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">)</mo><mo>+</mo><mi>m</mi><mi>a</mi><mi>p</mi><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>p</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dp[i][j][k][p]=max(dp[i-1][j][k-1][p],dp[i-1][j][k][p-1],dp[i][j-1][k-1][p],dp[i][j-1][k][p-1])+map[k][p]
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal">p</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal">p</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal">p</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">])</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">ma</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal">p</span><span class="mclose">]</span></span></span></span></span></p>
<p>我们来分析这个方程，四种位置变化的组合，最后加上对于转移到<code>(k,p)</code>点的数值<code>map[k][p]</code></p>
<p>也许你会有疑惑为什么不加上转移到<code>(i,j)</code>点的数值<code>map[i][j]</code>;	别急，听我慢慢解释</p>
<p>两次移动虽然用一个方程表示，但是实质上是两次取数的过程，第一个人从左上到右下取完之后才进行第二个人取数（第一个人取过的位置都会变成0，但是对于我们的dp过程，我们不方便将<code>map[][]</code>的某一个位置的数值变成0）</p>
<p>但是不论如何取数，即使两个人的位置有重合，对于重合点的数值<code>map[][]</code>,我们都可以都只加一次，也就是加上<code>map[k][p]</code>,而对于<code>map[i][j]</code>,我们将讨论相关条件来决定是否加入。</p>
<p>对于状态转移之后，也就是<code>dp[i][j][k][p]</code>点，表示已经到达这个状态的最大数值，那么到达此状态之后，我们可以将次状态分为两种情况</p>
<ol>
<li>点<code>(i,j)和(k,p)</code>重合，那么意味着我们只用将这个点的数值计算一次，也就是<code>map[k][p]</code>,不用考虑<code>map[i][j]</code>；</li>
<li>点<code>(i,j)和(k,p)</code>不重合，对于点<code>(k,p)</code>我们计算了其数值<code>map[k][p]</code>,那么对于到达点<code>(i,j)</code>的数值<code>map[i][j]</code>没有计算，那么我们只需要加上<code>map[i][j]</code>即可；</li>
</ol>
<p>到此状态转移方程分析结束，代码如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="built_in">map</span>[<span class="number">11</span>][<span class="number">11</span>];</span><br><span class="line"><span class="type">int</span> dp[<span class="number">11</span>][<span class="number">11</span>][<span class="number">11</span>][<span class="number">11</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//freopen(&quot;a.in&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line">    <span class="comment">//freopen(&quot;a.out&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> x, y, z;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;x, &amp;y, &amp;z);</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">0</span> &amp;&amp; y == <span class="number">0</span> &amp;&amp; z == <span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">map</span>[x][y] = z;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n; k++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> p = <span class="number">1</span>; p &lt;= n; p++) &#123;</span><br><span class="line">                    dp[i][j][k][p] = max(dp[i][j][k][p], dp[i - <span class="number">1</span>][j][k - <span class="number">1</span>][p] + <span class="built_in">map</span>[k][p]);</span><br><span class="line">                    dp[i][j][k][p] = max(dp[i][j][k][p], dp[i - <span class="number">1</span>][j][k][p - <span class="number">1</span>] + <span class="built_in">map</span>[k][p]);</span><br><span class="line">                    dp[i][j][k][p] = max(dp[i][j][k][p], dp[i][j - <span class="number">1</span>][k - <span class="number">1</span>][p] + <span class="built_in">map</span>[k][p]);</span><br><span class="line">                    dp[i][j][k][p] = max(dp[i][j][k][p], dp[i][j - <span class="number">1</span>][k][p - <span class="number">1</span>] + <span class="built_in">map</span>[k][p]);</span><br><span class="line">                    <span class="keyword">if</span> (i != k || j != p)dp[i][j][k][p] += <span class="built_in">map</span>[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, dp[n][n][n][n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><a href="https://www.luogu.com.cn/problem/P1006">洛谷p1006</a></li>
</ol>
<p>这道题和上面的方格取数有很大的相似处，但是也有部分不同，两个人的路径无法交叉,矩阵大小<strong>m行n列</strong></p>
<p>分析：路径无法交叉，意味着从左上角的同一点出发时就只能一个人向下并且到达右下顶点的左侧，一个人向右迈出第一步并且到达右下顶点的上侧；</p>
<p><img src="https://soybeanlittlecar.oss-cn-beijing.aliyuncs.com/blog/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E4%BC%A0%E7%BA%B8%E6%9D%A1-1.png" alt=""></p>
<p>这里是对于起始点和终点的判定防止交叉;	这里我们假定开始向下的为第一个人，向右的是第二个人</p>
<p>同理我们定义<code>dp[i][j][k][p]</code>表示第一个人到达<code>[i][j]</code>，第二个人到达<code>[k][p]</code>位置时的数值（好感度）总和</p>
<p>考虑第一个人，他能涉及的区域应该为矩形<code>左上角(1,1),右下角(m,n-1)</code>，因此外层循环如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n<span class="number">-1</span>; j++) &#123;</span><br><span class="line">            <span class="comment">//balabala</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然状态转移考虑的时候我们考虑两个人同时进行位置改变，但是实质上是第一个人到达<code>(i,j)</code>，在此前提之下，因为事实情况是第一个人已经到达这个确定的位置（这个位置已经是合法的了），那么说明第二个人的路径没有和第一个人当前的路径有重合，我们再来考虑第二个人，因为不能有路径交叉，第一个人的考虑范围为矩形<code>左上角(1,j+1)，右下角(m-1,n)</code>;</p>
<p>因为这个<code>(i,j)</code>能涉及的范围包括整个矩形<code>(1,1),(i,j)</code>;所以让<code>p&gt;j</code>即可保证无重合;状态转移方程如下</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>p</mi><mo stretchy="false">]</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>k</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>p</mi><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>p</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>k</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>p</mi><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>p</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">)</mo><mo>+</mo><mi>m</mi><mi>a</mi><mi>p</mi><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>p</mi><mo stretchy="false">]</mo><mo>+</mo><mi>m</mi><mi>a</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dp[i][j][k][p]=max(dp[i-1][j][k-1][p],dp[i-1][j][k][p-1],dp[i][j-1][k-1][p],dp[i][j-1][k][p-1])+map[k][p]+map[i][j]
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal">p</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal">p</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal">p</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">])</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">ma</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal">p</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">ma</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span></span></p>
<p>整体代码如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="built_in">map</span>[<span class="number">53</span>][<span class="number">53</span>];</span><br><span class="line"><span class="type">int</span> dp[<span class="number">52</span>][<span class="number">52</span>][<span class="number">52</span>][<span class="number">52</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;m, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;<span class="built_in">map</span>[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= m - <span class="number">1</span>; k++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> p = <span class="number">1</span> + j; p &lt;= n; p++) &#123;</span><br><span class="line">                    dp[i][j][k][p] = max(dp[i][j][k][p], dp[i - <span class="number">1</span>][j][k - <span class="number">1</span>][p] + <span class="built_in">map</span>[k][p] + <span class="built_in">map</span>[i][j]);</span><br><span class="line">                    dp[i][j][k][p] = max(dp[i][j][k][p], dp[i - <span class="number">1</span>][j][k][p - <span class="number">1</span>] + <span class="built_in">map</span>[k][p] + <span class="built_in">map</span>[i][j]);</span><br><span class="line">                    dp[i][j][k][p] = max(dp[i][j][k][p], dp[i][j - <span class="number">1</span>][k - <span class="number">1</span>][p] + <span class="built_in">map</span>[k][p] + <span class="built_in">map</span>[i][j]);</span><br><span class="line">                    dp[i][j][k][p] = max(dp[i][j][k][p], dp[i][j - <span class="number">1</span>][k][p - <span class="number">1</span>] + <span class="built_in">map</span>[k][p] + <span class="built_in">map</span>[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, dp[m][n - <span class="number">1</span>][m - <span class="number">1</span>][n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里是四维，但是仔细想一下，从左上角到右下角，因为两人路径互不干扰，因此可以假设两人同时进行，步数一样</p>
<p>那么可以得到方程	<code>i+j=p+q</code>,因此只需要枚举三个坐标i，j，k即可得到第四个坐标q（q从j+1开始），降低阶数到3阶；</p>
<h3 id="背包问题">背包问题</h3>
<h4 id="01背包">01背包</h4>
<p>​	有n件物品，每一件物品有对应的价值value和重量weight，有背包最大容量max，如何选取物品，在不超过背包容量的情况下取得最大的总价值</p>
<p>​	分析：我们可以定义<code>dp[i][j]</code>为考虑前i件物品，背包容量为j，能装下的最大价值</p>
<p>​	在前i-1件物品考虑完的情况下，我们考虑第i件物品，对应的<code>value[i]和weight[i]</code>,</p>
<ul>
<li>如果背包此时的<code>j&lt;weight[i]</code>，那么无法装下第i件物品，那么考虑前i件物品和考虑前i-1件物品的价值是一样的，状态转移方程为：</li>
</ul>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dp[i][j]=dp[i-1][j]
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span></span></p>
<ul>
<li>如果背包装得下，也就是<code>j&gt;weight[i]</code>，那么此时有两种取向，装第i件商品和不装第i件商品，取两者的最大值，状态转移方程为：</li>
</ul>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mi>w</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">]</mo><mo>+</mo><mi>v</mi><mi>a</mi><mi>l</mi><mi>u</mi><mi>e</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">dp[i][j]=max(dp[i][j],dp[i-1][j-weight[i]]+value[i])
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal">e</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">h</span><span class="mord mathnormal">t</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">u</span><span class="mord mathnormal">e</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">])</span></span></span></span></span></p>
<p>因此代码如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> max_num 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> max_weight 200</span></span><br><span class="line"><span class="type">int</span> weight[<span class="number">202</span>], value[<span class="number">202</span>];</span><br><span class="line"><span class="type">int</span> dp[max_num][max_weight];<span class="comment">//dp[i][j]表示考虑前i件商品，有j的容量能取到的最大价值 </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> n, m;<span class="comment">//m就是定义的最大容量 </span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;weight[i], &amp;value[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &lt; weight[i])dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = max(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - weight[i]] + value[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, dp[n][m]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>优化：滚动数组（后面有时间再写详细优化解释）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> dp[max_weight];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = m; j &gt;= weight[i]; j--) &#123;</span><br><span class="line">		dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="多重背包">多重背包</h4>
<p>​	对于n件商品，每一件对应有价值value和weight，每一件商品有num件，对于容量为max的背包，如何选取商品获得最大价值</p>
<p>​	分析：将每一件商品的num件都进行拆解，转换成数据量更大的01背包问题，问题在于，数据量更大可能超时，因此需要进行优化</p>
<p>​	考虑这样一个问题，对于一种商品的num件，我们可以选取任意件，但是有没有更好的方法表示这任意件商品呢？</p>
<p>​	这里我们讨论关于<strong>二进制优化</strong>，给你一个数字k，你可以将其表示成为</p>
<p>​    <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>=</mo><mn>1</mn><mo>+</mo><mn>2</mn><mo>+</mo><mn>4</mn><mo>+</mo><mn>8</mn><mo>+</mo><mn>16</mn><mo>+</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>+</mo><msup><mn>2</mn><mi>m</mi></msup><mo>+</mo><mi>t</mi></mrow><annotation encoding="application/x-tex">k=1+2+4+8+16+......+2^m+t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">8</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">16</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord">......</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7477em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">t</span></span></span></span>;这里的m取最大值，然后剩余一个数字t，举个例子：</p>
<ul>
<li>27=1+2+4+8+12；</li>
<li>49=1+2+4+8+16+17；</li>
<li>235=1+2+4+8+16+32+64+108；</li>
</ul>
<p>这样有什么用呢？		对于数字27，原来数字15=1*15（需要15个1来表示15），现在可以<strong>压缩</strong>成15=1+2+12；	11=1+2+8；</p>
<p>也就是对于数字的分解<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>=</mo><mn>1</mn><mo>+</mo><mn>2</mn><mo>+</mo><mn>4</mn><mo>+</mo><mn>8</mn><mo>+</mo><mn>16</mn><mo>+</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>+</mo><msup><mn>2</mn><mi>m</mi></msup><mo>+</mo><mi>t</mi></mrow><annotation encoding="application/x-tex">k=1+2+4+8+16+......+2^m+t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">8</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">16</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord">......</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7477em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">t</span></span></span></span>，对于任意小于等于k的数字q，q可以用k的分解数字组合而成，从而进行<strong>压缩</strong></p>
<p>这样我们也可以对num件同样的物品进行<strong>二进制压缩</strong>，把每个压缩的数字作为一个整体的新的物品</p>
<p>代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> max_num 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> max_weight 200</span></span><br><span class="line"><span class="type">int</span> weight[<span class="number">202</span>], value[<span class="number">202</span>];</span><br><span class="line"><span class="type">int</span> dp[max_num][max_weight];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="type">int</span> v, w, num;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;v, &amp;w, &amp;num);</span><br><span class="line">        <span class="comment">//对num进行2进制拆解，1，2，4，8，16 .........以及一个无法继续取到的余数</span></span><br><span class="line">        <span class="type">int</span> k = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (k &lt;= num) &#123;</span><br><span class="line">            value[cnt] = v * k;</span><br><span class="line">            weight[cnt++] = w * k;</span><br><span class="line">            num -= k;</span><br><span class="line">            k &lt;&lt;= <span class="number">1</span>;<span class="comment">//k乘以2</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            value[cnt] = v * num;</span><br><span class="line">            weight[cnt++] = w * num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">//那么就是前cnt件商品</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= cnt - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &lt; weight[i])dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = max(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - weight[i]] + value[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, dp[cnt][m]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="分组背包">分组背包</h4>
<p>一共有m组物品，每一组物品对应有s[i]个，对应每个物体有value和weight；背包容量为max，每一组物品中最多只能选择一个，如何选取获得最大的价值</p>
<p>分析：与01背包的差别在于，每一组的个数更多了，因此原来的考虑第i个物品，变成了考虑第i组物品</p>
<p>我们依然定义<code>dp[i][j]</code>为前i组物品，j容量对应的最大价值。</p>
<p>我们来考虑第i组物品，一共有s[i]个，假设不取i组的物品</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo separator="true">;</mo></mrow><annotation encoding="application/x-tex">dp[i][j]=dp[i-1][j];
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mpunct">;</span></span></span></span></span></p>
<p>然后再依次考虑第i组所有物品对应的情况，遍历该组的每一个物品，考虑其取与不取对应的最大价值</p>
<p>当然需要前提判断，当前容量j能够放下我们考虑的物品，<code>if(j&gt;=s[i][k])</code>,第i组的第k个物品</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mi>w</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo><mo stretchy="false">]</mo><mo>+</mo><mi>v</mi><mi>a</mi><mi>l</mi><mi>u</mi><mi>e</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">dp[i][j]=max(dp[i][j],dp[i-1][j-weight[i][k]]+value[i][k])
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal">e</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">h</span><span class="mord mathnormal">t</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">]]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">u</span><span class="mord mathnormal">e</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">])</span></span></span></span></span></p>
<p>因此代码如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> max_num 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> max_weight 200</span></span><br><span class="line"><span class="type">int</span> weight[<span class="number">100</span>][max_weight], value[<span class="number">100</span>][max_num];</span><br><span class="line"><span class="type">int</span> s[<span class="number">100</span>];<span class="comment">//表示每一组有多少个物品</span></span><br><span class="line"><span class="type">int</span> dp[<span class="number">100</span>][max_weight];<span class="comment">//前i组，最大价值 </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;s[i]);<span class="comment">//有很多个组，每个组最多只能选择一个物品 </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= s[i]; j++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;value[i][j], &amp;weight[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            dp[i][j] = dp[i - <span class="number">1</span>][j];<span class="comment">//不选第i组，从前i-1组里面选择</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= s[i]; k++) &#123;<span class="comment">//遍历第i组的所有物品 </span></span><br><span class="line">                <span class="keyword">if</span> (j &gt;= weight[i][k])</span><br><span class="line">                    dp[i][j] = max(dp[i][j], dp[i - <span class="number">1</span>][j - weight[i][k]] + value[i][k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, dp[n][m]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="完全背包">完全背包</h4>
<p>一共有n种物品，每个物品有无限个，对应有value和weight，背包容量为max，求解取到的最大价值</p>
<p>分析：如果我们把每一种物品的无限数量进行拆分，依然是01背包问题，或者是多重背包问题（只是这里无上限，不好进行优化），我们只需要在01背包基础上枚举每一种物品取的数量k即可，代码如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> max_num 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> max_weight 200</span></span><br><span class="line"><span class="type">int</span> weight[<span class="number">202</span>], value[<span class="number">202</span>];</span><br><span class="line"><span class="type">int</span> dp[<span class="number">100</span>][<span class="number">200</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这里看作01背包</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= max_weight; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k * weight[i] &lt;= j; k++) &#123;</span><br><span class="line">                dp[i][j] = max(dp[i][j], dp[i - <span class="number">1</span>][j - k * weight[i]] + k * value[i]);</span><br><span class="line">            &#125;<span class="comment">//去遍历对于每件商品的所有取值情况，取最大的价值的情况作为结果</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来我们仔细分析这段代码，显然发现</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mi>k</mi><mo>∗</mo><mi>w</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">]</mo><mo>+</mo><mi>k</mi><mo>∗</mo><mi>v</mi><mi>a</mi><mi>l</mi><mi>u</mi><mi>e</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi>k</mi><mo>=</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>3</mn><mo separator="true">,</mo><mn>4</mn></mrow><annotation encoding="application/x-tex">dp[i][j]=max(dp[i-1][j],dp[i-1][j-k*weight[i]]+k*value[i])... k=1,2,3,4
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal">e</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">h</span><span class="mord mathnormal">t</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">u</span><span class="mord mathnormal">e</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">])</span><span class="mord">...</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">4</span></span></span></span></span></p>
<p>我们将j替换成<code>j-weight[i]</code>有</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mi>w</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">]</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mi>w</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mi>k</mi><mo>∗</mo><mi>w</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">]</mo><mo>+</mo><mi>k</mi><mo>∗</mo><mi>v</mi><mi>a</mi><mi>l</mi><mi>u</mi><mi>e</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi>k</mi><mo>=</mo><mn>2</mn><mo separator="true">,</mo><mn>3</mn><mo separator="true">,</mo><mn>4</mn><mo separator="true">,</mo><mn>5</mn><mo separator="true">,</mo><mn>6</mn></mrow><annotation encoding="application/x-tex">dp[i][j-weight[i]]=max(dp[i-1][j-weight[i]],dp[i-1][j-k*weight[i]]+k*value[i])...k=2,3,4,5,6
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal">e</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">h</span><span class="mord mathnormal">t</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal">e</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">h</span><span class="mord mathnormal">t</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal">e</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">h</span><span class="mord mathnormal">t</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">u</span><span class="mord mathnormal">e</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">])</span><span class="mord">...</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">6</span></span></span></span></span></p>
<p>观察两个式子，我们发现两个式子可以把k给抵消掉（采用<strong>递归</strong>的形式消去k）（递归的过程是j从小到大递归，因此在代码的循环部分j也要从小到大），两个式子整合为下面式子 <strong>（读者可以自己多列举几个k的数值去理解这里是如何整合的）</strong></p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mi>w</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">]</mo><mo>+</mo><mi>v</mi><mi>a</mi><mi>l</mi><mi>u</mi><mi>e</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">dp[i][j]=max(dp[i-1][j],dp[i][j-weight[i]]+value[i])
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal">e</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">h</span><span class="mord mathnormal">t</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">u</span><span class="mord mathnormal">e</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">])</span></span></span></span></span></p>
<p>因此代码在时间复杂度上可以优化成这样（三维到二维）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> max_weight 200</span></span><br><span class="line"><span class="type">int</span> weight[<span class="number">202</span>], value[<span class="number">202</span>];</span><br><span class="line"><span class="type">int</span> dp[<span class="number">100</span>][<span class="number">200</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &lt; weight[i])dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = max(dp[i - <span class="number">1</span>][j], dp[i][j - weight[i]] + value[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, dp[n][m]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="背包问题总结">背包问题总结</h4>
<p>四种背包问题在本质上都可以解释为01背包问题，简单的二维dp，只是附加了不同的条件，需要对应不同的方法去<strong>优化加强版的01背包</strong>，这些优化都是基于时间上的优化，但是背包问题普遍都可以使用<strong>滚动数组优化空间</strong>到一维。滚动数组优化以及各种背包问题的循环嵌套顺序，遍历顺序（从小到大或者是从大到小），可以自己尝试画出二维的递归表格，通过填涂表格的形式更好的理解嵌套和遍历顺序。</p>
<p>当然，嵌套和遍历顺序我们也可以通过状态转移方程推出，背包问题属于最基础形式的动态规划问题。</p>
]]></content>
      <tags>
        <tag>c语言</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>算法-分治</title>
    <url>/2023/06/25/%E7%AE%97%E6%B3%95-%E5%88%86%E6%B2%BB/</url>
    <content><![CDATA[<span id="more"></span>
<h2 id="从二路归并引入">从二路归并引入</h2>
<p>杠铃增重问题介绍归并排序</p>
<p><img src="https://soybeanlittlecar.oss-cn-beijing.aliyuncs.com/blog/%E7%AE%97%E6%B3%95-%E5%88%86%E6%B2%BB/00001.png" alt=""></p>
<p><img src="https://soybeanlittlecar.oss-cn-beijing.aliyuncs.com/blog/%E7%AE%97%E6%B3%95-%E5%88%86%E6%B2%BB/00002.png" alt=""></p>
<p><img src="https://soybeanlittlecar.oss-cn-beijing.aliyuncs.com/blog/%E7%AE%97%E6%B3%95-%E5%88%86%E6%B2%BB/00003.png" alt=""></p>
<p><img src="https://soybeanlittlecar.oss-cn-beijing.aliyuncs.com/blog/%E7%AE%97%E6%B3%95-%E5%88%86%E6%B2%BB/00004.png" alt=""></p>
<p><img src="https://soybeanlittlecar.oss-cn-beijing.aliyuncs.com/blog/%E7%AE%97%E6%B3%95-%E5%88%86%E6%B2%BB/00005.png" alt=""></p>
<p>归并排序利用分治思想，将整体数组先进行两两拆分，每次取中点作为分割点，最终每个个体数组只有一个元素形成了局部有序</p>
<p>局部解依次合并形成全局解，将大问题拆分成为小问题，解决小问题，再将小问题的答案合并形成大问题的答案</p>
<p>以下是C语言代码示例</p>
<p>递归</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> _MergeSort(<span class="type">int</span>* a, <span class="type">int</span>* tmp, <span class="type">int</span> begin, <span class="type">int</span> end) &#123;</span><br><span class="line">	<span class="keyword">if</span> (begin &gt;= end)</span><br><span class="line">		<span class="keyword">return</span>;<span class="comment">//单个或者不存在其区间就结束递归</span></span><br><span class="line">	<span class="comment">//类似于后序：</span></span><br><span class="line">	<span class="type">int</span> middle = (begin + end) / <span class="number">2</span>;</span><br><span class="line">	<span class="type">int</span> begin1 = begin;</span><br><span class="line">	<span class="type">int</span> end1 = middle;</span><br><span class="line">	<span class="type">int</span> begin2 = middle + <span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> end2 = end;</span><br><span class="line">	_MergeSort(a, tmp, begin1, end1);</span><br><span class="line">	_MergeSort(a, tmp, begin2, end2);</span><br><span class="line">	<span class="comment">//此时认为 [begin1, end1] 和 [begin2, end2]两段区间上有序</span></span><br><span class="line">	<span class="comment">//归并算法</span></span><br><span class="line">	<span class="type">int</span> i = begin;</span><br><span class="line">	<span class="keyword">while</span> (begin1 &lt;= end1 &amp;&amp; begin2 &lt;= end2) &#123;</span><br><span class="line">		<span class="keyword">if</span> (a[begin1] &lt;= a[begin2]) &#123;</span><br><span class="line">			tmp[i++] = a[begin1++];</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			tmp[i++] = a[begin2++];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (begin1 &lt;= end1) &#123;</span><br><span class="line">		tmp[i++] = a[begin1++];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (begin2 &lt;= end2) &#123;</span><br><span class="line">		tmp[i++] = a[begin2++];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">memcpy</span>(a + begin, tmp + begin, <span class="keyword">sizeof</span>(<span class="type">int</span>) * (end - begin + <span class="number">1</span>));<span class="comment">//内存操作函数，可以将整个数组的数复制过去</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//归并排序 递归版本</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MergeSort</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">	<span class="type">int</span>* tmp = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * n);<span class="comment">//首先malloc一个数组</span></span><br><span class="line">	<span class="keyword">if</span> (tmp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;未能申请到内存\n&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//第一次传入 0 和 n - 1 传入闭区间</span></span><br><span class="line">	_MergeSort(a, tmp, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">free</span>(tmp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>非递归</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">MergeSortNonR</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">	<span class="type">int</span>* tmp = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * n);</span><br><span class="line">	<span class="keyword">if</span> (tmp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;申请空间失败\n&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> gap = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (gap &lt; n) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i += <span class="number">2</span> * gap) &#123; <span class="comment">//每次跨越两组</span></span><br><span class="line">			<span class="type">int</span> begin1 = i, end1 = i + gap - <span class="number">1</span>;</span><br><span class="line">			<span class="type">int</span> begin2 = i + gap, end2 = i + <span class="number">2</span> * gap - <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span> (end1 &gt;= n || begin2 &gt;= n) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (end2 &gt;= n) &#123;</span><br><span class="line">				end2 = n - <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//归并</span></span><br><span class="line">			<span class="type">int</span> j = begin1;</span><br><span class="line">			<span class="type">int</span> m = end2 - begin1 + <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">while</span> (begin1 &lt;= end1 &amp;&amp; begin2 &lt;= end2) &#123;</span><br><span class="line">				<span class="keyword">if</span> (a[begin1] &lt;= a[begin2]) &#123;</span><br><span class="line">					tmp[j++] = a[begin1++];</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					tmp[j++] = a[begin2++];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">while</span> (begin1 &lt;= end1) &#123;</span><br><span class="line">				tmp[j++] = a[begin1++];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">while</span> (begin2 &lt;= end2) &#123;</span><br><span class="line">				tmp[j++] = a[begin2++];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">memcpy</span>(a + i, tmp + i, <span class="keyword">sizeof</span>(<span class="type">int</span>) * m);<span class="comment">//局部复制，end2 - begin1 + 1</span></span><br><span class="line">		&#125;</span><br><span class="line">		gap *= <span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">free</span>(tmp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>课件版本/自己熟悉写的</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span> x[], <span class="type">int</span> tmp[], <span class="type">int</span> left, <span class="type">int</span> leftend, <span class="type">int</span> rightend, <span class="type">int</span> *num)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; leftend) &#123;</span><br><span class="line">        merge(x, tmp, left, (left + leftend) / <span class="number">2</span>, leftend, num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (leftend + <span class="number">1</span> &lt; rightend) &#123;</span><br><span class="line">        merge(x, tmp, leftend + <span class="number">1</span>, (leftend + <span class="number">1</span> + rightend) / <span class="number">2</span>, rightend, num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> i = left, j = leftend + <span class="number">1</span>, q = left;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= leftend &amp;&amp; j &lt;= rightend) &#123;</span><br><span class="line">        (*num)++;</span><br><span class="line">        <span class="keyword">if</span> (x[i] &lt;= x[j])</span><br><span class="line">            tmp[q++] = x[i++];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            tmp[q++] = x[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= leftend)</span><br><span class="line">        tmp[q++] = x[i++];</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= rightend)</span><br><span class="line">        tmp[q++] = x[j++];</span><br><span class="line">    <span class="keyword">for</span> (i = left; i &lt;= rightend; i++)</span><br><span class="line">        x[i] = tmp[i];</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h2 id="最大子数组问题">最大子数组问题</h2>
<p><a href="https://www.luogu.com.cn/problem/P1115">P1115 最大子段和 - 洛谷</a></p>
<p>对于一个数组，找出一段连续的子数组，使得子数组中所有数字的和最大</p>
<p>首先我们考虑简单的枚举法，枚举所有子数组的左侧边界和右侧边界，算法的时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>3</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，外层循环枚举左侧边界，内层循环枚举右侧边界，最内层加和区间所有数值</p>
<p>然后我们考虑第一层优化，对于每次加和的数组，对于已经加和过的区间，我们可以将其存起来，这样我们可以有</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mo stretchy="false">[</mo><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo stretchy="false">]</mo><mo>=</mo><mi>n</mi><mi>u</mi><mi>m</mi><mo stretchy="false">[</mo><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo>+</mo><mi>s</mi><mo stretchy="false">[</mo><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">num[left][right]=num[left][right-1]+s[right]
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">t</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">h</span><span class="mord mathnormal">t</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">t</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">h</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">h</span><span class="mord mathnormal">t</span><span class="mclose">]</span></span></span></span></span></p>
<p>每次得到的区间和优化为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>时间，最终算法优化为枚举左右断点，也就是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p>
<p>接着我们考虑分治法，根据分治法的流程，首先分解成子问题，然后求解子问题的解，最终合并子问题的解作为原问题的解</p>
<p><img src="https://soybeanlittlecar.oss-cn-beijing.aliyuncs.com/blog/%E7%AE%97%E6%B3%95-%E5%88%86%E6%B2%BB/00006.png" alt=""></p>
<p>我们可以求解出子数组的解<code>S1</code>和<code>S2</code>，这两可能是最后的解，还有一种可能就是跨越两个数组分解位置的解<code>S3</code>，这里我们可以通过分治思想递归求出子数组的解，问题在于如何求解跨越分界点的解，这里采用枚举法，从分界点往两侧进行枚举，寻找最大的值，算法时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">CrossingSubArray</span><span class="params">(<span class="type">int</span> X[], <span class="type">int</span> low, <span class="type">int</span> mid, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">    <span class="type">int</span> max = -INFINITY;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = mid; i &gt;= low; i--) &#123;</span><br><span class="line">        left += X[i];</span><br><span class="line">        <span class="keyword">if</span> (max &lt; left)max = left;</span><br><span class="line">    &#125;</span><br><span class="line">    left = max;</span><br><span class="line">    max = -INFINITY;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = mid + <span class="number">1</span>; i &lt;= high; i++) &#123;</span><br><span class="line">        right += X[i];</span><br><span class="line">        <span class="keyword">if</span> (max &lt; right)max = right;</span><br><span class="line">    &#125;</span><br><span class="line">    right = max;</span><br><span class="line">    <span class="keyword">return</span> left + right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后合并三个可能的解</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">MaxSubArray</span><span class="params">(<span class="type">int</span> X[], <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (low == high) &#123;</span><br><span class="line">        <span class="keyword">return</span> X[low];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">int</span> max = -INFINITY;</span><br><span class="line">        <span class="type">int</span> mid = (low + high) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> s1 = MaxSubArray(X, low, mid);</span><br><span class="line">        <span class="keyword">if</span> (s1 &gt; max)max = s1;</span><br><span class="line">        <span class="type">int</span> s2 = MaxSubArray(X, mid + <span class="number">1</span>, high);</span><br><span class="line">        <span class="keyword">if</span> (s2 &gt; max)max = s2;</span><br><span class="line">        <span class="type">int</span> s3 = CrossingSubArray(X, low, mid, high);</span><br><span class="line">        <span class="keyword">if</span> (s3 &gt; max)max = s3;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="逆序对计数问题">逆序对计数问题</h2>
<p><a href="https://www.luogu.com.cn/problem/P1908">P1908 逆序对 - 洛谷</a></p>
<p>逆序对指的是一个序列中，第一个数字的序号比第二个数字小，但是第一个数字大于第二个数字，即<code>a[i] &gt; a[j] &amp;&amp; i &lt; j</code></p>
<p>求解一个数组中的逆序对数</p>
<p>首先考虑枚举，对于每一个数字，我们枚举它后面的所有数字，查看是否构成逆序对，时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p>
<p>接着考虑分治法，将大数组按中点拆分成两个子数组，对于子数组自身的逆序对数量，我们很容易通过递归可以求解，对于两个子数组之间的逆序对数量，我们需要考虑如何求解</p>
<p><img src="https://soybeanlittlecar.oss-cn-beijing.aliyuncs.com/blog/%E7%AE%97%E6%B3%95-%E5%88%86%E6%B2%BB/00007.png" alt=""></p>
<p>首先考虑枚举，对于每一个属于第一个子数组中的数字，我们在第二个子数组中枚举每一个数字，找到比它小的构成逆序对，这样最终整体的时间复杂度仍然为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，并没有起到分治优化的效果</p>
<p>由于我们是需要在一个序列中找到比它大的，我们可以对其中一个子数组进行排序，然后利用二分查找快速确定位置，我们对两个子数组都进行排序，然后对于每一个数字属于第一个子数组，我们利用二分查找找出比其小的分界点</p>
<p><img src="https://soybeanlittlecar.oss-cn-beijing.aliyuncs.com/blog/%E7%AE%97%E6%B3%95-%E5%88%86%E6%B2%BB/00008.png" alt=""></p>
<p>排序的时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，计算可逆序对的时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mfrac><mi>n</mi><mn>2</mn></mfrac><mi>l</mi><mi>o</mi><mi>g</mi><mfrac><mi>n</mi><mn>2</mn></mfrac><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O({\frac{n}{2}}log{\frac{n}{2}})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.095em;vertical-align:-0.345em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6954em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6954em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span><span class="mclose">)</span></span></span></span>，最终整体算法时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><msup><mrow><mi>l</mi><mi>o</mi><mi>g</mi></mrow><mn>2</mn></msup><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n{log}^2n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1484em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8984em;"><span style="top:-3.1473em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p>
<p>我们接着考虑优化，对于上述排序与二分查找，我们可以联想到归并排序，归并排序的合并过程其实就是一个给出可逆序对的过程，每个元素合并到数组内时就有确定的数量的数字可以构成它的可逆序对</p>
<p><img src="https://soybeanlittlecar.oss-cn-beijing.aliyuncs.com/blog/%E7%AE%97%E6%B3%95-%E5%88%86%E6%B2%BB/00009.png" alt=""></p>
<p>归并的过程可以统计逆序对数量，因此只需要在归并排序的代码基础之上进行简单的修改，对于合并过程，每次右侧数组有数字进入总数组时，统计此时<code>i</code>指针的位置，这样相比于上一种排序和二分，利用归并排序，合并的时间复杂度优化至<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，总复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">MergeCount</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> left, <span class="type">int</span> mid, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="type">int</span> tmp_A[<span class="number">10005</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = left; i &lt;= right; i++) &#123;</span><br><span class="line">        tmp_A[i] = A[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> i = left, j = mid + <span class="number">1</span>, k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tmp_A[i] &lt;= tmp_A[j]) &#123;</span><br><span class="line">            A[k + left] = tmp_A[i++];</span><br><span class="line">            k++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            A[k + left] = tmp_A[j++];</span><br><span class="line">            k++;</span><br><span class="line">            cnt += mid + <span class="number">1</span> - i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid) &#123;</span><br><span class="line">        A[k + left] = tmp_A[i++];</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= right) &#123;</span><br><span class="line">        A[k + left] = tmp_A[j++];</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//合并问题解</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">CountInver</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        cnt += CountInver(A, left, mid);</span><br><span class="line">        cnt += CountInver(A, mid + <span class="number">1</span>, right);</span><br><span class="line">        cnt += MergeCount(A, left, mid, right);</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>分治</category>
      </categories>
      <tags>
        <tag>分治</tag>
      </tags>
  </entry>
  <entry>
    <title>表达式树</title>
    <url>/2023/04/20/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%A0%91/</url>
    <content><![CDATA[<p>表达式树可以用于表达式的计算，形式为一颗二叉树，非常形象，下面我们通过前中后缀表达式的详细规则构建表达式树</p>
<span id="more"></span>
<p><strong>Ps: 以下代码只是经过简单的数据测试（目前来看没什么问题），如果出现数据计算错误，请联系作者</strong></p>
<p>针对以下前中后缀表达式的输入情况说明：</p>
<ol>
<li>输入数据仅仅支持<code>+ , -, *, /</code>四种运算，如果有其它运算要求，例如幂<code>^</code>、<code>%</code>运算，可以自行上网搜寻文章，对运算进行扩充，也可以参照作者文章<code>c语言模板/多位数计算器</code>进行计算符号扩充的理解</li>
<li>输入的三种表达式中，除了中缀表达式有括号在其中（不会产生任何数字的歧义），但是对于前缀和后缀表达式，不同数字之间需要添加空格，这里的数字指的是一个完整的数字，在后缀表达式<code>123 54 +</code>中，比如<code>123</code>和<code>54</code>区分，<code>123</code>和<code>54</code>分别作为一个完整的数字存在，因此需要区分，至于其它情况，数字和操作符之间，操作符和操作符之间，可以不添加空格，但是为了结构的一致性，建议添加空格</li>
<li>计算仅仅支持<code>int</code>范围内的计算，并且对于<code>/</code>运算，采取的是向下取整，如果对于计算的方式有不同需求的，可以自行修改</li>
</ol>
<p>构建表达式树之前，我们定义一个结点栈，用来存储表达式树构建过程中的元素，栈内每一个元素的本质是一颗子树。</p>
<p>同时给出表达式树构建之前所需的一些自定义函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 1005</span></span><br><span class="line"><span class="keyword">typedef</span> ElemType <span class="type">int</span>;<span class="comment">//这里根据单位数字或者是多位数字，自行选择类型，int 或 char</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    ElemType elem;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">left</span>, *<span class="title">right</span>;</span></span><br><span class="line">&#125; Node, *Nodeprt;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">stack</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> top;</span><br><span class="line">    Nodeprt data[MAXSIZE];</span><br><span class="line">&#125; Stack;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">(Stack *s)</span> &#123;<span class="comment">//初始化栈</span></span><br><span class="line">    s-&gt;top = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">empty</span><span class="params">(Stack *s)</span> &#123;<span class="comment">//判断栈空</span></span><br><span class="line">    <span class="keyword">return</span> s-&gt;top == <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">full</span><span class="params">(Stack *s)</span> &#123;<span class="comment">//判断栈满</span></span><br><span class="line">    <span class="keyword">return</span> s-&gt;top == MAXSIZE - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">push</span><span class="params">(Stack *s, Nodeprt item)</span> &#123;<span class="comment">//元素入栈</span></span><br><span class="line">    <span class="keyword">if</span> (full(s)) <span class="keyword">return</span>;</span><br><span class="line">    s-&gt;data[++s-&gt;top] = item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Nodeprt <span class="title function_">pop</span><span class="params">(Stack *s)</span> &#123;<span class="comment">//弹出栈顶元素</span></span><br><span class="line">    <span class="keyword">if</span> (empty(s)) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> s-&gt;data[s-&gt;top--];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ElemType <span class="title function_">get_top_data</span><span class="params">(Stack *s)</span> &#123;<span class="comment">//获取栈顶元素，只是获取，不是弹出</span></span><br><span class="line">    <span class="keyword">return</span> s-&gt;data[s-&gt;top]-&gt;elem;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Nodeprt <span class="title function_">build_node</span><span class="params">(ElemType Data)</span> &#123;<span class="comment">//单个数字的表达式树，可以用char 进行统一</span></span><br><span class="line">    Nodeprt p = (Nodeprt) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    p-&gt;elem = Data;</span><br><span class="line">    p-&gt;left = p-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Nodeprt <span class="title function_">build_node</span><span class="params">(ElemType Data, <span class="type">int</span> flag)</span> &#123;<span class="comment">//因为树的结点的统一性，我们选择将data统一为int，用负数表示对应的操作符</span></span><br><span class="line">    Nodeprt p = (Nodeprt) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    <span class="keyword">if</span> (flag)Data = -Data;</span><br><span class="line">    p-&gt;elem = Data;</span><br><span class="line">    p-&gt;left = p-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">priority</span><span class="params">(<span class="type">char</span> ch)</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (ch) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//符号优先级定义，在中缀转表达式树，中缀转后缀会用到，根据其它的一些数学运算，可以适当扩充</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">cal_operator_tree</span><span class="params">(Nodeprt root)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;elem&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">switch</span>(-root-&gt;elem)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:<span class="keyword">return</span> cal_operator_tree(root-&gt;left)+ cal_operator_tree(root-&gt;right);</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:<span class="keyword">return</span> cal_operator_tree(root-&gt;left)- cal_operator_tree(root-&gt;right);</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:<span class="keyword">return</span> cal_operator_tree(root-&gt;left)* cal_operator_tree(root-&gt;right);</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:<span class="keyword">return</span> cal_operator_tree(root-&gt;left)/ cal_operator_tree(root-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> root-&gt;elem;</span><br><span class="line">&#125;<span class="comment">//递归计算左右子树的数值</span></span><br></pre></td></tr></table></figure>
<h2 id="中缀表达式">中缀表达式</h2>
<p>表达式树构建规则：先将中缀表达式按照计算优先级套上一层一层括号，然后按照以下几条规则从左往右遍历中缀表达式</p>
<ol>
<li>如果某个字符是<strong>数字</strong>，那么直接进入结点栈;（这里如果是多位数字，请自行处理形成一个完整的数字，比如字符串&quot;123&quot;变成123；</li>
<li>如果某个字符是’('，直接进入符号栈；</li>
<li>如果某个字符是’)‘，依次退出符号栈的操作符，直至遇到’('，对于每个弹出的操作符，都要和数字栈中弹出的两个结点进行结合形成新的结点，并且作为新的结点进入结点栈；</li>
<li>如果某个字符是<strong>操作符</strong>，从符号栈中依次弹出比当前<strong>操作符</strong>优先级高的字符（同样，对于每个弹出的字符，都要进行与结点栈的结合操作），然后再将<strong>当前操作符</strong>入符号栈;</li>
<li>最后遍历完中缀表达式之后，如果符号栈非空，那就依次弹出符号栈内的操作符，对于每个操作符都要与结点栈内弹出的两个结点进行结合，然后形成新的结点再进入结点栈，最终结点栈内的唯一结点就是<strong>表达式树的根</strong></li>
<li>对于每个操作符和结点结合的顺序说明，从结点栈内弹出的<strong>第一个</strong>结点作为<strong>右</strong>儿子，<strong>第二个</strong>弹出的结点作为<strong>左</strong>儿子。</li>
</ol>
<p>代码如下（均为函数封装形式）（下方代码仅仅针对单位数字，例如<code>0,1,2,3,4,5,6,7,8,9</code>）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Nodeprt <span class="title function_">build_operator_tree</span><span class="params">(<span class="type">char</span> *s)</span> &#123;</span><br><span class="line">    Stack *stack_node=(Stack*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Stack));</span><br><span class="line">    Stack *stack_operator=(Stack*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Stack));</span><br><span class="line">    init(stack_node);</span><br><span class="line">    init(stack_operator);</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">&#x27; &#x27;</span>)<span class="keyword">continue</span>;<span class="comment">//空格直接跳过</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">isdigit</span>(s[i])) &#123;<span class="comment">//是数字</span></span><br><span class="line">             Nodeprt tmp = build_node(s[i], <span class="number">0</span>);</span><br><span class="line">                push(stack_node, tmp);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//其它所有情况作为与数字的一个区分</span></span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                Nodeprt tmp = build_node(<span class="string">&#x27;(&#x27;</span>, <span class="number">1</span>);</span><br><span class="line">                push(stack_operator, tmp);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> (!empty(stack_operator) &amp;&amp; get_top_data(stack_operator) != <span class="string">&#x27;(&#x27;</span>) &#123;<span class="comment">//栈非空，直到&#x27;(&#x27;</span></span><br><span class="line">                    Nodeprt p = pop(stack_operator);</span><br><span class="line">                    p-&gt;right = pop(stack_node);</span><br><span class="line">                    p-&gt;left = pop(stack_node);</span><br><span class="line">                    push(stack_node, p);</span><br><span class="line">                &#125;</span><br><span class="line">                pop(stack_operator);<span class="comment">//把左括号弹出来</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;+&#x27;</span> || s[i] == <span class="string">&#x27;-&#x27;</span> || s[i] == <span class="string">&#x27;*&#x27;</span> || s[i] == <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> (!empty(stack_operator) &amp;&amp; priority((get_top_data(stack_operator))) &gt;= priority(s[i])) &#123;</span><br><span class="line">                    Nodeprt p = pop(stack_operator);</span><br><span class="line">                    p-&gt;right = pop(stack_node);</span><br><span class="line">                    p-&gt;left = pop(stack_node);</span><br><span class="line">                    push(stack_node, p);</span><br><span class="line">                &#125;</span><br><span class="line">                Nodeprt p = build_node(s[i], <span class="number">1</span>);</span><br><span class="line">                push(stack_operator, p);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!empty(stack_operator)) &#123;</span><br><span class="line">        Nodeprt p = pop(stack_operator);</span><br><span class="line">        p-&gt;right = pop(stack_node);</span><br><span class="line">        p-&gt;left = pop(stack_node);</span><br><span class="line">        push(stack_node, p);</span><br><span class="line">    &#125;</span><br><span class="line">    Nodeprt root = stack_node-&gt;data[stack_node-&gt;top];</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> s[MAXSIZE];</span><br><span class="line">    gets(s);</span><br><span class="line">    Nodeprt root= build_operator_tree(s);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果需要计算多位数字数字，我们需要对数字读入部分进行修改，仔细分析一下，我们会发现，每个结点的结构体定义的符号类型是<code>char</code>，但是对于多位数字，我们假定为<code>int</code>类型，无法存储在<code>char</code>里面，接下来讨论两种储存方式。</p>
<ol>
<li>我们可以定义</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">left</span>,*<span class="title">right</span>;</span></span><br><span class="line">&#125;Node,*Nodeprt;</span><br></pre></td></tr></table></figure>
<p>​	在结构体内同时使用<code>char ,int</code>，由于区分了符号栈和结点栈，我们可以很方便的读取完整的数字，区分数字和操作符（结点的构造稍微有一点不同），同时在表达式树构建完成之后，所有的数字都是叶结点，其它的是操作符结点，容易区分，只需在遍历过程中加一个小判断（是否为叶结点）即可；</p>
<ol start="2">
<li>
<p>同时定义<code>char ,int</code>有些浪费空间，我们来考虑一下一个合法的中缀表达式的规则</p>
<ul>
<li>不能存在负数，所有负数<code>x</code>都可以转换成<code>0 - (-x)</code>的形式，从而转换成非负数。</li>
<li><code>int</code>存储范围包括负数，但是我们只需要利用非负数，因此负数区间是空闲的</li>
<li>所有操作符的<strong>Ascll</strong>码独立，不会重复；</li>
</ul>
<p>基于这几点规则，我们可以用负数存储操作符，对于某个操作符<code>ch</code>,我们定义它在结点中存储的数值为<code>0 - ascll(ch)</code></p>
<p>这样我们的结点中只需要定义<code>int</code>即可</p>
</li>
</ol>
<p>我们以第二种为例</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Nodeprt <span class="title function_">build_operator_tree</span><span class="params">(<span class="type">char</span> *s)</span> &#123;</span><br><span class="line">    Stack *stack_node=(Stack*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Stack));</span><br><span class="line">    Stack *stack_operator=(Stack*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Stack));</span><br><span class="line">    init(stack_node);</span><br><span class="line">    init(stack_operator);</span><br><span class="line">    <span class="type">int</span> flag = <span class="number">0</span>, num = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//flag作为多位数字处理的一个标记，如果flag是1，表示继续处理数字，否则表示结束数字的处理，从而分隔完整的数字</span></span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">&#x27; &#x27;</span>)<span class="keyword">continue</span>;<span class="comment">//空格直接跳过</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">isdigit</span>(s[i])) &#123;<span class="comment">//是数字</span></span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">            num *= <span class="number">10</span>;</span><br><span class="line">            num += s[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//其它所有情况作为与数字的一个区分</span></span><br><span class="line">            <span class="keyword">if</span> (flag == <span class="number">1</span>) &#123;</span><br><span class="line">                Nodeprt tmp = build_node(num, <span class="number">0</span>);</span><br><span class="line">                push(stack_node, tmp);</span><br><span class="line">                num = <span class="number">0</span>;</span><br><span class="line">                flag = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                Nodeprt tmp = build_node(<span class="string">&#x27;(&#x27;</span>, <span class="number">1</span>);</span><br><span class="line">                push(stack_operator, tmp);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> (!empty(stack_operator) &amp;&amp; get_top_data(stack_operator) != -<span class="string">&#x27;(&#x27;</span>) &#123;<span class="comment">//栈非空，直到&#x27;(&#x27;</span></span><br><span class="line">                    Nodeprt p = pop(stack_operator);</span><br><span class="line">                    p-&gt;right = pop(stack_node);</span><br><span class="line">                    p-&gt;left = pop(stack_node);</span><br><span class="line">                    push(stack_node, p);</span><br><span class="line">                &#125;</span><br><span class="line">                pop(stack_operator);<span class="comment">//把左括号弹出来</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;+&#x27;</span> || s[i] == <span class="string">&#x27;-&#x27;</span> || s[i] == <span class="string">&#x27;*&#x27;</span> || s[i] == <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> (!empty(stack_operator) &amp;&amp; priority(-(get_top_data(stack_operator))) &gt;= priority(s[i])) &#123;</span><br><span class="line">                    Nodeprt p = pop(stack_operator);</span><br><span class="line">                    p-&gt;right = pop(stack_node);</span><br><span class="line">                    p-&gt;left = pop(stack_node);</span><br><span class="line">                    push(stack_node, p);</span><br><span class="line">                &#125;</span><br><span class="line">                Nodeprt p = build_node(s[i], <span class="number">1</span>);</span><br><span class="line">                push(stack_operator, p);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!empty(stack_operator)) &#123;</span><br><span class="line">        Nodeprt p = pop(stack_operator);</span><br><span class="line">        p-&gt;right = pop(stack_node);</span><br><span class="line">        p-&gt;left = pop(stack_node);</span><br><span class="line">        push(stack_node, p);</span><br><span class="line">    &#125;</span><br><span class="line">    Nodeprt root = stack_node-&gt;data[stack_node-&gt;top];</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> s[MAXSIZE];</span><br><span class="line">    gets(s);</span><br><span class="line">    Nodeprt root= build_operator_tree(s);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="前缀表达式">前缀表达式</h2>
<p>前缀表达式运算符优先级已经由自身的符号顺序决定，表达式内没有括号，因此无需操作符栈，只需要一个结点栈即可</p>
<p>表达式树构建规则：</p>
<ol>
<li><strong>从后往前</strong>遍历前缀表达式，对于每一个遍历到的元素，形成一个结点</li>
<li>如果当前元素是数字，直接进入结点栈</li>
<li>如果是操作符，那就依次从结点栈内弹出两个结点，第一个弹出的作为右儿子，第二个弹出的作为左儿子，然后与当前操作符形成一个新的结点（树），再进入结点栈中</li>
</ol>
<p><strong>Ps：我们在从后往前遍历前缀表达式的过程中，假如某个多位数字是1234，但是从后往前读取得到的多位数字是4321，因此对于每次数字存储前，都需要对当前数字进行逆转</strong></p>
<p>重复以上规则，最终结点栈中仅剩一个结点，也就是表达式树的根结点</p>
<p>代码如下（以多位数字为例，用<code>int</code>同时存储数字和操作符—详细请看上文的中缀表达式构建方式说明）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">reverse_num</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> s[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span> (num) &#123;</span><br><span class="line">        s[cnt++] = num % <span class="number">10</span>;</span><br><span class="line">        num /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; cnt; i++) &#123;</span><br><span class="line">        num *= <span class="number">10</span>;</span><br><span class="line">        num += s[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Nodeprt <span class="title function_">build_operator_tree</span><span class="params">(<span class="type">char</span> *s)</span> &#123;</span><br><span class="line">    Stack *stack_node = (Stack *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Stack));</span><br><span class="line">    init(stack_node);</span><br><span class="line">    <span class="type">int</span> flag = <span class="number">0</span>, num = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//flag作为多位数字处理的一个标记，如果flag是1，表示继续处理数字，否则表示结束数字的处理，从而分隔完整的数字</span></span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;<span class="comment">//从后往前遍历</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isdigit</span>(s[i])) &#123;<span class="comment">//是数字</span></span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">            num *= <span class="number">10</span>;</span><br><span class="line">            num += s[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//一定是操作符</span></span><br><span class="line">            <span class="keyword">if</span> (flag == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">//这里虽然是从后往前遍历，但是数字读取反了，比如原来是31，结果读取成了13，需要扭转数字</span></span><br><span class="line">                num = reverse_num(num);</span><br><span class="line">                Nodeprt tmp = build_node(num, <span class="number">0</span>);</span><br><span class="line">                push(stack_node, tmp);</span><br><span class="line">                num = <span class="number">0</span>;</span><br><span class="line">                flag = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;+&#x27;</span> || s[i] == <span class="string">&#x27;-&#x27;</span> || s[i] == <span class="string">&#x27;*&#x27;</span> || s[i] == <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">                Nodeprt p = build_node(s[i], <span class="number">1</span>);</span><br><span class="line">                p-&gt;right = pop(stack_node);</span><br><span class="line">                p-&gt;left = pop(stack_node);</span><br><span class="line">                push(stack_node, p);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Nodeprt root = stack_node-&gt;data[stack_node-&gt;top];</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="后缀表达式">后缀表达式</h2>
<p>后缀表达式的运算符优先级已经由符号顺序决定，没有括号限制，因此无需符号栈，只要一个结点栈即可</p>
<p>表达式树构建规则：</p>
<ol>
<li>从前往后遍历后缀表达式，对于每个元素处理成为一个结点</li>
<li>如果是数字，直接进入结点栈</li>
<li>如果是操作符，那就依次从结点栈内弹出两个结点，第一个弹出的作为右儿子，第二个弹出的作为左儿子，然后与当前操作符形成一个新的结点（树），再进入结点栈中</li>
</ol>
<p>Ps：从前往后遍历不存在读取的数字相反的情况（参考前缀表达式），因此无需逆转数字</p>
<p>代码如下（以多位数字位例子，用<code>int</code>同时存储数字和操作符—详细请看上文的中缀表达式构建方式说明）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Nodeprt <span class="title function_">build_operator_tree</span><span class="params">(<span class="type">char</span> *s)</span> &#123;</span><br><span class="line">    Stack *stack_node = (Stack *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Stack));</span><br><span class="line">    init(stack_node);</span><br><span class="line">    <span class="type">int</span> flag = <span class="number">0</span>, num = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//flag作为多位数字处理的一个标记，如果flag是1，表示继续处理数字，否则表示结束数字的处理，从而分隔完整的数字</span></span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= len - <span class="number">1</span>; i++) &#123;<span class="comment">//从后往前遍历</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isdigit</span>(s[i])) &#123;<span class="comment">//是数字</span></span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">            num *= <span class="number">10</span>;</span><br><span class="line">            num += s[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//一定是操作符</span></span><br><span class="line">            <span class="keyword">if</span> (flag == <span class="number">1</span>) &#123;</span><br><span class="line">                Nodeprt tmp = build_node(num, <span class="number">0</span>);</span><br><span class="line">                push(stack_node, tmp);</span><br><span class="line">                num = <span class="number">0</span>;</span><br><span class="line">                flag = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;+&#x27;</span> || s[i] == <span class="string">&#x27;-&#x27;</span> || s[i] == <span class="string">&#x27;*&#x27;</span> || s[i] == <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">                Nodeprt p = build_node(s[i], <span class="number">1</span>);</span><br><span class="line">                p-&gt;right = pop(stack_node);</span><br><span class="line">                p-&gt;left = pop(stack_node);</span><br><span class="line">                push(stack_node, p);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Nodeprt root = stack_node-&gt;data[stack_node-&gt;top];</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>表达式树</category>
      </categories>
      <tags>
        <tag>表达式树</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp-study</title>
    <url>/2023/07/04/cpp-study/</url>
    <content><![CDATA[<p>c++学习过程中与c的比较（基于西北工业大学mooc）</p>
<span id="more"></span>
<h1>程序中数据的表示</h1>
<h2 id="数据类型">数据类型</h2>
<table>
<thead>
<tr>
<th><strong>long</strong></th>
<th><strong>4字节</strong></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>long double</strong></td>
<td><strong>增加了double的精度</strong></td>
<td></td>
</tr>
<tr>
<td><strong>bool</strong></td>
<td><strong>1字节</strong></td>
<td><strong>0或1</strong></td>
</tr>
</tbody>
</table>
<h2 id="常量与变量">常量与变量</h2>
<p>字面值（常量）：<code>112141</code>、<code>'A'</code>、<code>\x1234</code></p>
<p>以下说明均针对于字面值常量</p>
<p>八进制：0开头</p>
<p>十六进制：0x或者0X开头</p>
<p>浮点型常量默认double，如果要表示float要在末尾加上f或者F</p>
<p>字符：<code>\ooo</code>三位八进制数字表示字符</p>
<p><code>\xoo</code>两位十六进制数表示字符</p>
<p>const + 变量类型 + 变量名 = 数值，不可再次更改</p>
<h2 id="输入与输出">输入与输出</h2>
<p>cpp中主要采用<code>cin</code>和<code>cout</code>进行输入输出以及相关的格式控制，但是对于格式控制比较繁琐，可以使用<code>scanf</code>和<code>printf</code></p>
<h2 id="函数">函数</h2>
<h3 id="内联函数">内联函数</h3>
<p>cpp中可以在函数的声明前面加上<code>inline</code>，使得函数在编译过程中即成为内联函数，提升整体效率。</p>
<p>但是内联函数无法实现过于复杂的功能，因此规定内联函数内<strong>不使用循环语句和switch语句</strong></p>
<h3 id="函数的默认参数">函数的默认参数</h3>
<p>函数支持默认参数，为形参指定默认值，默认参数只能<strong>声明一次</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a=<span class="number">5</span>,<span class="type">int</span> b=<span class="number">6</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">add</span>(<span class="number">3</span>,<span class="number">4</span>);<span class="comment">//3+4</span></span><br><span class="line">    <span class="built_in">add</span>(<span class="number">4</span>);<span class="comment">//4+6</span></span><br><span class="line">    <span class="built_in">add</span>();<span class="comment">//5+6</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>默认参数自右向左设置，如果某一个参数设置了默认值，则<strong>它的右侧所有参数都必须有默认值</strong></p>
<p>默认值必须为常量或者全局变量或者他们构成的表达式或者函数</p>
<h3 id="函数重载">函数重载</h3>
<p>cpp支持函数重载，也就是允许在同一个域中使用多个相同函数名的函数，但是要求函数在参数<strong>类型或者个数中至少有一个不同</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">add</span><span class="params">(<span class="type">double</span> a,<span class="type">double</span> b)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="函数模板">函数模板</h2>
<p>根据上面的函数重载进行理解，就是把多个相同的函数，但是数据类型不同的用同一个函数模板表示</p>
<p>template&lt;模板形参表&gt;返回类型   函数名（函数参数）{}</p>
<p>模板形参表形式：typename 类型名1,typename 类型名2…(typename也可以用class表示，不过一般使用typename)非空</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> t,<span class="keyword">typename</span> f&gt;</span></span><br><span class="line"><span class="function">t <span class="title">add</span><span class="params">(t a,f b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">add</span>(<span class="number">5</span>,<span class="number">6.3</span>)&lt;&lt;endl;<span class="comment">//11</span></span><br><span class="line">    cout&lt;&lt;<span class="built_in">add</span>(<span class="number">6.3</span>,<span class="number">5</span>)&lt;&lt;endl;<span class="comment">//11.3</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>explanation_of_snake</title>
    <url>/2023/08/29/explanation-snake/</url>
    <content><![CDATA[<h1>游戏模式</h1>
<p>游戏一共分为四个模式，无尽模式，关卡模式，特殊食物模式，道具模式</p>
<h2 id="无尽模式">无尽模式</h2>
<p>和经典的贪吃蛇一样，吃掉食物增加分数和速度，地图上会生成一些障碍物，障碍物的数量可以在模式选择里更改，最终会记录玩家获得的分数</p>
<h2 id="关卡模式">关卡模式</h2>
<p>一共有六个关卡，每一个关卡都是一个迷宫图，玩家需要吃掉一定数量的食物获得胜利，胜利后即可解锁下一个关卡，前五个关卡的地图是固定的，第六个地图是随机生成的，每次点击都会出现不同的地图，最后会记录玩家通关的时间</p>
<h2 id="特殊食物模式">特殊食物模式</h2>
<p>食物在生成后会被附上属性，当前屏幕上的食物的属性会在顶部导航栏显示</p>
<ul>
<li>加速食物：顶部出现5s的计时器，显示加速剩余时间</li>
<li>减速食物：顶部出现5s的计时器，显示减速剩余时间</li>
<li>消除障碍物食物：吃掉食物后，会随机消除一部分地图中的障碍物</li>
<li>生成障碍物食物：吃掉食物后，会随机生成一部分地图中的障碍物</li>
<li>高分食物：食物具有更高的分数，其额外分数不定，属于1~3</li>
</ul>
<h2 id="随机事件模式">随机事件模式</h2>
<p>在游戏运行过程中会发生随机事件，其中控制更改会在顶部出现计时器</p>
<ul>
<li>控制更改：顶部导航栏出现计时器，玩家的按键控制反向</li>
<li>障碍物重刷：障碍物会全部消失，然后重新生成相同数量的障碍物</li>
<li>障碍物消失：障碍物会全部消失</li>
<li>虚实食物：食物的出现又概率变成两个，一个真，一个假</li>
</ul>
<h1>登录系统</h1>
<p>玩家可以点击登录，输入自己的用户名和密码进行登录或者注册，从而可以将游戏数据同步到服务器</p>
<p>永久保存数据，登录系统在安全方面，找回密码方面并不完善</p>
<h1>警告</h1>
<p>游戏在各个模式下，有极小极小的可能性出现食物无法吃到的情况，虽然已经采用算法尽可能避免这种情况。倘若这种情况出现，请重新开始游戏</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>pygame</tag>
      </tags>
  </entry>
  <entry>
    <title>soy的贪吃蛇</title>
    <url>/2023/09/10/soy%E7%9A%84%E8%B4%AA%E5%90%83%E8%9B%87/</url>
    <content><![CDATA[<p><a href="https://soybeanlittlecar.oss-cn-beijing.aliyuncs.com/blog/pygame-snake/source%20code.zip">源码下载</a></p>
<p><a href="https://soybeanlittlecar.oss-cn-beijing.aliyuncs.com/blog/pygame-snake/main.exe">可执行文件/贪吃蛇exe文件下载</a></p>
<p>源文件打包方法如下：</p>
<p>下载源文件并解压，在解压文件的同级目录下，就是在main.py的同级目录，打开cmd窗口，输入以下指令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pyinstaller --onefile --add-data &quot;images;images&quot; main.py game_over.py game_page_run.py globals.py level_choose.py map_test.py mode_choose_page.py mode_items.py mode_random.py skin_set_page.py test_window_pause.py check_user.py data_base.py login_page.py ranking_table.py</span><br></pre></td></tr></table></figure>
<p>打包的前提是用户已经安装了<code>pyinstaller</code></p>
<p>在[python的官网](<a href="https://www.python.org/">Welcome to Python.org</a>)下载3.9版本以上的python，然后在命令行界面输入<code>pip install pyinstaller</code>即可下载</p>
<p>该项目在老师指导后，有了一些创新点，比如在迷宫模式设置ai追逐啥的，基于目前水平有限，并没有继续申优</p>
<p>项目也有很多的小问题，大概都是我目前的水平无法解决的，但是整体的框架应该没有大问题，后续学习了新的知识我会继续更新此项目的相关功能</p>
<p>基于python中pygame的局限性，此项目很多方面都为pygame所困，无法呈现出一个理想的效果，在此也不推荐大家使用pygame制作游戏，而是使用unity去制作更加好的游戏</p>
]]></content>
      <tags>
        <tag>小学期</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式</title>
    <url>/2023/10/10/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<p>正则表达式是一种用于匹配和操作文本的强大工具，它是由一系列字符和特殊字符组成的模式，用于描述要匹配的文本模式。</p>
<p>正则表达式可以在文本中查找、替换、提取和验证特定的模式。</p>
<p>例如：</p>
<ul>
<li><strong>runoo+b</strong>，可以匹配 <strong>runoob、runooob、runoooooob</strong> 等，<strong>+</strong> 号代表前面的字符必须至少出现一次（1次或多次）<a href="https://www.runoob.com/try/try-regex.php?texts=runoob%7Crunooob%7Crunoooooob&amp;tips=runoo%2Bb"><strong>尝试一下 »</strong></a>。</li>
<li><strong>runoo*b</strong>，可以匹配 <strong>runob、runoob、runoooooob</strong> 等，***** 号代表前面的字符可以不出现，也可以出现一次或者多次（0次、或1次、或多次）<a href="https://www.runoob.com/try/try-regex.php?texts=runoob%7Crunooob%7Crunoooooob&amp;tips=runoo*b"><strong>尝试一下 »</strong></a>。</li>
<li><strong>colou?r</strong> 可以匹配 <strong>color</strong> 或者 <strong>colour</strong>，<strong>?</strong> 问号代表前面的字符最多只可以出现一次（0次或1次）<a href="https://www.runoob.com/try/try-regex.php?texts=color%7Ccolour%7Ccolour123&amp;tips=colou%3Fr"><strong>尝试一下 »</strong></a>。</li>
</ul>
<p>构造正则表达式的方法和创建数学表达式的方法一样。也就是用多种元字符与运算符可以将小的表达式结合在一起来创建更大的表达式。正则表达式的组件可以是单个的字符、字符集合、字符范围、字符间的选择或者所有这些组件的任意组合。</p>
<p>正则表达式是由普通字符（例如字符 a 到 z）以及特殊字符（称为&quot;元字符&quot;）组成的文字模式。模式描述在搜索文本时要匹配的一个或多个字符串。正则表达式作为一个模板，将某个字符模式与所搜索的字符串进行匹配。</p>
<h3 id="普通字符">普通字符</h3>
<p>所有大写和小写字母、所有数字、所有标点符号和一些其他符号。</p>
<ul>
<li><code>[ABC]</code>，匹配<code>[. . .]</code>中的所有字符，比如<code>[soy]</code>匹配<code>sssdiobfyyy</code>中的所有<code>s, o, y</code></li>
<li><code>[^ABC]</code>，匹配除了<code>[. . .]</code>中的所有字符，比如<code>[soy]</code>匹配<code>sssdiobfyyy</code>中的<code>d i o b f</code></li>
<li><code>[A-Z]</code>表示匹配所有大写字母，<code>[a-z]</code>表示匹配所有小写字母</li>
<li><code>.</code>匹配除了换行符<code>\n, \r</code>外的任何单个字符</li>
<li><code>[\s\S]</code>匹配所有，<code>\s</code>匹配所有空白符，包括换行，<code>\S</code>非空白符，不包括换行</li>
<li><code>\w</code>匹配字母，数字，下划线，等价于<code>[A-Za-z0-9_]</code></li>
</ul>
<h3 id="非打印字符">非打印字符</h3>
<p><code>\cx, \f, \n, \r, \s, \S, \t, \v</code></p>
<h3 id="特殊字符">特殊字符</h3>
<table>
<thead>
<tr>
<th style="text-align:left">特别字符</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">$</td>
<td style="text-align:left">匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 <code>\n</code> 或<code>\r</code>。要匹配 $ 字符本身，请使用 <code>\$</code>。</td>
</tr>
<tr>
<td style="text-align:left">( )</td>
<td style="text-align:left">标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用<code>\(</code>和<code> \)</code>。</td>
</tr>
<tr>
<td style="text-align:left">*</td>
<td style="text-align:left">匹配前面的子表达式零次或多次。要匹配 <code>*</code> 字符，请使用<code> \*</code>。</td>
</tr>
<tr>
<td style="text-align:left">+</td>
<td style="text-align:left">匹配前面的子表达式一次或多次。要匹配 <code>+</code> 字符，请使用<code> \+</code>。</td>
</tr>
<tr>
<td style="text-align:left">.</td>
<td style="text-align:left">匹配除换行符 \n 之外的任何单字符。要匹配<code> .</code> ，请使用<code> \.</code> 。</td>
</tr>
<tr>
<td style="text-align:left">[</td>
<td style="text-align:left">标记一个中括号表达式的开始。要匹配 [，请使用<code> \[</code>。</td>
</tr>
<tr>
<td style="text-align:left">?</td>
<td style="text-align:left">匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。要匹配 ? 字符，请使用<code> \?</code>。</td>
</tr>
<tr>
<td style="text-align:left">\</td>
<td style="text-align:left">将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如，<code>n</code> 匹配字符 <code>n</code>。<code>\n</code> 匹配换行符。序列 <code>\\</code> 匹配<code>\</code>，而<code>\(</code> 则匹配 <code>(</code>。</td>
</tr>
<tr>
<td style="text-align:left">^</td>
<td style="text-align:left">匹配输入字符串的开始位置，除非在方括号表达式中使用，当该符号在方括号表达式中使用时，表示不接受该方括号表达式中的字符集合。要匹配 ^ 字符本身，请使用<code>\^</code>。</td>
</tr>
<tr>
<td style="text-align:left">{</td>
<td style="text-align:left">标记限定符表达式的开始。要匹配 {，请使用<code>\&#123;</code>。</td>
</tr>
<tr>
<td style="text-align:left">|</td>
<td style="text-align:left">指明两项之间的一个选择。要匹配 |，请使用<code> |</code>。</td>
</tr>
</tbody>
</table>
<h3 id="限定符">限定符</h3>
<ul>
<li><code>*</code>等价于{0,}</li>
<li><code>+</code>等价于{1,}</li>
<li><code>?</code>等价于{0,1}</li>
<li><code>&#123;n&#125;</code>，n是非负整数，表示匹配次数</li>
<li><code>&#123;n,&#125;</code>，n是非负整数，表示至少的匹配次数</li>
<li><code>&#123;n,m&#125;</code>，n，m是非负整数，表示至少n次，最多m次</li>
<li>注意这些逗号之间不能添加空格</li>
</ul>
]]></content>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>mips</title>
    <url>/2023/10/20/mips/</url>
    <content><![CDATA[<p>[Mars基本用法参考](<a href="https://jingyan.baidu.com/article/ea24bc39c04b76da62b3313c.html#:~:text=%E6%96%B9%E6%B3%95%2F%E6%AD%A5%E9%AA%A4">https://jingyan.baidu.com/article/ea24bc39c04b76da62b3313c.html#:~:text=方法%2F步骤</a> 1%2F11 分步阅读 首先在官网下载Mars 4.5。,是一个4MB的Jar可执行文件。 如果电脑上已经装有Java运行库就可以直接运行了。 2%2F11 打开MARS，点击左上角的File菜单，选择New或者Open (一个asm格式文件).如图我们新建了一个。)</p>
<h2 id="赋值">赋值</h2>
<ul>
<li><code>ori $t2,100</code>将t2寄存器的值赋值为100，其实是”100或上0“的结果给t2寄存器</li>
<li><code>li $t1,100</code>将t1寄存器的值赋值为100，<code>li</code>是伪指令，表示<strong>立即加载</strong></li>
</ul>
<h2 id="传值">传值</h2>
<ul>
<li><code>move $t1,$t2</code>，将t2寄存器的值传递给t1寄存器，同时t2寄存器中的值不改变</li>
</ul>
<h2 id="运算">运算</h2>
<ul>
<li>加法：<code>add $t1,$t2,$t3</code>,将t2寄存器的值和t3寄存器的值相加给t1寄存器，这里公式里面可以包含数字，比如<code>add $t1,$t2,100</code>，100也可以换成负数</li>
<li>减法：<code>sub $t1,$t2,$t3</code></li>
<li>乘法：<code>mul $t1,$t2,$t3</code></li>
<li>除法：<code>div rs, rt</code>，商放在<code>LO</code>寄存器中，余数放在<code>HI</code>寄存器中，如果rt寄存器的值为0，那么结果不可预料</li>
<li>使用<code>mfhi和mflo</code>来分别读取HI和LO寄存器</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">li $t1,5		#被除数5</span><br><span class="line">li $t2,2		#除数2</span><br><span class="line">div $t1,$t2		#计算5/2，商在LO中，余数在HI中</span><br><span class="line">mfhi $t3		#将HI寄存器的值取出放在t3寄存器中，为1</span><br><span class="line">mflo $t4		#将LO寄存器的值取出放在t4寄存器中，为2</span><br></pre></td></tr></table></figure>
<h2 id="输入输出-scanf与printf">输入输出(scanf与printf)</h2>
<p><code>v0</code>寄存器的值与<code>syscall</code>（系统调用）是紧密联系的，也就是<code>v0</code>的值决定了syscall是输入还是输出，输入/输出是字符串还是数字</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">li $v0,5</span><br><span class="line">syscall</span><br></pre></td></tr></table></figure>
<p>这段代码表面含义：把v0寄存器的值赋值为5，然后进行系统调用。</p>
<p>实际含义：读入一个整数，整数的值存储于v0中。也就是v0寄存器的值为5，决定了syscall为读入一个整数，并将读入的整数存储在v0寄存器中。具体对应值参考mars的help</p>
<h3 id="第一个程序">第一个程序</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">li $v0,5                                                </span><br><span class="line">syscall                 #读入一个整数</span><br><span class="line"></span><br><span class="line">addi $v0,$v0,1          #加1</span><br><span class="line">move $a0,$v0            #把v0寄存器的值移到a0</span><br><span class="line"></span><br><span class="line">li $v0,1              </span><br><span class="line">syscall                 #输出a0寄存器的值</span><br></pre></td></tr></table></figure>
<h2 id="判断">判断</h2>
<p>跳转指令<code>ble</code></p>
<p><code>ble $t1,6,lable1</code>如果t1寄存器的值小于等于6，则跳转到lable1处，否则，执行ble下一条指令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">li $t1,5                                                                          </span><br><span class="line">li $v0,1                        #确立syscall为输出a0的值                            </span><br><span class="line">ble $t1,5,lable1    </span><br><span class="line"></span><br><span class="line">li $a0,5      #若t1不是小于等于5，继续执行该语句</span><br><span class="line">syscall       #输出5</span><br><span class="line"></span><br><span class="line">lable1:       #若t1小于等于5，跳转至此处</span><br><span class="line">li $a0,6</span><br><span class="line">syscall       #输出6</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">li $t1,5                                                                          </span><br><span class="line">li $v0,1                        #确立syscall为输出a0的值                            </span><br><span class="line">ble $t1,3,lable1    </span><br><span class="line"></span><br><span class="line">li $a0,5      #若t1不是小于等于5，继续执行该语句</span><br><span class="line">syscall       #输出5</span><br><span class="line"></span><br><span class="line">lable1:       #若t1小于等于5，跳转至此处</span><br><span class="line">li $a0,6</span><br><span class="line">syscall       #输出6</span><br><span class="line">最终输出56</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">li $t1,5</span><br><span class="line">li $v0,1</span><br><span class="line">ble $t1,3,lable1</span><br><span class="line"></span><br><span class="line">li $a0,5</span><br><span class="line">syscall			#输出5</span><br><span class="line">li $v0,10</span><br><span class="line">syscall			#程序结束代码</span><br><span class="line"></span><br><span class="line">lable1:</span><br><span class="line">li $a0,6</span><br><span class="line">syscall</span><br></pre></td></tr></table></figure>
<h2 id="循环">循环</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">li $t1,0</span><br><span class="line">li $a0,0</span><br><span class="line">loop:</span><br><span class="line"> addi $a0,$a0,1</span><br><span class="line"> addi $t1,$t1,1</span><br><span class="line"> ble $t1,3,loop</span><br><span class="line">li $v0,1</span><br><span class="line">syscall</span><br></pre></td></tr></table></figure>
<p>使用判断语句和loop即可实现循环</p>
<h2 id="数组">数组</h2>
<p>mips代表一般有两部分，<code>.data和.text</code>，前面的内容都是<code>.text</code>部分，对于数组的使用需要使用<code>.data</code>段。</p>
<p>在.data定义一个起始地址为array，空间为400的数组，然后再.text写代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line">array:.space 400</span><br><span class="line"></span><br><span class="line">.text</span><br><span class="line">xxxx</span><br></pre></td></tr></table></figure>
<p>使用数组之前，需要将数组的首地址赋值给一个寄存器，用<code>la</code>指令</p>
<p><code>la $t1,array</code></p>
<p>int占4个字节，以下是赋值方式，在此表示方法下，需要<code>sw(存)</code>和<code>lw(取)</code>来赋值和取值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">li $t2,3</span><br><span class="line">sw $t2,0($t1)		#array[0]=3</span><br><span class="line"></span><br><span class="line">li $t2,4</span><br><span class="line">sw $t2,4($t1)		#array[1]=4</span><br></pre></td></tr></table></figure>
<p>完整代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line">array:.space 400</span><br><span class="line"></span><br><span class="line">.text</span><br><span class="line">la $t1,array</span><br><span class="line"></span><br><span class="line">li $t2,3</span><br><span class="line">sw $t2,0($t1)</span><br><span class="line">li $t2,4</span><br><span class="line">sw $t2,4($t2)</span><br><span class="line"></span><br><span class="line">li $v0,1</span><br><span class="line">lw $a0,0($t1)</span><br><span class="line">syscall</span><br><span class="line">lw $a0,4($t1)</span><br><span class="line">syscall</span><br></pre></td></tr></table></figure>
<p>在.data里加一句`a:.asciiz&quot;,&quot;</p>
<p>想要输出逗号的地方加一句</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">la $a0,a</span><br><span class="line">li $v0,4</span><br><span class="line">syscall</span><br></pre></td></tr></table></figure>
<p>数组的赋值还有别的写法，这种写法适合循环赋值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line">array:.space 400</span><br><span class="line"></span><br><span class="line">.text</span><br><span class="line">la $t1,array</span><br><span class="line">li $t2,4</span><br><span class="line">addi $t3,$t1,4</span><br><span class="line">sw $t2,0($t3)		#array[1]=4</span><br></pre></td></tr></table></figure>
<h2 id="宏">宏</h2>
<p><code>.marco</code>开始<code>.end_macro</code>结束</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.macro RI(%i)</span><br><span class="line">	li $v0,5</span><br><span class="line">	syscall</span><br><span class="line">	move %i,$v0</span><br><span class="line">.end_macro</span><br></pre></td></tr></table></figure>
<h2 id="递归">递归</h2>
<p><code>jal</code>指令，跳转到相应位置，并将现在的指令位置存储在ra寄存器中，当跳转结束后可由<code>jr $ra</code>指令返回，返回值存储在v0寄存器中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">li $a0,1</span><br><span class="line"></span><br><span class="line">jal lable</span><br><span class="line"></span><br><span class="line">li $v0,1</span><br><span class="line">syscall</span><br><span class="line">li $v0 10</span><br><span class="line">syscall</span><br><span class="line"></span><br><span class="line">label:</span><br><span class="line">addi $a0,$a0,1</span><br><span class="line">jr $ra</span><br><span class="line"></span><br><span class="line">#最后输出2</span><br></pre></td></tr></table></figure>
<p><code>sp</code>指针，sp指针可以分配空间</p>
<p>栈通常由高地址向低地址生长，$sp指向栈顶，也就是最高地址</p>
<ul>
<li>数据入栈时，让sp减小</li>
<li>数据出栈时，sp增大</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">addi $sp,$sp,-8</span><br></pre></td></tr></table></figure>
<p>可以理解为分配了8个单位的空间，可以用来存储数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sw $t1,0($sp)</span><br><span class="line">sw $t2,4($sp)</span><br></pre></td></tr></table></figure>
<p>无论如何修改寄存器t1，t2的值，只要如下操作，t1，t2就会恢复原本的值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lw $t1,0($sp)</span><br><span class="line">lw $t2,4($sp)</span><br></pre></td></tr></table></figure>
<p>最后别忘了加回来指针</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">addi $sp,$sp,8</span><br></pre></td></tr></table></figure>
<p>下面时一份递归代码，输出f(3)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">f</span><span class="params">(x)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">1</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> f(x<span class="number">-1</span>)+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其对应的汇编代码为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">li $a1,3</span><br><span class="line">jal label</span><br><span class="line"></span><br><span class="line">move $a0,$v0	#输出</span><br><span class="line">li $v0,1</span><br><span class="line">syscall</span><br><span class="line">li $v0,10</span><br><span class="line">syscall</span><br><span class="line"></span><br><span class="line">label:</span><br><span class="line">	beq $a1,1,ret	#如果x==1,则xxx</span><br><span class="line">	addi $sp,$sp,-8</span><br><span class="line">	sw $a1,0($sp)</span><br><span class="line">	sw $ra,4($sp)	#将返回值和x的地址存储起来</span><br><span class="line">	addi $a1,$a1,-1	#x-1</span><br><span class="line">	jal label		#执行f(x-1)</span><br><span class="line">	lw $a1,0($sp)</span><br><span class="line">	lw $ra,4($sp)</span><br><span class="line">	addi $sp,$sp,8</span><br><span class="line">	move $s1,$v0</span><br><span class="line">	addi $v0,$s1,1	#f(x-1)+1</span><br><span class="line">	jr $ra</span><br><span class="line"></span><br><span class="line">ret:</span><br><span class="line">	li $v0,1	#返回值存储在v0中</span><br><span class="line">	jr $ra</span><br></pre></td></tr></table></figure>
<h1>mips总结</h1>
<p>寄存器表，记录常见寄存器的用途与编号规则</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Reg.Num</th>
<th>Usage</th>
</tr>
</thead>
<tbody>
<tr>
<td>zero</td>
<td>0</td>
<td>恒为0</td>
</tr>
<tr>
<td>at</td>
<td>1</td>
<td>为汇编程序保留</td>
</tr>
<tr>
<td>v0~v1</td>
<td>2~3    (2的1次幂)</td>
<td>过程调用返回值</td>
</tr>
<tr>
<td>a0~a3</td>
<td>4~7    (2的2次幂)</td>
<td>过程调用参数(函数参数)</td>
</tr>
<tr>
<td>t0~t7</td>
<td>8~15   (2的3次幂)</td>
<td>临时变量</td>
</tr>
<tr>
<td>s0~s7</td>
<td>16~23 (2的4次幂)</td>
<td>保存</td>
</tr>
<tr>
<td>t8~t9</td>
<td>24~25</td>
<td>临时变量</td>
</tr>
<tr>
<td>k0~k1</td>
<td>26~27</td>
<td>为<strong>OS</strong>保留</td>
</tr>
<tr>
<td>gp</td>
<td>28</td>
<td>global pointer</td>
</tr>
<tr>
<td>sp</td>
<td>29</td>
<td>stack pointer</td>
</tr>
<tr>
<td>fp</td>
<td>30</td>
<td>frame pointer</td>
</tr>
<tr>
<td>ra</td>
<td>31</td>
<td>return address</td>
</tr>
</tbody>
</table>
]]></content>
  </entry>
  <entry>
    <title>计算几何</title>
    <url>/2023/11/18/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/</url>
    <content><![CDATA[<h2 id="点和线段的定义">点和线段的定义</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">point</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125;Point;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">segment</span> &#123;</span></span><br><span class="line">    Point p1;</span><br><span class="line">    Point p2;</span><br><span class="line">&#125;Segment;</span><br></pre></td></tr></table></figure>
<h2 id="叉积">叉积</h2>
<p>叉积为正，p1位于p2顺时针方向，为负，p1位于p2逆时针方向<br>
确定两个有向线段的顺逆时针方向，将有向线段源点都转化为原点，从而比较两个点的顺逆时针方向</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="type">long</span> <span class="title function_">CrossProduct</span><span class="params">(Point p1,Point p2)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p1.x*p2.y-p1.y*p2.x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="线段相交">线段相交</h2>
<p>两个连续线段的左转右转问题，同样可以看叉积确定顺逆时针，pi-》pj-》pk<br>
负数就是逆时针，正数就是顺时针</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="type">long</span> <span class="title function_">Direction</span><span class="params">(Point pi,Point pj,Point pk)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (pk.x-pi.x)*(pj.y-pi.y)-(pk.y-pi.y)*(pj.x-pi.x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>两条线段相交的情况：</p>
<ol>
<li>两条线段都跨越了对方所在直线</li>
<li>或者一条线段的某个端点在另一条直线上（特殊情况）<br>
返回1就是在线段上</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int OnSegment(Point pi,Point pj,Point pk)&#123;//pk在不在线段pi，pj上</span><br><span class="line">    if(min(pi.x,pj.x)&lt;=pk.x&amp;&amp;pk.x&lt;=max(pi.x,pj.x)&amp;&amp;min(pi.y,pj.y)&lt;=pk.y&amp;&amp;pk.y&lt;=max(pi.y,pj.y))return 1;</span><br><span class="line">    else return 0;</span><br><span class="line">&#125;</span><br><span class="line">int SegmentIsIntersect(Point p1,Point p2,Point p3,Point p4)&#123;</span><br><span class="line">    long long d1 = Direction(p3,p4,p1);</span><br><span class="line">    long long d2 = Direction(p3,p4,p2);</span><br><span class="line">    long long d3 = Direction(p1,p2,p3);</span><br><span class="line">    long long d4 = Direction(p1,p2,p4);</span><br><span class="line">    if(((d1&gt;0&amp;&amp;d2&lt;0)||(d1&lt;0&amp;&amp;d2&gt;0))&amp;&amp;((d3&lt;0&amp;&amp;d4&gt;0)||(d3&gt;0&amp;&amp;d4&lt;0)))&#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    else if(d1==0&amp;&amp;OnSegment(p3,p4,p1))return 1;</span><br><span class="line">    else if(d2==0&amp;&amp;OnSegment(p3,p4,p2))return 1;</span><br><span class="line">    else if(d3==0&amp;&amp;OnSegment(p1,p2,p3))return 1;</span><br><span class="line">    else if(d4==0&amp;&amp;OnSegment(p1,p2,p4))return 1;</span><br><span class="line">    else return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="点到线段的距离">点到线段的距离</h2>
<p>包含了特殊情况</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="type">double</span> <span class="title function_">PointToSegment</span><span class="params">(Point p0, Point p1, Point p2)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> cross = (p2.x - p1.x) * (p0.x - p1.x) + (p2.y - p1.y) * (p0.y - p1.y);</span><br><span class="line">    <span class="keyword">if</span> (cross &lt;= <span class="number">0</span>)<span class="keyword">return</span> <span class="built_in">sqrt</span>((p0.x - p1.x) * (p0.x - p1.x) + (p0.y - p1.y) * (p0.y - p1.y));</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> d2 = (p2.x - p1.x) * (p2.x - p1.x) + (p2.y - p1.y) * (p2.y - p1.y);</span><br><span class="line">    <span class="keyword">if</span> (cross &gt;= d2)<span class="keyword">return</span> <span class="built_in">sqrt</span>((p0.x - p2.x) * (p0.x - p2.x) + (p0.y - p2.y) * (p0.y - p2.y));</span><br><span class="line">    <span class="type">long</span> <span class="type">double</span> r = (<span class="type">long</span> <span class="type">double</span>) cross / d2;</span><br><span class="line">    <span class="type">long</span> <span class="type">double</span> px = p1.x + (p2.x - p1.x) * r;</span><br><span class="line">    <span class="type">long</span> <span class="type">double</span> py = p1.y + (p2.y - p1.y) * r;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>((p0.x - px) * (p0.x - px) + (p0.y - py) * (p0.y - py));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Graham凸包">Graham凸包</h2>
<p>首先找到y坐标最小，最靠左的点p0，p0一定是凸包上的点</p>
<p>对p0参考，对其它所有点排序（根据幅角，或者是余弦值）</p>
<p>入栈p0，p1，p2，每次看一个点相对于栈顶两个元素连线的位置</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Point p0;</span><br><span class="line">Point <span class="built_in">stack</span>[<span class="number">10000</span>];</span><br><span class="line"><span class="type">int</span> top = <span class="number">-1</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">double</span> <span class="title function_">Distance</span><span class="params">(Point p1,Point p2)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sqrtl((p1.x-p2.x)*(p1.x-p2.x)+(p1.y-p2.y)*(p1.y-p2.y));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> <span class="title function_">Direction</span><span class="params">(Point pi,Point pj,Point pk)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (pk.x-pi.x)*(pj.y-pi.y)-(pk.y-pi.y)*(pj.x-pi.x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> <span class="title function_">area</span><span class="params">(Point p0, Point p1, Point p2)</span> &#123;<span class="comment">//这里算的是三角形面积的两倍</span></span><br><span class="line">    <span class="keyword">return</span> llabs((p1.x - p0.x) * (p2.y - p0.y) - (p1.y - p0.y) * (p2.x - p0.x));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *e1,<span class="type">const</span> <span class="type">void</span> *e2)</span>&#123;</span><br><span class="line">    Point p1 = *((Point *)e1);</span><br><span class="line">    Point p2 = *((Point *)e2);</span><br><span class="line">    <span class="comment">//计算相对点的余弦，余弦越小，幅角越大</span></span><br><span class="line">    <span class="comment">//这里让两个数同时乘以分母，避免除法</span></span><br><span class="line">    <span class="type">long</span> <span class="type">double</span> f1 = (p1.x-p0.x)* Distance(p2,p0);</span><br><span class="line">    <span class="type">long</span> <span class="type">double</span> f2 = (p2.x-p0.x)* Distance(p1,p0);</span><br><span class="line">    <span class="keyword">if</span>(fabsl(f1-f2)&lt;<span class="number">1e-5</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p1.x&gt;p2.x)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(p1.x&lt;p2.x)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(f1&gt;f2)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(f1&lt;f2)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">GrahamScan</span><span class="params">(Point Q[],<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    top = <span class="number">-1</span>;</span><br><span class="line">    p0 = (Point)&#123;MAX,MAX&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(Q[i].y&lt;p0.y)p0 = Q[i];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(Q[i].y==p0.y)&#123;</span><br><span class="line">            <span class="keyword">if</span>(Q[i].x&lt;p0.x)p0=Q[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//p0为y坐标最小，如果y有一样的，p0就是最左边的那个</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;<span class="comment">//去除p0</span></span><br><span class="line">        <span class="keyword">if</span>(Q[i].x==p0.x&amp;&amp;Q[i].y==p0.y)&#123;</span><br><span class="line">            <span class="keyword">for</span>(;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">                Q[i]=Q[i+<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    qsort(Q,n<span class="number">-1</span>,<span class="keyword">sizeof</span>(Q[<span class="number">0</span>]),cmp);</span><br><span class="line">    <span class="built_in">stack</span>[++top]=p0;</span><br><span class="line">    <span class="built_in">stack</span>[++top]=Q[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span> (n - <span class="number">1</span> &lt; <span class="number">2</span>)<span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">stack</span>[++top]=Q[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(Direction(<span class="built_in">stack</span>[top<span class="number">-1</span>],<span class="built_in">stack</span>[top],Q[i])&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            top--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">stack</span>[++top]=Q[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//最后stack里面就是逆时针的凸包点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="旋转卡壳">旋转卡壳</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="type">long</span> <span class="title function_">area</span><span class="params">(Point p0, Point p1, Point p2)</span> &#123;<span class="comment">//这里算的是三角形面积的两倍</span></span><br><span class="line">    <span class="keyword">return</span> llabs((p1.x - p0.x) * (p2.y - p0.y) - (p1.y - p0.y) * (p2.x - p0.x));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> <span class="title function_">dis</span><span class="params">(Point p1, Point p2)</span> &#123;<span class="comment">//这里算的是两个点距离的平方</span></span><br><span class="line">    <span class="keyword">return</span> (p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> <span class="title function_">rotatingCalipers</span><span class="params">()</span> &#123;<span class="comment">//返回凸包上最远的点对距离的平方</span></span><br><span class="line">    <span class="type">int</span> j = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">stack</span>[++top] = <span class="built_in">stack</span>[<span class="number">0</span>];<span class="comment">//要在凸包集合末尾加上最初的点，保证枚举所有边</span></span><br><span class="line">    <span class="keyword">if</span> (top &lt; <span class="number">3</span>) &#123; <span class="keyword">return</span> dis(<span class="built_in">stack</span>[<span class="number">0</span>], <span class="built_in">stack</span>[<span class="number">1</span>]); &#125;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; top; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (area(<span class="built_in">stack</span>[i], <span class="built_in">stack</span>[i + <span class="number">1</span>], <span class="built_in">stack</span>[j]) &lt;= area(<span class="built_in">stack</span>[i], <span class="built_in">stack</span>[i + <span class="number">1</span>], <span class="built_in">stack</span>[j % top + <span class="number">1</span>]))j = j % top + <span class="number">1</span>;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> tmp = max(dis(<span class="built_in">stack</span>[i], <span class="built_in">stack</span>[j]), dis(<span class="built_in">stack</span>[i + <span class="number">1</span>], <span class="built_in">stack</span>[j]));</span><br><span class="line">        max = max(max, tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二维点对的查找">二维点对的查找</h2>
<p>对所有点进行重复坐标的合并，并增加其点的个数</p>
<p>按照x升序，y再升序进行排列，查找某个点xy时，先查找x的左侧和右侧边界，然后在确定的边界内查找y</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">binarySearchLeft</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="type">int</span> saveRight = right;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (s[mid].x &lt; x)left = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> right = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (left &gt; saveRight || s[left].x != x)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">binarySearchRight</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="type">int</span> saveLeft = left;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (s[mid].x &gt; x)right = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> left = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (right &lt; saveLeft || s[right].x != x)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="type">int</span> L = binarySearchLeft(x, left, right);</span><br><span class="line">    <span class="type">int</span> R = binarySearchRight(x, left, right);</span><br><span class="line">    <span class="keyword">if</span> (L == <span class="number">-1</span> || R == <span class="number">-1</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (L &lt;= R) &#123;</span><br><span class="line">        <span class="type">int</span> mid = (L + R) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (s[mid].y &lt; y)L = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s[mid].y &gt; y)R = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> s[mid].cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="三角形三条边长度确定外接圆坐标">三角形三条边长度确定外接圆坐标</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="type">long</span> <span class="title function_">GP</span><span class="params">(<span class="type">long</span> <span class="type">long</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取圆心坐标</span></span><br><span class="line"><span class="type">long</span> <span class="type">double</span> site[<span class="number">2</span>];</span><br><span class="line"><span class="type">void</span> <span class="title function_">getCirclePoint</span><span class="params">(Point A, Point B, Point C)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">double</span> x = (<span class="type">long</span> <span class="type">double</span>) ((GP(A.x) + GP(A.y)) * (B.y - C.y) + (GP(B.x) + GP(B.y)) * (C.y - A.y) + (GP(C.x) + GP(C.y)) * (A.y - B.y)) / (A.x * (B.y - C.y) + B.x * (C.y - A.y) + C.x * (A.y - B.y)) / <span class="number">2</span>;</span><br><span class="line">    <span class="type">long</span> <span class="type">double</span> y = (<span class="type">long</span> <span class="type">double</span>) ((GP(A.x) + GP(A.y)) * (C.x - B.x) + (GP(B.x) + GP(B.y)) * (A.x - C.x) + (GP(C.x) + GP(C.y)) * (B.x - A.x)) / (A.x * (B.y - C.y) + B.x * (C.y - A.y) + C.x * (A.y - B.y)) / <span class="number">2</span>;</span><br><span class="line">    site[<span class="number">0</span>] = x;</span><br><span class="line">    site[<span class="number">1</span>] = y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">long</span> <span class="type">double</span> <span class="title function_">calDisCircleToLine</span><span class="params">(Point cir[], Point line[])</span> &#123;</span><br><span class="line">    getCirclePoint(cir[<span class="number">0</span>], cir[<span class="number">1</span>], cir[<span class="number">2</span>]);</span><br><span class="line">    <span class="type">long</span> <span class="type">double</span> r = sqrtl((site[<span class="number">0</span>] - cir[<span class="number">0</span>].x) * (site[<span class="number">0</span>] - cir[<span class="number">0</span>].x) + (site[<span class="number">1</span>] - cir[<span class="number">0</span>].y) * (site[<span class="number">1</span>] - cir[<span class="number">0</span>].y));</span><br><span class="line">    <span class="type">long</span> <span class="type">double</span> dis = fabsl((site[<span class="number">0</span>] - line[<span class="number">0</span>].x) * (site[<span class="number">1</span>] - line[<span class="number">1</span>].y) - (site[<span class="number">1</span>] - line[<span class="number">0</span>].y) * (site[<span class="number">0</span>] - line[<span class="number">1</span>].x)) / distance(line[<span class="number">0</span>], line[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span> (dis &gt; r)<span class="keyword">return</span> dis - r;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0.00</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>计算几何</tag>
      </tags>
  </entry>
  <entry>
    <title>图算法合集</title>
    <url>/2023/11/14/%E5%9B%BE%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86/</url>
    <content><![CDATA[<h3 id="邻接表存储图">邻接表存储图</h3>
<p>数组s存储的是所有对应编号节点连的边(抛弃了以前的邻接表头部分，更简洁)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> w;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">link</span>;</span></span><br><span class="line">&#125; Node, *Nodeprt;</span><br><span class="line">Nodeprt s[<span class="number">100005</span>];</span><br></pre></td></tr></table></figure>
<p>节点编号和权重</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Nodeprt <span class="title function_">buildEdge</span><span class="params">(<span class="type">int</span> data,<span class="type">long</span> <span class="type">long</span> w)</span>&#123;</span><br><span class="line">    Nodeprt p = (Nodeprt)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    p-&gt;data=data;</span><br><span class="line">    p-&gt;w=w;</span><br><span class="line">    p-&gt;link = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>插入每条边，直接从头部插入，然后更新头部，提高效率，避免每次寻找链表尾部</p>
<p>插入的时候，如果是无向图，需要用两次插入函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">insertEdge</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">long</span> <span class="type">long</span> w)</span>&#123;</span><br><span class="line">    Nodeprt p = buildEdge(v,w);</span><br><span class="line">    <span class="keyword">if</span>(s[u]==<span class="literal">NULL</span>)s[u]=p;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        p-&gt;link=s[u];</span><br><span class="line">        s[u]=p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>邻接表存图，如果多组数据，需要删除当前有的边</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">deleteEdge</span><span class="params">(<span class="type">int</span> n)</span>&#123;<span class="comment">//删除所有顶点连接的边</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(Nodeprt p = s[i];p!=<span class="literal">NULL</span>;)&#123;</span><br><span class="line">            Nodeprt q = p;</span><br><span class="line">            p=p-&gt;link;</span><br><span class="line">            <span class="built_in">free</span>(q);</span><br><span class="line">        &#125;</span><br><span class="line">        s[i]=<span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="堆">堆</h3>
<p>在后面的学习中，基本所有算法对时间都有一个比较高的要求，因此基本能使用堆的地方都尽可能使用堆优化，每次自己都手写一遍</p>
<p>堆节点及其存储(这里以对结构体的节点编号和距离为例子)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> w;</span><br><span class="line">&#125;Edge,*Edgeprt;</span><br><span class="line">Edge Heap[<span class="number">500005</span>];</span><br><span class="line"><span class="type">int</span> size=<span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>堆的插入，每次插入到末尾，然后自顶向上更新，对堆进行向下过滤</p>
<p>小顶堆</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">insertHeap</span><span class="params">(<span class="type">int</span> data,<span class="type">long</span> <span class="type">long</span> w)</span>&#123;</span><br><span class="line">    Edge p = &#123;data,w&#125;;</span><br><span class="line">    size++;</span><br><span class="line">    <span class="type">int</span> i=size;</span><br><span class="line">    <span class="keyword">while</span>(i&gt;=<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="comment">//看当前位置值是否比父亲小，如果小，就把父亲过滤下来</span></span><br><span class="line">        <span class="keyword">if</span>(p.w&lt;Heap[i/<span class="number">2</span>].w)Heap[i]=Heap[i/<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        i/=<span class="number">2</span>;<span class="comment">//往上走一层</span></span><br><span class="line">    &#125;</span><br><span class="line">    Heap[i]=p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大顶堆</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">insertHeap</span><span class="params">(<span class="type">int</span> data,<span class="type">long</span> <span class="type">long</span> w)</span>&#123;</span><br><span class="line">    Edge p = &#123;data,w&#125;;</span><br><span class="line">    size++;</span><br><span class="line">    <span class="type">int</span> i=size;</span><br><span class="line">    <span class="keyword">while</span>(i&gt;=<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="comment">//看当前位置是否比父亲大，如果大，就把父亲过滤下来</span></span><br><span class="line">        <span class="keyword">if</span>(p.w&gt;Heap[i/<span class="number">2</span>].w)Heap[i]=Heap[i/<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        i/=<span class="number">2</span>;<span class="comment">//往上走一层</span></span><br><span class="line">    &#125;</span><br><span class="line">    Heap[i]=p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>堆的删除，返回堆顶元素，删除堆顶之后，把末尾元素放到堆顶，然后自顶向下更新，向上过滤</p>
<p>小顶堆</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Edge <span class="title function_">deleteHeap</span><span class="params">()</span>&#123;</span><br><span class="line">    Edge res = Heap[<span class="number">1</span>];<span class="comment">//先保存返回值</span></span><br><span class="line">    Heap[<span class="number">1</span>]=Heap[size--];<span class="comment">//把末尾元素放到堆顶</span></span><br><span class="line">    <span class="type">int</span> i=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=size)&#123;</span><br><span class="line">        <span class="comment">//寻找这一层左右两个点中较小的值</span></span><br><span class="line">        <span class="keyword">if</span>(i+<span class="number">1</span>&lt;=size&amp;&amp;Heap[i].w&gt;Heap[i+<span class="number">1</span>].w)i++;</span><br><span class="line">        <span class="comment">//看当前位置是否比父亲小，如果小，就交换位置</span></span><br><span class="line">        <span class="keyword">if</span>(Heap[i].w&lt;Heap[i/<span class="number">2</span>].w)&#123;</span><br><span class="line">            Edge tmp = Heap[i];</span><br><span class="line">            Heap[i]=Heap[i/<span class="number">2</span>];</span><br><span class="line">            Heap[i/<span class="number">2</span>]=tmp;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        i*=<span class="number">2</span>;<span class="comment">//往下走一层</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大顶堆</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Edge <span class="title function_">deleteHeap</span><span class="params">()</span>&#123;</span><br><span class="line">    Edge res = Heap[<span class="number">1</span>];<span class="comment">//先保存返回值</span></span><br><span class="line">    Heap[<span class="number">1</span>]=Heap[size--];<span class="comment">//把末尾元素放到堆顶</span></span><br><span class="line">    <span class="type">int</span> i=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=size)&#123;</span><br><span class="line">        <span class="comment">//寻找这一层左右两个点中较大的值</span></span><br><span class="line">        <span class="keyword">if</span>(i+<span class="number">1</span>&lt;=size&amp;&amp;Heap[i].w&lt;Heap[i+<span class="number">1</span>].w)i++;</span><br><span class="line">        <span class="comment">//看当前位置是否比父亲大，如果大，就交换位置</span></span><br><span class="line">        <span class="keyword">if</span>(Heap[i].w&gt;Heap[i/<span class="number">2</span>].w)&#123;</span><br><span class="line">            Edge tmp = Heap[i];</span><br><span class="line">            Heap[i]=Heap[i/<span class="number">2</span>];</span><br><span class="line">            Heap[i/<span class="number">2</span>]=tmp;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        i*=<span class="number">2</span>;<span class="comment">//往下走一层</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="最短路">最短路</h2>
<h3 id="Dijkstra">Dijkstra</h3>
<p>可以有向图，无向图，但是不能有负权值</p>
<p>单源最短路径，给定点<code>src</code>，到其它所有编号点的最短距离</p>
<p><code>final</code>数组表示当前哪些点的最短距离已经求过了，计算过了就设置为1</p>
<p>正常复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>V</mi><mn>2</mn></msup><mo>+</mo><mi>E</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(V^2+E)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mclose">)</span></span></span></span>，堆优化后为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>V</mi><mo>+</mo><mi>E</mi><mo stretchy="false">)</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>E</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O((V+E)logE)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">((</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mclose">)</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mclose">)</span></span></span></span></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="type">long</span> dis[<span class="number">100005</span>];<span class="comment">//src点到所有编号点的最短距离</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">dijkstra</span><span class="params">(<span class="type">int</span> src,<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="type">int</span> final[<span class="number">100005</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        final[i]=<span class="number">0</span>;</span><br><span class="line">        dis[i]=MAX;<span class="comment">//最开始到所有点的距离为无穷大</span></span><br><span class="line">    &#125;</span><br><span class="line">    final[src]=<span class="number">1</span>;</span><br><span class="line">    dis[src]=<span class="number">0</span>;<span class="comment">//加入源点</span></span><br><span class="line">    <span class="comment">//把源点所有连接的点加入到堆里面，提高返回最小距离的效率</span></span><br><span class="line">    <span class="keyword">for</span>(Nodeprt p = s[src];p!=<span class="literal">NULL</span>;p=p-&gt;link)&#123;</span><br><span class="line">        dis[p-&gt;data]=p-&gt;w;</span><br><span class="line">        insertHeap(p-&gt;data,p-&gt;w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(size!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//每次找到最短距离，并且得是没有加入到final的点</span></span><br><span class="line">        Edge p = deleteHeap();</span><br><span class="line">        <span class="type">int</span> k=p.data;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> w = p.w;</span><br><span class="line">        <span class="keyword">if</span>(final[k]==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//找到一个最短路径的点，就更新这个点所有相连的点，同样是加入堆</span></span><br><span class="line">            final[k]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(Nodeprt q=s[k];q!=<span class="literal">NULL</span>;q=q-&gt;link)&#123;</span><br><span class="line">                <span class="comment">//只要是相连的，并且没有加入到final的，都要考虑</span></span><br><span class="line">                <span class="keyword">if</span>(final[q-&gt;data]==<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">//加入堆之前先更新一下距离</span></span><br><span class="line">                    <span class="keyword">if</span>(dis[q-&gt;data]&gt;q-&gt;w+w)dis[q-&gt;data]=q-&gt;w+w;</span><br><span class="line">                    insertHeap(q-&gt;data,dis[q-&gt;data]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Floyed">Floyed</h3>
<p>无负权回路，正权都可以，求解任意两点之间的最短路径，有向图或者负权，传递闭包，复杂度<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>3</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p>
<p>适用于稠密图，快于V次Dijkstra</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="built_in">map</span>[<span class="number">1005</span>][<span class="number">1005</span>];</span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i==j)<span class="built_in">map</span>[i][j]=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">map</span>[i][j]=MAX;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输入所有边，对于i到j有边，就设置为对应权值</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Floyed</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=n;k++)&#123;<span class="comment">//选取中介点，从第一个点到最后一个点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">map</span>[i][j]&gt;<span class="built_in">map</span>[i][k]+<span class="built_in">map</span>[k][j])&#123;</span><br><span class="line">                    <span class="built_in">map</span>[i][j]=<span class="built_in">map</span>[i][k]+<span class="built_in">map</span>[k][j];</span><br><span class="line">                    path[i][j]=k;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Spfa">Spfa</h3>
<p>可以用来判断负环</p>
<p>首先入队列源点，然后出队，对于出队的点，更新所有与它有关的距离，如果距离被更新，并且被更新的点不在队列中，那就入队</p>
<p>这样每次从出队一个元素，更新所有距离，如果距离被更新，并且被更新的点不在队列，就入队</p>
<p>直到最终队列里面为空为结束</p>
<p>负环的判断：负环说明没有最短路径，如果一个点入队n次(n为节点总数量)那就说明存在负环</p>
<p>时间复杂度<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>V</mi><mi>E</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(VE)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mclose">)</span></span></span></span></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Edgeprt E[<span class="number">100005</span>];</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> dis[<span class="number">100005</span>];</span><br><span class="line"><span class="type">int</span> <span class="built_in">queue</span>[<span class="number">100005</span>];</span><br><span class="line"><span class="type">int</span> front = <span class="number">0</span>, rear = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Spfa</span><span class="params">(<span class="type">int</span> src, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> final[<span class="number">100005</span>];</span><br><span class="line">    <span class="type">int</span> cnt[<span class="number">5005</span>];<span class="comment">//记录每个节点入队的次数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        final[i] = <span class="number">0</span>;</span><br><span class="line">        dis[i] = MAX;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">queue</span>[rear++] = src;</span><br><span class="line">    cnt[src]++;</span><br><span class="line">    final[src] = <span class="number">1</span>;</span><br><span class="line">    dis[src] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (front != rear) &#123;</span><br><span class="line">        <span class="type">int</span> q = <span class="built_in">queue</span>[front++];</span><br><span class="line">        final[q] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Edgeprt p = E[q]; p != <span class="literal">NULL</span>; p = p-&gt;link) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;w + E[q]-&gt;w &lt; dis[p-&gt;data]) &#123;</span><br><span class="line">                dis[p-&gt;data] = p-&gt;w + E[q]-&gt;w;</span><br><span class="line">                <span class="keyword">if</span> (final[p-&gt;data] == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">queue</span>[rear++] = p-&gt;data;</span><br><span class="line">                    cnt[p-&gt;data]++;</span><br><span class="line">                    <span class="keyword">if</span> (cnt[p-&gt;data] &gt; n)<span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//入队次数过多，负环存在</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//到这说明正常运行，无负环</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="最小生成树">最小生成树</h2>
<h3 id="Prim">Prim</h3>
<p><code>final</code>数组记录加入到最小生成树的点</p>
<p>从一个点，每次找最近的点，最终把所有点加入到最小生成树</p>
<p>正常复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>V</mi><mn>2</mn></msup><mo>+</mo><mi>E</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(V^2+E)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mclose">)</span></span></span></span>，这里使用了堆优化复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>E</mi><mo>+</mo><mi>V</mi><mo stretchy="false">)</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>E</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O((E+V)logE)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">((</span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mclose">)</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mclose">)</span></span></span></span></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="type">long</span> <span class="title function_">prim</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> src)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> result = <span class="number">0</span>;<span class="comment">//最小生成树总权重，唯一，但是树的形状可能不唯一</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        final[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    final[src] = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//把源点相连的边都加入堆，方便后面返回最近的点</span></span><br><span class="line">    <span class="keyword">for</span> (Nodeprt p = s[src]; p != <span class="literal">NULL</span>; p = p-&gt;link) &#123;</span><br><span class="line">        insertHeap(p-&gt;data, p-&gt;weight);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (size != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//每次返回最短的距离的点</span></span><br><span class="line">        Edge p = deleteHeap();</span><br><span class="line">        <span class="type">int</span> k = p.data;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> w = p.weight;</span><br><span class="line">        <span class="keyword">if</span> (final[k] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//把这个最短距离加入到总权重中，将这个点加入最小生成树集合</span></span><br><span class="line">            result += w;</span><br><span class="line">            final[k] = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//对于这个点，把它所有相连的点加入到堆</span></span><br><span class="line">            <span class="keyword">for</span> (Nodeprt q = s[k]; q != <span class="literal">NULL</span>; q = q-&gt;link) &#123;</span><br><span class="line">                <span class="keyword">if</span> (final[q-&gt;data] == <span class="number">0</span>) &#123;</span><br><span class="line">                    insertHeap(q-&gt;data, q-&gt;weight);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Kruskal">Kruskal</h3>
<p>Kruskal算法不需要真正构建图，只需要把所有边都存起来就行，因此直接用结构体存储每条边</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> u;</span><br><span class="line">    <span class="type">int</span> v;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> w;</span><br><span class="line">&#125; Edge, *Edgeprt;</span><br><span class="line">Edge s[<span class="number">500005</span>];</span><br></pre></td></tr></table></figure>
<p>按照边的权重从小到大排序，然后依次考虑每条边，看能否加入最小生成树</p>
<p>加入的判断过程，就是看加入这条边是否会形成环，这里采用并查集判断</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> S[<span class="number">100005</span>];<span class="comment">//记录每个树的高度</span></span><br><span class="line"><span class="type">int</span> root[<span class="number">100005</span>];<span class="comment">//记录每个点的根</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Find</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root[x]&lt;<span class="number">0</span>)<span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> root[x]=Find(root[x]);<span class="comment">//路径压缩查找根</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Union</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span>&#123;</span><br><span class="line">    <span class="type">int</span> rootX = Find(x);</span><br><span class="line">    <span class="type">int</span> rootY = Find(y);</span><br><span class="line">    <span class="keyword">if</span>(rootX!=rootY)&#123;</span><br><span class="line">        <span class="keyword">if</span>(S[x]&gt;S[y])&#123;</span><br><span class="line">        	root[rootY]=rootX;</span><br><span class="line">    	&#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(S[x]&lt;S[y])&#123;</span><br><span class="line">            root[rootX]=rootY;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            root[rootY]=rootX;</span><br><span class="line">            S[x]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> <span class="title function_">Kruskal</span><span class="params">(<span class="type">int</span> m)</span>&#123;<span class="comment">//m为边的个数</span></span><br><span class="line">    qsort(s,m,<span class="keyword">sizeof</span>(s[<span class="number">0</span>]),cmp);<span class="comment">//cmp按照权重从小到大排序</span></span><br><span class="line">    <span class="type">int</span> u,v;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        u=s[i].u;v=s[i].v;</span><br><span class="line">        <span class="keyword">if</span>(Find(u)!=Find(v))&#123;<span class="comment">//加入这条边不会形成环</span></span><br><span class="line">            ans+=s[i].w;</span><br><span class="line">            Union(u,v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="拓扑排序Topo">拓扑排序Topo</h2>
<p>有向图，先插入边的时候记录一下每个点的入度</p>
<p>首先把所有入度为0的点加入，然后每次返回一个点，再把这个点所有连接的点的入度减一</p>
<p>直到最后所有点都在拓扑序列里，这里用了堆优化，可能同时有多个点入度为0，序号大的先输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> num[<span class="number">100005</span>];<span class="comment">//在插入边的时候记录一下每个点的入度(有向图)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Topo</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="comment">//先把所有入度为0的点加入到堆，因为这里要求字典序大的先输出，可能同时有多个点入度为0</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (num[i] == <span class="number">0</span>) &#123;</span><br><span class="line">			insertHeap(i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (size != <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="type">int</span> p = deleteHeap();</span><br><span class="line">		<span class="keyword">if</span> (p == <span class="number">-1</span>)<span class="keyword">break</span>;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, p);</span><br><span class="line">		<span class="keyword">for</span> (Nodeprt q = s[p]; q != <span class="literal">NULL</span>; q = q-&gt;link) &#123;</span><br><span class="line">			num[q-&gt;data]--;</span><br><span class="line">			<span class="keyword">if</span> (num[q-&gt;data] == <span class="number">0</span>) &#123;</span><br><span class="line">				insertHeap(q-&gt;data);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二分图匹配">二分图匹配</h2>
<h3 id="Hungary匈牙利算法-无权二分图最大匹配">Hungary匈牙利算法(无权二分图最大匹配)</h3>
<p><a href="%5B%E4%BA%8C%E5%88%86%E5%9B%BE%E5%8C%B9%E9%85%8D-%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95-CSDN%E5%8D%9A%E5%AE%A2%5D(https://blog.csdn.net/qq_39304630/article/details/108135381?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=%E4%BA%8C%E5%88%86%E5%9B%BE%E5%8C%B9%E9%85%8D&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-108135381.142%5Ev96%5Epc_search_result_base1&amp;spm=1018.2226.3001.4187)">参考教程</a></p>
<p>无权二分图最大匹配</p>
<p>最大匹配：让两个集合的点互相配对，同一个点最多只能和一个点配对，最多的配对数量</p>
<p>最小覆盖：求最少数量的点，删除包含这些点的边，能够删除二分图所有边，这些点的数量和最多配对数量一样</p>
<p><a href="https://so.csdn.net/so/search?q=%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95&amp;spm=1001.2101.3001.7020">匈牙利算法</a>是一个用于解决该类问题的标准算法之一，核心想法是&quot;让路&quot;：假设你当前想配对Bi与Gk，但是Gk已经有了对象Bj，此时就和Bj交涉能否让Bj尝试换一个对象，如果Bi能够换一个对象，就可以配对Bi与Gk；否则配对失败。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="built_in">map</span>[<span class="number">405</span>][<span class="number">405</span>];<span class="comment">//记录第一个集合的点到第二个集合的点是否有边</span></span><br><span class="line"><span class="type">int</span> mate[<span class="number">405</span>];<span class="comment">//第二个集合的点对应的配对第一个集合的点的编号</span></span><br><span class="line"><span class="type">int</span> visit[<span class="number">405</span>];<span class="comment">//第二个集合的某个点是否访问过</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">match</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">map</span>[x][i]&amp;&amp;!visit[i])&#123;</span><br><span class="line">            visit[i]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(!mate[i]||match(mate[i],n))&#123;</span><br><span class="line">                mate[i]=x;<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Hungary</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;<span class="comment">//依次对第一个集合的所有点去匹配</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)visit[j]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(match(i,n))res++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="KM算法-带权二分图最大匹配">KM算法(带权二分图最大匹配)</h3>
<p>KM 算法是用于求带权二分图的最优匹配的算法，其时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>4</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^4)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p>
<p>1.首先选择顶点数较少的为 X 部（左点集），初始时对 X 部的每一个顶点设置顶标，顶标的值为该点关联的最大边的权值，Y 部（右点集）的顶点顶标为 0。</p>
<p>2.对于 X 部中的每个顶点，在相等子图中利用匈牙利算法找一条增广路径，如果没有找到，则修改顶标，扩大相等子图(边权等于两个顶点顶标的和的边组成的图)，继续找增广路径。</p>
<p>3.当 X 部的每个点都找到增广路径时，此时意味着每个点都在匹配中，即找到了该二分图的完全匹配。该完全匹配即为二分图的最优匹配。</p>
<p>ps: map[i][j]设置为对应的权值，如果不存在边就设置为<code>-MAX</code></p>
<p>最小权就先把所有取负值，最后结果加上负号就行</p>
<p>这个稍微好理解一点，把顶标改成期望值</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX 1e15</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> max(a, b) a&gt;b?a:b</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> min(a, b) a&gt;b?b:a</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">point</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125; Point, *Pointprt;</span><br><span class="line">Point A[<span class="number">520</span>], B[<span class="number">520</span>];</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> <span class="built_in">map</span>[<span class="number">520</span>][<span class="number">520</span>];<span class="comment">//记录每条边的权</span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> Lx[<span class="number">520</span>], Ly[<span class="number">520</span>];<span class="comment">//左右顶点的顶标</span></span><br><span class="line"><span class="type">int</span> visX[<span class="number">520</span>], visY[<span class="number">520</span>];</span><br><span class="line"><span class="type">int</span> match[<span class="number">520</span>];<span class="comment">//记录右侧顶点匹配的左侧顶点标号</span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> slack[<span class="number">520</span>];<span class="comment">//边权和顶标的最小差值</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">DFS</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> m)</span> &#123;</span><br><span class="line">    visX[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;<span class="comment">//遍历右侧顶点</span></span><br><span class="line">        <span class="keyword">if</span> (visY[i] == <span class="number">0</span>) &#123;<span class="comment">//右侧这个点没访问过,并且存在路径</span></span><br><span class="line">            <span class="keyword">if</span> (Lx[x] + Ly[i] - <span class="built_in">map</span>[x][i] == <span class="number">0</span>) &#123;<span class="comment">//不在交替路中</span></span><br><span class="line">                visY[i] = <span class="number">1</span>;<span class="comment">//加入交替路</span></span><br><span class="line">                <span class="keyword">if</span> (match[i] == <span class="number">0</span> || DFS(match[i], m) == <span class="number">1</span>) &#123;<span class="comment">//如果这个点没匹配，或者能为匹配过的点更换目标</span></span><br><span class="line">                    match[i] = x;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> slack[i] = min(slack[i], Lx[x] + Ly[i] - <span class="built_in">map</span>[x][i]);</span><br><span class="line">            <span class="comment">//slack[i]存储的是右侧的点需要变成相等子图顶标值最小增加多少</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//无法匹配</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> <span class="title function_">KM</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span> &#123;<span class="comment">//m是右侧顶点数量，n是左侧顶点数量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)Lx[i] = -MAX;<span class="comment">//x顶标要为最大权重</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)Ly[i] = <span class="number">0</span>;<span class="comment">//y顶标为0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)match[i] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            Lx[i] = max(Lx[i], <span class="built_in">map</span>[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)slack[j] = MAX;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) visX[j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)visY[j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (DFS(i, n) == <span class="number">1</span>)<span class="keyword">break</span>;</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> d = MAX;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!visY[j])d = min(d, slack[j]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;<span class="comment">//左侧顶标减去</span></span><br><span class="line">                <span class="keyword">if</span> (visX[j])Lx[j] -= d;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j&lt;= m; j++) &#123;<span class="comment">//右侧顶标加上</span></span><br><span class="line">                <span class="keyword">if</span> (visY[j])Ly[j] += d;</span><br><span class="line">                <span class="keyword">else</span> slack[j] -= d;</span><br><span class="line">                <span class="comment">//修改顶标后，把所有不在交错树中的右侧顶点的slack值减去Min</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (match[i] != <span class="number">0</span>) &#123;<span class="comment">//存在边</span></span><br><span class="line">            ans += <span class="built_in">map</span>[match[i]][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>优化<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>3</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，看不懂copy的模板思密达</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX 1e15</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pi 4000000000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> max(a, b) a&gt;b?a:b</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> min(a, b) a&gt;b?b:a</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">point</span> &#123;</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> x;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> y;</span><br><span class="line">&#125; Point, *Pointprt;</span><br><span class="line">Point A[<span class="number">520</span>], B[<span class="number">520</span>];</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> <span class="built_in">map</span>[<span class="number">520</span>][<span class="number">520</span>];<span class="comment">//记录每条边的权</span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> Lx[<span class="number">520</span>], Ly[<span class="number">520</span>];<span class="comment">//左右顶点的顶标</span></span><br><span class="line"><span class="type">int</span> visX[<span class="number">520</span>], visY[<span class="number">520</span>];</span><br><span class="line"><span class="type">int</span> match[<span class="number">520</span>];<span class="comment">//记录右侧顶点匹配的左侧顶点标号</span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> slack[<span class="number">520</span>];<span class="comment">//边权和顶标的最小差值</span></span><br><span class="line"><span class="type">int</span> pre[<span class="number">520</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">BFS</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> m)</span> &#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>, yy = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        pre[i] = <span class="number">0</span>;</span><br><span class="line">        slack[i] = MAX;</span><br><span class="line">    &#125;</span><br><span class="line">    match[<span class="number">0</span>] = p;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> d = MAX;</span><br><span class="line">        x = match[y];</span><br><span class="line">        visY[y] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visY[i])<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (slack[i] &gt; Lx[x] + Ly[i] - <span class="built_in">map</span>[x][i]) &#123;</span><br><span class="line">                slack[i] = Lx[x] + Ly[i] - <span class="built_in">map</span>[x][i];</span><br><span class="line">                pre[i] = y;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (slack[i] &lt; d) &#123;</span><br><span class="line">                d = slack[i];</span><br><span class="line">                yy = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visY[i]) &#123;</span><br><span class="line">                Lx[match[i]] -= d;</span><br><span class="line">                Ly[i] += d;</span><br><span class="line">            &#125; <span class="keyword">else</span> slack[i] -= d;</span><br><span class="line">        &#125;</span><br><span class="line">        y = yy;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">while</span> (match[y]);</span><br><span class="line">    <span class="keyword">while</span> (y) &#123;</span><br><span class="line">        match[y] = match[pre[y]];</span><br><span class="line">        y = pre[y];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> <span class="title function_">KM</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span> &#123;<span class="comment">//m是右侧顶点数量，n是左侧顶点数量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)Lx[i] = -MAX;<span class="comment">//x顶标要为最大权重</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)Ly[i] = <span class="number">0</span>;<span class="comment">//y顶标为0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)match[i] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            visY[j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        BFS(i, m);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (match[i] != <span class="number">0</span>) &#123;<span class="comment">//存在边</span></span><br><span class="line">            ans += <span class="built_in">map</span>[match[i]][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="最大流问题">最大流问题</h2>
<p>给定n个点，m条边，有向图，求s到t的最大流量，允许重边和自环，自环直接忽略，重边进行合并</p>
<p>使用Dinic算法，每次通过BFS寻找是否存在增广路径，然后通过DFS进行增广</p>
<p>使用邻接表存储，每次插入一条边时，都需要插入一条其反向的，流量为0的边</p>
<p>cur数组记录之前BFS到的位置，避免每次确认是否还有增广路径的时候的重复寻找，提升效率</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">BFS</span><span class="params">(<span class="type">int</span> s,<span class="type">int</span> t)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">1000</span>;i++)&#123;</span><br><span class="line">        depth[i]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    front = rear = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">queue</span>[rear++]=s;</span><br><span class="line">    depth[s]=<span class="number">1</span>;</span><br><span class="line">    cur[s] = E[s];</span><br><span class="line">    <span class="keyword">while</span>(front!=rear)&#123;</span><br><span class="line">        s = <span class="built_in">queue</span>[front++];</span><br><span class="line">        <span class="keyword">for</span>(Edgeprt p = cur[s];p!=<span class="literal">NULL</span>;p=p-&gt;link)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;flow&gt;<span class="number">0</span>&amp;&amp;depth[p-&gt;data]==<span class="number">0</span>)&#123;<span class="comment">//这条边还可以有流量，并且没有访问过</span></span><br><span class="line">                depth[p-&gt;data]=depth[s]+<span class="number">1</span>;</span><br><span class="line">                cur[p-&gt;data] = E[p-&gt;data];</span><br><span class="line">                <span class="keyword">if</span>(p-&gt;data==t)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                <span class="built_in">queue</span>[rear++]=p-&gt;data;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> <span class="title function_">DFS</span><span class="params">(<span class="type">int</span> s,<span class="type">long</span> <span class="type">long</span> flow,<span class="type">int</span> t)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s==t||flow&lt;=<span class="number">0</span>)<span class="keyword">return</span> flow;<span class="comment">//找到t就返回此时增广路径的流量</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> rest = flow;</span><br><span class="line">    <span class="keyword">for</span>(Edgeprt p = cur[s];p!=<span class="literal">NULL</span>;p=p-&gt;link)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;flow &gt; <span class="number">0</span> &amp;&amp; depth[p-&gt;data] ==depth[s]+<span class="number">1</span>)&#123;<span class="comment">//由深度和流量不为0确认是增广路径</span></span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> tmp = DFS(p-&gt;data,min(rest,p-&gt;flow),t);<span class="comment">//对下一个节点寻找增广路径，流量取最小</span></span><br><span class="line">            <span class="keyword">if</span>(tmp&lt;=<span class="number">0</span>)depth[p-&gt;data]=<span class="number">0</span>;<span class="comment">//tmp小于等于0为阻塞路径，也就是对之前的增广进行反悔</span></span><br><span class="line">            rest-=tmp;</span><br><span class="line">            p-&gt;flow-=tmp;</span><br><span class="line">            p-&gt;rev-&gt;flow+=tmp;</span><br><span class="line">            <span class="keyword">if</span>(rest&lt;=<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flow-rest;<span class="comment">//剩余流量减去增广之后的剩余流量，就是此次增广的流量</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> <span class="title function_">Dinic</span><span class="params">(<span class="type">int</span> s,<span class="type">int</span> t)</span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(BFS(s,t))&#123;</span><br><span class="line">        ans+=DFS(s,MAX,t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title>FFT快速傅里叶变换</title>
    <url>/2023/11/27/FFT%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/</url>
    <content><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/347091298">FFT参考文章1</a></p>
<p><a href="https://oi-wiki.org/math/poly/fft/">FFT参考文章2</a></p>
<p>快速傅里叶变换实现将两个多项式的乘法从<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>时间复杂度降低到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p>
<p>主要思想为分治，实现为DFT(离散傅里叶变换)和IDFT(离散傅里叶逆变换)，将多项式的系数表达式和点值表达式建立联系</p>
<h2 id="递归实现">递归实现</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> max(a, b) a&gt;b?a:b</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX 1&lt;&lt;22</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> eps 1e-6</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pi acos(-1.0)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">complex</span> &#123;</span></span><br><span class="line">	<span class="type">double</span> x;</span><br><span class="line">	<span class="type">double</span> y;</span><br><span class="line">&#125; Complex, *Complexprt;</span><br><span class="line">Complex a[MAX], b[MAX];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">mulComplex</span><span class="params">(Complexprt w1, Complexprt w2)</span> &#123;<span class="comment">//两个复数相乘给第一个数</span></span><br><span class="line">	<span class="comment">//(x+iy)*(x&#x27;+iy&#x27;) = x*x&#x27;-y*y&#x27;+i(xy&#x27;+yx&#x27;)</span></span><br><span class="line">	<span class="type">double</span> x = w1-&gt;x * w2-&gt;x - w1-&gt;y * w2-&gt;y;</span><br><span class="line">	<span class="type">double</span> y = w1-&gt;x * w2-&gt;y + w1-&gt;y * w2-&gt;x;</span><br><span class="line">	w1-&gt;x = x;</span><br><span class="line">	w1-&gt;y = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">FFT</span><span class="params">(Complex a[], <span class="type">int</span> n, <span class="type">int</span> inv)</span> &#123;<span class="comment">//inv为虚部符号，inv=1为FFT，inv=-1为IFFT</span></span><br><span class="line">	<span class="keyword">if</span> (n == <span class="number">1</span>) &#123;<span class="comment">//只有一项就返回</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> mid = n / <span class="number">2</span>;</span><br><span class="line">	Complex A1[mid + <span class="number">1</span>];</span><br><span class="line">	Complex A2[mid + <span class="number">1</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i += <span class="number">2</span>) &#123;<span class="comment">//多项式拆分</span></span><br><span class="line">		A1[i / <span class="number">2</span>] = a[i];</span><br><span class="line">		A2[i / <span class="number">2</span>] = a[i + <span class="number">1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	FFT(A1, mid, inv);</span><br><span class="line">	FFT(A2, mid, inv);<span class="comment">//求解子多项式</span></span><br><span class="line">	Complex w0 = (Complex) &#123;</span><br><span class="line">		<span class="number">1</span>, <span class="number">0</span></span><br><span class="line">	&#125;;</span><br><span class="line">	Complex wn = (Complex) &#123;</span><br><span class="line">		<span class="built_in">cos</span>(<span class="number">2</span> * pi / n), inv * <span class="built_in">sin</span>(<span class="number">2</span> * pi / n)</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; mid; i++, mulComplex(&amp;w0, &amp;wn)) &#123;</span><br><span class="line">		<span class="comment">//a[i] = A1[i] + w0 * A2[i];</span></span><br><span class="line">		a[i].x = A1[i].x + w0.x * A2[i].x - w0.y * A2[i].y;</span><br><span class="line">		a[i].y = A1[i].y + w0.x * A2[i].y + w0.y * A2[i].x;</span><br><span class="line">		<span class="comment">//a[i + n/2] = A1[i] -w0 * A2[i]</span></span><br><span class="line">		a[i + n / <span class="number">2</span>].x = A1[i].x - w0.x * A2[i].x + w0.y * A2[i].y;</span><br><span class="line">		a[i + n / <span class="number">2</span>].y = A1[i].y - w0.x * A2[i].y - w0.y * A2[i].x;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="comment">//freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line">	<span class="comment">//freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line">	<span class="type">int</span> n, m;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;<span class="comment">//输入第一个系数多项式</span></span><br><span class="line">		<span class="type">double</span> x;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>, &amp;x);</span><br><span class="line">		a[i].x = x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;<span class="comment">//输入第二个系数多项式</span></span><br><span class="line">		<span class="type">double</span> x;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>, &amp;x);</span><br><span class="line">		b[i].x = x;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//ceil为向上取整</span></span><br><span class="line">	<span class="type">int</span> len = max(<span class="number">1</span>, (<span class="type">int</span>) <span class="built_in">ceil</span>(log2(n + m)));<span class="comment">//FFT需要项数为2的整数次幂，所以多项式次数len为第一个大于n+m的2的整数次幂</span></span><br><span class="line">	len = <span class="number">1</span> &lt;&lt; len;</span><br><span class="line">	FFT(a, len, <span class="number">1</span>);<span class="comment">//系数表达式转点值表达式</span></span><br><span class="line">	FFT(b, len, <span class="number">1</span>);<span class="comment">//系数表达式转点值表达式</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= len; i++) &#123;<span class="comment">//O(n)乘法</span></span><br><span class="line">		mulComplex(&amp;a[i], &amp;b[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	FFT(a, len, <span class="number">-1</span>);<span class="comment">//点值表达式转系数表达式，逆变换之后需要除以n才是系数</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n + m - <span class="number">1</span>; i++) &#123; <span class="comment">//最高n+m-2次幂</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%.0f &quot;</span>, a[i].x / len + eps);<span class="comment">//输出系数除以n</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="迭代实现">迭代实现</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> eps 1e-7</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pi acos(-1.0)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">double</span> ld;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">complex</span> &#123;</span></span><br><span class="line">    <span class="type">double</span> x;</span><br><span class="line">    <span class="type">double</span> y;</span><br><span class="line">&#125; Complex, *Complexprt;</span><br><span class="line">Complex a[<span class="number">4000005</span>], b[<span class="number">4000005</span>];</span><br><span class="line"><span class="type">char</span> A[<span class="number">1000005</span>], B[<span class="number">1000005</span>];</span><br><span class="line"><span class="type">int</span> rev[<span class="number">4000005</span>];</span><br><span class="line"><span class="type">int</span> ans[<span class="number">4000005</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">mulComplex</span><span class="params">(Complexprt w1, Complexprt w2)</span> &#123;<span class="comment">//两个复数相乘给第一个数</span></span><br><span class="line">    <span class="comment">//(x+iy)*(x&#x27;+iy&#x27;) = x*x&#x27;-y*y&#x27;+i(xy&#x27;+yx&#x27;)</span></span><br><span class="line">    <span class="type">double</span> x = w1-&gt;x * w2-&gt;x - w1-&gt;y * w2-&gt;y;</span><br><span class="line">    <span class="type">double</span> y = w1-&gt;x * w2-&gt;y + w1-&gt;y * w2-&gt;x;</span><br><span class="line">    w1-&gt;x = x;</span><br><span class="line">    w1-&gt;y = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(Complex *a, Complex *b)</span> &#123;</span><br><span class="line">    Complex p = *a;</span><br><span class="line">    a-&gt;x = b-&gt;x;</span><br><span class="line">    a-&gt;y = b-&gt;y;</span><br><span class="line">    b-&gt;x = p.x;</span><br><span class="line">    b-&gt;y = p.y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">FFT</span><span class="params">(Complex a[], <span class="type">int</span> n, <span class="type">int</span> inv)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; rev[i])swap(&amp;a[i], &amp;a[rev[i]]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> h = <span class="number">1</span>; h &lt; n; h &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">        Complex wn = (Complex) &#123;</span><br><span class="line">                <span class="built_in">cos</span>(pi / h), inv * <span class="built_in">sin</span>(pi / h)</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j += h &lt;&lt; <span class="number">1</span>) &#123;</span><br><span class="line">            Complex w0 = (Complex) &#123;</span><br><span class="line">                    <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = j; k &lt; j + h; k++) &#123;</span><br><span class="line">                Complex x = a[k];</span><br><span class="line">                Complex y = (Complex) &#123;w0.x * a[k + h].x - w0.y * a[k + h].y, w0.x * a[k + h].y + w0.y * a[k + h].x&#125;;</span><br><span class="line">                a[k] = (Complex) &#123;x.x + y.x, x.y + y.y&#125;;</span><br><span class="line">                a[k + h] = (Complex) &#123;x.x - y.x, x.y - y.y&#125;;</span><br><span class="line">                mulComplex(&amp;w0, &amp;wn);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (inv == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            a[i].x = a[i].x / n + eps;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> len = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (len &lt; n + m - <span class="number">1</span>) &#123;<span class="comment">//len是项数,n,m也是项数</span></span><br><span class="line">            len &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">            l++;<span class="comment">//l是幂次</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            rev[i] = (rev[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (l - <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    FFT(a,len,<span class="number">1</span>);</span><br><span class="line">    FFT(b,len,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            mulComplex(&amp;a[i], &amp;b[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    FFT(a, len, <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>KMP</title>
    <url>/2023/12/02/KMP/</url>
    <content><![CDATA[<h2 id="KMP">KMP</h2>
<p><code>getNext()</code>函数，分析T数组自身的前后缀匹配的性质，计算出T数组的回溯位置</p>
<p>next[i]表中记录的是字符串中的每个子串的最大相等前后缀的长度</p>
<p>以<code>aabaaf</code>为例子</p>
<p>第一个子串是t0=“a”，易知该子串没有前缀也没有后缀，故next[0]=0<br>
第二个子串是t1=“aa”，该子串的前缀为&quot;a&quot;，后缀也为&quot;a&quot;，故next[1]=1<br>
第三个子串是t2=“aab”，该子串的后缀中一定会有&quot;b&quot;，前缀中一定不含有&quot;b&quot;，则其没有相等的前后缀，故next[2]=0<br>
第四个子串是t3=“aaba”，该子串的最大相等前后缀为&quot;a&quot;，长度为1，故next[3]=1<br>
第五个子串是t4=“aabaa”，该子串的最大相等前后缀为&quot;aa&quot;，长度为2，故next[4]=2<br>
第六个子串是t5=“aabaaf”，该子串的后缀中一定会有&quot;f&quot;，前缀中一定不含有&quot;f&quot;，则其没有相等的前后缀，故next[5]=0</p>
<table>
<thead>
<tr>
<th>j</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
</tr>
</thead>
<tbody>
<tr>
<td>T</td>
<td>a</td>
<td>a</td>
<td>b</td>
<td>a</td>
<td>a</td>
<td>f</td>
</tr>
<tr>
<td>next</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>0</td>
</tr>
</tbody>
</table>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">getnext</span><span class="params">(<span class="type">char</span> T[], <span class="type">int</span> next[])</span> &#123;</span><br><span class="line">	<span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">	next[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> len = <span class="built_in">strlen</span>(T);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">		<span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; T[i] != T[j])j = next[j - <span class="number">1</span>];</span><br><span class="line">		<span class="keyword">if</span> (T[i] == T[j])j++;</span><br><span class="line">		next[i] = j;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; Source.length(); i++) &#123;</span><br><span class="line">			<span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; S[i] != T[j])j = next[j - <span class="number">1</span>];</span><br><span class="line">			<span class="keyword">if</span> (S[i] == T[j])j++;</span><br><span class="line">			<span class="keyword">if</span> (j == len2) &#123;<span class="comment">//匹配到了一个，自己决定写些啥</span></span><br><span class="line">				cnt++;</span><br><span class="line">				j = next[j - <span class="number">1</span>];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<h2 id="有限自动机">有限自动机</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> lenT length(T)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> conNum 26</span></span><br><span class="line"><span class="type">int</span> dp[lenT][conNum];</span><br><span class="line"><span class="type">void</span> <span class="title function_">FSM</span><span class="params">(<span class="type">char</span> T[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(T);</span><br><span class="line">    dp[<span class="number">0</span>][T[<span class="number">0</span>] - <span class="string">&#x27;a&#x27;</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> c = <span class="number">0</span>; c &lt; conNum; c++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (T[j] - <span class="string">&#x27;a&#x27;</span> == c)dp[j][c] = j + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> dp[j][c] = dp[x][c];</span><br><span class="line">        &#125;</span><br><span class="line">        x = dp[x][T[j] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">char</span> S[],<span class="type">int</span> lenT)</span>&#123;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(S);</span><br><span class="line">    <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len;i++)&#123;</span><br><span class="line">        j = dp[j][S[i]-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        <span class="keyword">if</span>(j==lenT)<span class="keyword">return</span> i-j+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
</search>
