<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>正则表达式</title>
      <link href="/2023/10/10/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2023/10/10/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>正则表达式是一种用于匹配和操作文本的强大工具，它是由一系列字符和特殊字符组成的模式，用于描述要匹配的文本模式。</p><p>正则表达式可以在文本中查找、替换、提取和验证特定的模式。</p><p>例如：</p><ul><li><strong>runoo+b</strong>，可以匹配 <strong>runoob、runooob、runoooooob</strong> 等，<strong>+</strong> 号代表前面的字符必须至少出现一次（1次或多次）<a href="https://www.runoob.com/try/try-regex.php?texts=runoob%7Crunooob%7Crunoooooob&amp;tips=runoo%2Bb"><strong>尝试一下 »</strong></a>。</li><li><strong>runoo*b</strong>，可以匹配 <strong>runob、runoob、runoooooob</strong> 等，***** 号代表前面的字符可以不出现，也可以出现一次或者多次（0次、或1次、或多次）<a href="https://www.runoob.com/try/try-regex.php?texts=runoob%7Crunooob%7Crunoooooob&amp;tips=runoo*b"><strong>尝试一下 »</strong></a>。</li><li><strong>colou?r</strong> 可以匹配 <strong>color</strong> 或者 <strong>colour</strong>，<strong>?</strong> 问号代表前面的字符最多只可以出现一次（0次或1次）<a href="https://www.runoob.com/try/try-regex.php?texts=color%7Ccolour%7Ccolour123&amp;tips=colou%3Fr"><strong>尝试一下 »</strong></a>。</li></ul><p>构造正则表达式的方法和创建数学表达式的方法一样。也就是用多种元字符与运算符可以将小的表达式结合在一起来创建更大的表达式。正则表达式的组件可以是单个的字符、字符集合、字符范围、字符间的选择或者所有这些组件的任意组合。</p><p>正则表达式是由普通字符（例如字符 a 到 z）以及特殊字符（称为&quot;元字符&quot;）组成的文字模式。模式描述在搜索文本时要匹配的一个或多个字符串。正则表达式作为一个模板，将某个字符模式与所搜索的字符串进行匹配。</p><h3 id="普通字符">普通字符</h3><p>所有大写和小写字母、所有数字、所有标点符号和一些其他符号。</p><ul><li><code>[ABC]</code>，匹配<code>[. . .]</code>中的所有字符，比如<code>[soy]</code>匹配<code>sssdiobfyyy</code>中的所有<code>s, o, y</code></li><li><code>[^ABC]</code>，匹配除了<code>[. . .]</code>中的所有字符，比如<code>[soy]</code>匹配<code>sssdiobfyyy</code>中的<code>d i o b f</code></li><li><code>[A-Z]</code>表示匹配所有大写字母，<code>[a-z]</code>表示匹配所有小写字母</li><li><code>.</code>匹配除了换行符<code>\n, \r</code>外的任何单个字符</li><li><code>[\s\S]</code>匹配所有，<code>\s</code>匹配所有空白符，包括换行，<code>\S</code>非空白符，不包括换行</li><li><code>\w</code>匹配字母，数字，下划线，等价于<code>[A-Za-z0-9_]</code></li></ul><h3 id="非打印字符">非打印字符</h3><p><code>\cx, \f, \n, \r, \s, \S, \t, \v</code></p><h3 id="特殊字符">特殊字符</h3><table><thead><tr><th style="text-align:left">特别字符</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">$</td><td style="text-align:left">匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 <code>\n</code> 或<code>\r</code>。要匹配 $ 字符本身，请使用 <code>\$</code>。</td></tr><tr><td style="text-align:left">( )</td><td style="text-align:left">标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用<code>\(</code>和<code> \)</code>。</td></tr><tr><td style="text-align:left">*</td><td style="text-align:left">匹配前面的子表达式零次或多次。要匹配 <code>*</code> 字符，请使用<code> \*</code>。</td></tr><tr><td style="text-align:left">+</td><td style="text-align:left">匹配前面的子表达式一次或多次。要匹配 <code>+</code> 字符，请使用<code> \+</code>。</td></tr><tr><td style="text-align:left">.</td><td style="text-align:left">匹配除换行符 \n 之外的任何单字符。要匹配<code> .</code> ，请使用<code> \.</code> 。</td></tr><tr><td style="text-align:left">[</td><td style="text-align:left">标记一个中括号表达式的开始。要匹配 [，请使用<code> \[</code>。</td></tr><tr><td style="text-align:left">?</td><td style="text-align:left">匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。要匹配 ? 字符，请使用<code> \?</code>。</td></tr><tr><td style="text-align:left">\</td><td style="text-align:left">将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如，<code>n</code> 匹配字符 <code>n</code>。<code>\n</code> 匹配换行符。序列 <code>\\</code> 匹配<code>\</code>，而<code>\(</code> 则匹配 <code>(</code>。</td></tr><tr><td style="text-align:left">^</td><td style="text-align:left">匹配输入字符串的开始位置，除非在方括号表达式中使用，当该符号在方括号表达式中使用时，表示不接受该方括号表达式中的字符集合。要匹配 ^ 字符本身，请使用<code>\^</code>。</td></tr><tr><td style="text-align:left">{</td><td style="text-align:left">标记限定符表达式的开始。要匹配 {，请使用<code>\&#123;</code>。</td></tr><tr><td style="text-align:left">|</td><td style="text-align:left">指明两项之间的一个选择。要匹配 |，请使用<code> |</code>。</td></tr></tbody></table><h3 id="限定符">限定符</h3><ul><li><code>*</code>等价于{0,}</li><li><code>+</code>等价于{1,}</li><li><code>?</code>等价于{0,1}</li><li><code>&#123;n&#125;</code>，n是非负整数，表示匹配次数</li><li><code>&#123;n,&#125;</code>，n是非负整数，表示至少的匹配次数</li><li><code>&#123;n,m&#125;</code>，n，m是非负整数，表示至少n次，最多m次</li><li>注意这些逗号之间不能添加空格</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 正则表达式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>soy的贪吃蛇</title>
      <link href="/2023/09/10/soy%E7%9A%84%E8%B4%AA%E5%90%83%E8%9B%87/"/>
      <url>/2023/09/10/soy%E7%9A%84%E8%B4%AA%E5%90%83%E8%9B%87/</url>
      
        <content type="html"><![CDATA[<p><a href="https://soybeanlittlecar.oss-cn-beijing.aliyuncs.com/blog/pygame-snake/source%20code.zip">源码下载</a></p><p><a href="https://soybeanlittlecar.oss-cn-beijing.aliyuncs.com/blog/pygame-snake/main.exe">可执行文件/贪吃蛇exe文件下载</a></p><p>源文件打包方法如下：</p><p>下载源文件并解压，在解压文件的同级目录下，就是在main.py的同级目录，打开cmd窗口，输入以下指令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyinstaller --onefile --add-data &quot;images;images&quot; main.py game_over.py game_page_run.py globals.py level_choose.py map_test.py mode_choose_page.py mode_items.py mode_random.py skin_set_page.py test_window_pause.py check_user.py data_base.py login_page.py ranking_table.py</span><br></pre></td></tr></table></figure><p>打包的前提是用户已经安装了<code>pyinstaller</code></p><p>在[python的官网](<a href="https://www.python.org/">Welcome to Python.org</a>)下载3.9版本以上的python，然后在命令行界面输入<code>pip install pyinstaller</code>即可下载</p><p>该项目在老师指导后，有了一些创新点，比如在迷宫模式设置ai追逐啥的，基于目前水平有限，并没有继续申优</p><p>项目也有很多的小问题，大概都是我目前的水平无法解决的，但是整体的框架应该没有大问题，后续学习了新的知识我会继续更新此项目的相关功能</p><p>基于python中pygame的局限性，此项目很多方面都为pygame所困，无法呈现出一个理想的效果，在此也不推荐大家使用pygame制作游戏，而是使用unity去制作更加好的游戏</p>]]></content>
      
      
      
        <tags>
            
            <tag> 小学期 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>explanation_of_snake</title>
      <link href="/2023/08/29/explanation-snake/"/>
      <url>/2023/08/29/explanation-snake/</url>
      
        <content type="html"><![CDATA[<h1>游戏模式</h1><p>游戏一共分为四个模式，无尽模式，关卡模式，特殊食物模式，道具模式</p><h2 id="无尽模式">无尽模式</h2><p>和经典的贪吃蛇一样，吃掉食物增加分数和速度，地图上会生成一些障碍物，障碍物的数量可以在模式选择里更改，最终会记录玩家获得的分数</p><h2 id="关卡模式">关卡模式</h2><p>一共有六个关卡，每一个关卡都是一个迷宫图，玩家需要吃掉一定数量的食物获得胜利，胜利后即可解锁下一个关卡，前五个关卡的地图是固定的，第六个地图是随机生成的，每次点击都会出现不同的地图，最后会记录玩家通关的时间</p><h2 id="特殊食物模式">特殊食物模式</h2><p>食物在生成后会被附上属性，当前屏幕上的食物的属性会在顶部导航栏显示</p><ul><li>加速食物：顶部出现5s的计时器，显示加速剩余时间</li><li>减速食物：顶部出现5s的计时器，显示减速剩余时间</li><li>消除障碍物食物：吃掉食物后，会随机消除一部分地图中的障碍物</li><li>生成障碍物食物：吃掉食物后，会随机生成一部分地图中的障碍物</li><li>高分食物：食物具有更高的分数，其额外分数不定，属于1~3</li></ul><h2 id="随机事件模式">随机事件模式</h2><p>在游戏运行过程中会发生随机事件，其中控制更改会在顶部出现计时器</p><ul><li>控制更改：顶部导航栏出现计时器，玩家的按键控制反向</li><li>障碍物重刷：障碍物会全部消失，然后重新生成相同数量的障碍物</li><li>障碍物消失：障碍物会全部消失</li><li>虚实食物：食物的出现又概率变成两个，一个真，一个假</li></ul><h1>登录系统</h1><p>玩家可以点击登录，输入自己的用户名和密码进行登录或者注册，从而可以将游戏数据同步到服务器</p><p>永久保存数据，登录系统在安全方面，找回密码方面并不完善</p><h1>警告</h1><p>游戏在各个模式下，有极小极小的可能性出现食物无法吃到的情况，虽然已经采用算法尽可能避免这种情况。倘若这种情况出现，请重新开始游戏</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pygame </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cpp-study</title>
      <link href="/2023/07/04/cpp-study/"/>
      <url>/2023/07/04/cpp-study/</url>
      
        <content type="html"><![CDATA[<p>c++学习过程中与c的比较（基于西北工业大学mooc）</p><span id="more"></span><h1>程序中数据的表示</h1><h2 id="数据类型">数据类型</h2><table><thead><tr><th><strong>long</strong></th><th><strong>4字节</strong></th><th></th></tr></thead><tbody><tr><td><strong>long double</strong></td><td><strong>增加了double的精度</strong></td><td></td></tr><tr><td><strong>bool</strong></td><td><strong>1字节</strong></td><td><strong>0或1</strong></td></tr></tbody></table><h2 id="常量与变量">常量与变量</h2><p>字面值（常量）：<code>112141</code>、<code>'A'</code>、<code>\x1234</code></p><p>以下说明均针对于字面值常量</p><p>八进制：0开头</p><p>十六进制：0x或者0X开头</p><p>浮点型常量默认double，如果要表示float要在末尾加上f或者F</p><p>字符：<code>\ooo</code>三位八进制数字表示字符</p><p><code>\xoo</code>两位十六进制数表示字符</p><p>const + 变量类型 + 变量名 = 数值，不可再次更改</p><h2 id="输入与输出">输入与输出</h2><p>cpp中主要采用<code>cin</code>和<code>cout</code>进行输入输出以及相关的格式控制，但是对于格式控制比较繁琐，可以使用<code>scanf</code>和<code>printf</code></p><h2 id="函数">函数</h2><h3 id="内联函数">内联函数</h3><p>cpp中可以在函数的声明前面加上<code>inline</code>，使得函数在编译过程中即成为内联函数，提升整体效率。</p><p>但是内联函数无法实现过于复杂的功能，因此规定内联函数内<strong>不使用循环语句和switch语句</strong></p><h3 id="函数的默认参数">函数的默认参数</h3><p>函数支持默认参数，为形参指定默认值，默认参数只能<strong>声明一次</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a=<span class="number">5</span>,<span class="type">int</span> b=<span class="number">6</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">add</span>(<span class="number">3</span>,<span class="number">4</span>);<span class="comment">//3+4</span></span><br><span class="line">    <span class="built_in">add</span>(<span class="number">4</span>);<span class="comment">//4+6</span></span><br><span class="line">    <span class="built_in">add</span>();<span class="comment">//5+6</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认参数自右向左设置，如果某一个参数设置了默认值，则<strong>它的右侧所有参数都必须有默认值</strong></p><p>默认值必须为常量或者全局变量或者他们构成的表达式或者函数</p><h3 id="函数重载">函数重载</h3><p>cpp支持函数重载，也就是允许在同一个域中使用多个相同函数名的函数，但是要求函数在参数<strong>类型或者个数中至少有一个不同</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">add</span><span class="params">(<span class="type">double</span> a,<span class="type">double</span> b)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="函数模板">函数模板</h2><p>根据上面的函数重载进行理解，就是把多个相同的函数，但是数据类型不同的用同一个函数模板表示</p><p>template&lt;模板形参表&gt;返回类型   函数名（函数参数）{}</p><p>模板形参表形式：typename 类型名1,typename 类型名2…(typename也可以用class表示，不过一般使用typename)非空</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> t,<span class="keyword">typename</span> f&gt;</span></span><br><span class="line"><span class="function">t <span class="title">add</span><span class="params">(t a,f b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">add</span>(<span class="number">5</span>,<span class="number">6.3</span>)&lt;&lt;endl;<span class="comment">//11</span></span><br><span class="line">    cout&lt;&lt;<span class="built_in">add</span>(<span class="number">6.3</span>,<span class="number">5</span>)&lt;&lt;endl;<span class="comment">//11.3</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>oo-java</title>
      <link href="/2023/06/27/oo-java/"/>
      <url>/2023/06/27/oo-java/</url>
      
        <content type="html"><![CDATA[<p>此文章为作者基于浙江大学mooc中的java基础和面向对象的相关学习而写，</p><p>参考书籍《Java编程思想》</p><p>一切内容均来自于个人，以下所谓“差异”，均比较与C语言</p><h1>Java基础</h1><p>Java中的大部分内容和c语言极其相似，以下列出一些不同点</p><h2 id="基本数据类型差异">基本数据类型差异</h2><table><thead><tr><th><strong>整数类型</strong></th><th><strong>byte</strong></th><th><strong>一个字节</strong></th></tr></thead><tbody><tr><td></td><td><strong>short</strong></td><td><strong>两个字节</strong></td></tr><tr><td></td><td><strong>int</strong></td><td><strong>四个字节</strong></td></tr><tr><td></td><td><strong>long</strong></td><td><strong>八个字节</strong></td></tr><tr><td><strong>浮点类型</strong></td><td><strong>float与double</strong></td><td><strong>四字节与八字节(同c语言)</strong></td></tr><tr><td><strong>字符类型</strong></td><td><strong>char</strong></td><td><strong>两个字节，‘\u0000’~‘\uffff’,支持汉字</strong></td></tr><tr><td><strong>布尔类型</strong></td><td><strong>boolean</strong></td><td><strong>一个字节，true  false</strong></td></tr></tbody></table><p>Java也具有<code>null</code>类型</p><h2 id="字面值常量差异">字面值常量差异</h2><p><code>0</code>开头表示八进制</p><p><code>0B/0b</code>表示二进制</p><p><code>0X/0x</code>表示十六进制</p><p>同时支持<code>_</code>分隔数字，便于分清数字位数（类似于python）</p><p>字面值常量整数默认为<code>int</code>，长整型<code>long</code>在数字末尾需要添加<code>L</code></p><p>字面值常量浮点数默认为<code>double</code>，浮点型<code>float</code>在数字末尾需要添加<code>F或f</code></p><p><code>boolean</code>为逻辑数字类型，只有<code>true和false</code>两种字面值，并且<strong>不对应于任何整数值1和0</strong>（这一点与c语言不同）</p><h2 id="变量声明差异">变量声明差异</h2><p>大部分和c语言一样，需要提前声明变量，并且需要进行初始化</p><p>java的变量如果不进行初始化，则会默认设为0或者false</p><p>Java11后支持局部变量类型推定，使用<code>var</code>进行声明变量，变量类型未定，根据上下文自动推定类型</p><h2 id="运算提醒">运算提醒</h2><p>与c语言相同，对于<code>&amp;&amp;</code>和<code>||</code>运算都具有“短路”现象，只有左操作数无法决定最终的值时才会计算右操作数</p><p><code>&gt;&gt;&gt;</code>代表无符号右移，高位补0</p><p><code>instanceof</code>测试某个对象是否为指定类的对象实例，返回boolean，类似于python</p><p>整数计算的时候默认为<code>int</code>型，即使所有参与运算的数据类型都低于<code>int</code>，除非有long，则上升类型为long</p><p>带有浮点数运算默认为<code>float</code>型，除非有double，则上升类型为double</p><h2 id="控制语句差异">控制语句差异</h2><p>除了c语言一样的控制语句之外，java还有一些特殊的控制语句形式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">rangeOf</span><span class="params">(<span class="type">int</span> k)</span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(k)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>-&gt;System.out.println(<span class="string">&quot;Ranking one&quot;</span>);</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>-&gt;System.out.println(<span class="string">&quot;Ranking two&quot;</span>);</span><br><span class="line">            <span class="keyword">default</span>-&gt;System.out.println(<span class="string">&quot;Ranking three&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>支持多种条件写在同一行，同时不需要冒号，使用<code>-&gt;</code>，不需要break语句跳出（在JDK14版本之后）</p><p>增强型for循环，主要用于枚举、数组和集合对象的元素遍历</p><p>Foreach用法,用于数组和容器</p><p><code>for(&lt;类型&gt;&lt;变量&gt;:&lt;集合对象&gt;)</code>声明类型需要与集合对象相兼容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String []args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] num = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">100</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            num[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k : num) &#123;</span><br><span class="line">            System.out.println(k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="移位操作符">移位操作符</h2><p>移位仅针对<code>int</code>,<code>long</code>使用，对于<code>byte, char, short</code>，在移位前都会转换成同数字大小的<code>int</code></p><p>位操作都是针对二进制补码操作</p><p><code>&lt;&lt;</code>左移，低位补0</p><p><code>&gt;&gt;</code>有符号右移，如果是正数，高位全部补0，如果是负数，高位全部补1</p><p><code>&gt;&gt;&gt;</code>无符号右移，不论正负，全部补0</p><p>java对于移位操作的数值有一定限制，对于int类型的操作数只考虑<strong>低五位</strong>，long类型只考虑<strong>低六位</strong></p><p>比如说<code>30&gt;&gt;32</code>等价于<code>30&gt;&gt;0</code>，有一个类似于取模32的过程，对于long就有个取模64的过程</p><h2 id="static详解">static详解</h2><p>static大多数用于类的成员变量或者成员方法，少数用于代码块提升性能，static不能修饰局部变量</p><ul><li>static修饰的成员变量或者方法属于<strong>类</strong>，因此生命周期和类相同</li><li>普通成员变量或者方法属于<strong>对象</strong></li><li>静态方法不能调用非静态成员变量，会报错</li><li>非静态方法可以调用非静态方法和静态方法，可以调用非静态成员和静态成员</li></ul><p>static方法称为静态方法，不依赖于任何对象就能使用，因此也不具备this的使用，其不依赖于任何对象，没有对象，也就没有this</p><p>静态方法中不能使用非静态成员变量和非静态方法，因为后者都是需要依附于对象才能被调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;soy&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">address</span> <span class="operator">=</span> <span class="string">&quot;BUAA&quot;</span>;</span><br><span class="line"></span><br><span class="line">    Main() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">        System.out.println(address);</span><br><span class="line">        test2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">        System.out.println(address);<span class="comment">//error</span></span><br><span class="line">        test1();<span class="comment">//error</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个示例的第17行，在静态的方法内调用了非静态成员变量<code>address</code>，系统报错</p><p>第18行，在静态方法内部调用了非静态方法<code>test1()</code>，系统报错</p><p>但是对于非静态方法，其可以随意调用静态变量和方法</p><p>静态方法可以不创建对象就调用，最常见的就是main方法是静态的</p><ul><li>静态变量被所有对象共享，内存只有一份，不同对象都可以修改该静态变量</li><li>非静态变量相互独立，在对象创建的时候进行初始化，有多个副本互不影响</li></ul><p>在类被加载的时候，static代码块就按照顺序进行初始化了</p><p>静态的加载顺序是从上往下依次执行，静态变量和静态代码块视作同一类，从上往下执行</p><h3 id="静态代码块">静态代码块</h3><p>静态代码块里面定义的变量都是局部变量，只在本块中有效</p><h1>初始化与清理</h1><h2 id="构造器初始化">构造器初始化</h2><p>在类里面使用和类名相同的方法作为构造函数，可以有多个构造函数，区别在于参数不同</p><p>构造器没有返回值</p><p>如果类没有构造器，系统会自动为你创造一个默认构造器</p><h2 id="方法重载">方法重载</h2><p>同一个类里面支持多个同名方法，区别在于参数不同，方法重载在涉及到数据的类型转换时可能有一些问题</p><p>传入的参数类型低于要求的类型，就会自动提升参数类型</p><p>传入的参数类型高于要求的类型，就会自动降低到参数对应的类型</p><h2 id="this">this</h2><p>this表示对当前对象的引用，可以作为返回值，返回对当前对象的引用</p><p>构造器之间可以相互调用，但是一次只能调用一个构造器，使用this调用</p><p>只有构造器能调用构造器，其它方法不能调用构造器</p><h2 id="变量初始化顺序">变量初始化顺序</h2><p>类的内部，变量的初始化顺序取决于其定义的先后顺序，但是不论他们处于任何位置，他们都会在构造器和任何方法调用之前完成初始化</p><h2 id="多个类">多个类</h2><p>一个<code>.java</code>文件允许有多个<code>class</code>，但是一般只有一个<code>class</code>由<code>public</code>修饰作为主类，主类的名字和<code>.java</code>文件名字相同</p><h2 id="类与类的关系">类与类的关系</h2><ul><li>关联：是一种has的关系<ul><li>一对一</li><li>一对多</li></ul></li><li>依赖：比has关系较弱，类之间的调用关系</li><li>聚集：整体和部分之间的联系<ul><li>组合</li></ul></li><li>泛化：类之间的继承关系</li><li>实现：类与接口的关系</li></ul><h1>封装</h1><ul><li>将对象的属性和方法看成一个整体</li><li>就信息进行隐藏，赋予一定的权限</li></ul><p>一般情况下，给<strong>所有的成员变量</strong>加入<code>private</code>权限限制，写相关属性的<code>get和set</code>方法，将这些方法设置为<code>public</code>，从而通过方法访问私有属性</p><ul><li><code>private</code>仅仅在本类中可见，提升数据的安全性</li><li><code>public</code>权限最低，其它类中也可以访问，减少代码冗余</li><li><code>protected</code>向子类和同一个包中的类公开</li><li>默认权限，向同一个包中的类公开</li></ul><p><code>protected</code>修饰规则详解：</p><ol><li>普通成员变量：<ul><li>同一包内的任何类都可以直接访问</li><li>被子类直接访问，不论子类和父类在不在同一个包下</li></ul></li><li>静态成员变量：<ul><li>同一包内的任何类都可以直接访问</li><li>被子类直接访问，不论子类和父类在不在同一个包下</li><li>在子类调用时采用类名调用，而不是用实例调用</li></ul></li><li>成员方法（加不加static无所谓，一样会被直接继承）：<ul><li>同一个包内的任何类都可以直接访问</li><li>被子类直接访问，不论子类和父类在不在同一个包下</li><li>可以通过子类的对象实例，子类的对象实例再调用其继承的<code>protected</code>方法</li><li>不同包下，一定不能通过父类实例调用<code>protected</code>方法，其它同级的子类也不行，也就是只有他自己的实例才行</li></ul></li></ol><h2 id="封装的单实例模式">封装的单实例模式</h2><h3 id="“懒汉式”单例">“懒汉式”单例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">//静态的。保留自身的引用。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">test</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//必须是私有的构造函数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//公共的静态的方法。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (test == <span class="literal">null</span>) &#123;</span><br><span class="line">            test = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> test;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>• 是否 Lazy 初始化：是，只有需要的时候才会初始化</p><p>• 是否多线程安全：否</p><p>• 描述：这种方式是最基本的实现方式，这种实现最大的问题就是不支持多线程。因为没有加锁 synchronized，所以严格意义上它并不算单例模式。</p><p>• 特点这种方式 lazy loading 很明显，不要求线程安全，在多线程不能正常工作只有一个实例，共享的数据，便于频繁查询修改</p><h3 id="“饿汉式”单例">“饿汉式”单例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">//静态的,保留自身的引用,类加载时就初始化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//必须是私有的构造函数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//公共的静态的方法。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> test;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>• 是否 Lazy 初始化：否，不论需不需要，类加载的时候就直接创建实例初始化</p><p>• 是否多线程安全：是</p><p>• 优点：没有加锁，执行效率会提高。</p><p>• 缺点：类加载时就初始化，容易产生垃圾对象，浪费内存。</p><p>• 特点：它基于 classloder 机制避免了多线程的同步问题，不过，instance 在类装载时就实例化。</p><h1>常用接口</h1><h3 id="List列表">List列表</h3><p>列表的三种类型，E为每个元素的类型</p><ul><li><code>List&lt;E&gt; list = new ArrayList&lt;&gt;()</code>，基于数组实现的动态数组，增删慢，查询快</li><li><code>List&lt;E&gt; list = new LinkedList&lt;&gt;()</code>，基于链表实现的双向链表，增删快，查询慢</li><li><code>List&lt;E&gt; list = new Vector&lt;&gt;()</code>，类似于<code>ArrayList</code>，多线程安全，性能较差</li></ul><p>常用方法：</p><ul><li><code>list.size()</code>，返回元素个数</li><li><code>list.add(&#123;int index ,&#125;E element)</code>，可选参数<code>index</code>，默认在列表尾部添加元素</li><li><code>list.get(int index)</code>，获取对应下标的元素</li><li>待补充</li></ul><h3 id="Map键值对">Map键值对</h3><p>四种类型，<code>E1</code>为键的类型，<code>E2</code>为值的类型</p><ul><li><code>Map&lt;E1, E2&gt; map = new HashMap&lt;&gt;()</code>，基于哈希表实现，保证查找效率，不保证元素的顺序</li><li>待添加</li></ul><p>常用方法：</p><ul><li><code>map.put(E1 key, E2 value)</code>，向表中添加键值对</li><li><code>map.containsKey(E1 key)</code>，查询是否包含“键”</li><li><code>map.get(E1 key)</code>，返回对应键的值</li><li><code>map.remove(E1 key)</code>，删除对应键的值</li><li>待添加</li></ul>]]></content>
      
      
      <categories>
          
          <category> 面向对象 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法-分治</title>
      <link href="/2023/06/25/%E7%AE%97%E6%B3%95-%E5%88%86%E6%B2%BB/"/>
      <url>/2023/06/25/%E7%AE%97%E6%B3%95-%E5%88%86%E6%B2%BB/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h2 id="从二路归并引入">从二路归并引入</h2><p>杠铃增重问题介绍归并排序</p><p><img src="https://soybeanlittlecar.oss-cn-beijing.aliyuncs.com/blog/%E7%AE%97%E6%B3%95-%E5%88%86%E6%B2%BB/00001.png" alt=""></p><p><img src="https://soybeanlittlecar.oss-cn-beijing.aliyuncs.com/blog/%E7%AE%97%E6%B3%95-%E5%88%86%E6%B2%BB/00002.png" alt=""></p><p><img src="https://soybeanlittlecar.oss-cn-beijing.aliyuncs.com/blog/%E7%AE%97%E6%B3%95-%E5%88%86%E6%B2%BB/00003.png" alt=""></p><p><img src="https://soybeanlittlecar.oss-cn-beijing.aliyuncs.com/blog/%E7%AE%97%E6%B3%95-%E5%88%86%E6%B2%BB/00004.png" alt=""></p><p><img src="https://soybeanlittlecar.oss-cn-beijing.aliyuncs.com/blog/%E7%AE%97%E6%B3%95-%E5%88%86%E6%B2%BB/00005.png" alt=""></p><p>归并排序利用分治思想，将整体数组先进行两两拆分，每次取中点作为分割点，最终每个个体数组只有一个元素形成了局部有序</p><p>局部解依次合并形成全局解，将大问题拆分成为小问题，解决小问题，再将小问题的答案合并形成大问题的答案</p><p>以下是C语言代码示例</p><p>递归</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> _MergeSort(<span class="type">int</span>* a, <span class="type">int</span>* tmp, <span class="type">int</span> begin, <span class="type">int</span> end) &#123;</span><br><span class="line"><span class="keyword">if</span> (begin &gt;= end)</span><br><span class="line"><span class="keyword">return</span>;<span class="comment">//单个或者不存在其区间就结束递归</span></span><br><span class="line"><span class="comment">//类似于后序：</span></span><br><span class="line"><span class="type">int</span> middle = (begin + end) / <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> begin1 = begin;</span><br><span class="line"><span class="type">int</span> end1 = middle;</span><br><span class="line"><span class="type">int</span> begin2 = middle + <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> end2 = end;</span><br><span class="line">_MergeSort(a, tmp, begin1, end1);</span><br><span class="line">_MergeSort(a, tmp, begin2, end2);</span><br><span class="line"><span class="comment">//此时认为 [begin1, end1] 和 [begin2, end2]两段区间上有序</span></span><br><span class="line"><span class="comment">//归并算法</span></span><br><span class="line"><span class="type">int</span> i = begin;</span><br><span class="line"><span class="keyword">while</span> (begin1 &lt;= end1 &amp;&amp; begin2 &lt;= end2) &#123;</span><br><span class="line"><span class="keyword">if</span> (a[begin1] &lt;= a[begin2]) &#123;</span><br><span class="line">tmp[i++] = a[begin1++];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">tmp[i++] = a[begin2++];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (begin1 &lt;= end1) &#123;</span><br><span class="line">tmp[i++] = a[begin1++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (begin2 &lt;= end2) &#123;</span><br><span class="line">tmp[i++] = a[begin2++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memcpy</span>(a + begin, tmp + begin, <span class="keyword">sizeof</span>(<span class="type">int</span>) * (end - begin + <span class="number">1</span>));<span class="comment">//内存操作函数，可以将整个数组的数复制过去</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//归并排序 递归版本</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MergeSort</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> n)</span> &#123;</span><br><span class="line"><span class="type">int</span>* tmp = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * n);<span class="comment">//首先malloc一个数组</span></span><br><span class="line"><span class="keyword">if</span> (tmp == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;未能申请到内存\n&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第一次传入 0 和 n - 1 传入闭区间</span></span><br><span class="line">_MergeSort(a, tmp, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line"><span class="built_in">free</span>(tmp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非递归</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">MergeSortNonR</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> n)</span> &#123;</span><br><span class="line"><span class="type">int</span>* tmp = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * n);</span><br><span class="line"><span class="keyword">if</span> (tmp == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;申请空间失败\n&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> gap = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (gap &lt; n) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i += <span class="number">2</span> * gap) &#123; <span class="comment">//每次跨越两组</span></span><br><span class="line"><span class="type">int</span> begin1 = i, end1 = i + gap - <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> begin2 = i + gap, end2 = i + <span class="number">2</span> * gap - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (end1 &gt;= n || begin2 &gt;= n) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (end2 &gt;= n) &#123;</span><br><span class="line">end2 = n - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//归并</span></span><br><span class="line"><span class="type">int</span> j = begin1;</span><br><span class="line"><span class="type">int</span> m = end2 - begin1 + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (begin1 &lt;= end1 &amp;&amp; begin2 &lt;= end2) &#123;</span><br><span class="line"><span class="keyword">if</span> (a[begin1] &lt;= a[begin2]) &#123;</span><br><span class="line">tmp[j++] = a[begin1++];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">tmp[j++] = a[begin2++];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (begin1 &lt;= end1) &#123;</span><br><span class="line">tmp[j++] = a[begin1++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (begin2 &lt;= end2) &#123;</span><br><span class="line">tmp[j++] = a[begin2++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memcpy</span>(a + i, tmp + i, <span class="keyword">sizeof</span>(<span class="type">int</span>) * m);<span class="comment">//局部复制，end2 - begin1 + 1</span></span><br><span class="line">&#125;</span><br><span class="line">gap *= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(tmp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>课件版本/自己熟悉写的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span> x[], <span class="type">int</span> tmp[], <span class="type">int</span> left, <span class="type">int</span> leftend, <span class="type">int</span> rightend, <span class="type">int</span> *num)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; leftend) &#123;</span><br><span class="line">        merge(x, tmp, left, (left + leftend) / <span class="number">2</span>, leftend, num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (leftend + <span class="number">1</span> &lt; rightend) &#123;</span><br><span class="line">        merge(x, tmp, leftend + <span class="number">1</span>, (leftend + <span class="number">1</span> + rightend) / <span class="number">2</span>, rightend, num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> i = left, j = leftend + <span class="number">1</span>, q = left;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= leftend &amp;&amp; j &lt;= rightend) &#123;</span><br><span class="line">        (*num)++;</span><br><span class="line">        <span class="keyword">if</span> (x[i] &lt;= x[j])</span><br><span class="line">            tmp[q++] = x[i++];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            tmp[q++] = x[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= leftend)</span><br><span class="line">        tmp[q++] = x[i++];</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= rightend)</span><br><span class="line">        tmp[q++] = x[j++];</span><br><span class="line">    <span class="keyword">for</span> (i = left; i &lt;= rightend; i++)</span><br><span class="line">        x[i] = tmp[i];</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h2 id="最大子数组问题">最大子数组问题</h2><p><a href="https://www.luogu.com.cn/problem/P1115">P1115 最大子段和 - 洛谷</a></p><p>对于一个数组，找出一段连续的子数组，使得子数组中所有数字的和最大</p><p>首先我们考虑简单的枚举法，枚举所有子数组的左侧边界和右侧边界，算法的时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>3</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，外层循环枚举左侧边界，内层循环枚举右侧边界，最内层加和区间所有数值</p><p>然后我们考虑第一层优化，对于每次加和的数组，对于已经加和过的区间，我们可以将其存起来，这样我们可以有</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mo stretchy="false">[</mo><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo stretchy="false">]</mo><mo>=</mo><mi>n</mi><mi>u</mi><mi>m</mi><mo stretchy="false">[</mo><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo>+</mo><mi>s</mi><mo stretchy="false">[</mo><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">num[left][right]=num[left][right-1]+s[right]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">t</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">h</span><span class="mord mathnormal">t</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">t</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">h</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">h</span><span class="mord mathnormal">t</span><span class="mclose">]</span></span></span></span></span></p><p>每次得到的区间和优化为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>时间，最终算法优化为枚举左右断点，也就是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p><p>接着我们考虑分治法，根据分治法的流程，首先分解成子问题，然后求解子问题的解，最终合并子问题的解作为原问题的解</p><p><img src="https://soybeanlittlecar.oss-cn-beijing.aliyuncs.com/blog/%E7%AE%97%E6%B3%95-%E5%88%86%E6%B2%BB/00006.png" alt=""></p><p>我们可以求解出子数组的解<code>S1</code>和<code>S2</code>，这两可能是最后的解，还有一种可能就是跨越两个数组分解位置的解<code>S3</code>，这里我们可以通过分治思想递归求出子数组的解，问题在于如何求解跨越分界点的解，这里采用枚举法，从分界点往两侧进行枚举，寻找最大的值，算法时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">CrossingSubArray</span><span class="params">(<span class="type">int</span> X[], <span class="type">int</span> low, <span class="type">int</span> mid, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">    <span class="type">int</span> max = -INFINITY;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = mid; i &gt;= low; i--) &#123;</span><br><span class="line">        left += X[i];</span><br><span class="line">        <span class="keyword">if</span> (max &lt; left)max = left;</span><br><span class="line">    &#125;</span><br><span class="line">    left = max;</span><br><span class="line">    max = -INFINITY;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = mid + <span class="number">1</span>; i &lt;= high; i++) &#123;</span><br><span class="line">        right += X[i];</span><br><span class="line">        <span class="keyword">if</span> (max &lt; right)max = right;</span><br><span class="line">    &#125;</span><br><span class="line">    right = max;</span><br><span class="line">    <span class="keyword">return</span> left + right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后合并三个可能的解</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">MaxSubArray</span><span class="params">(<span class="type">int</span> X[], <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (low == high) &#123;</span><br><span class="line">        <span class="keyword">return</span> X[low];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">int</span> max = -INFINITY;</span><br><span class="line">        <span class="type">int</span> mid = (low + high) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> s1 = MaxSubArray(X, low, mid);</span><br><span class="line">        <span class="keyword">if</span> (s1 &gt; max)max = s1;</span><br><span class="line">        <span class="type">int</span> s2 = MaxSubArray(X, mid + <span class="number">1</span>, high);</span><br><span class="line">        <span class="keyword">if</span> (s2 &gt; max)max = s2;</span><br><span class="line">        <span class="type">int</span> s3 = CrossingSubArray(X, low, mid, high);</span><br><span class="line">        <span class="keyword">if</span> (s3 &gt; max)max = s3;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="逆序对计数问题">逆序对计数问题</h2><p><a href="https://www.luogu.com.cn/problem/P1908">P1908 逆序对 - 洛谷</a></p><p>逆序对指的是一个序列中，第一个数字的序号比第二个数字小，但是第一个数字大于第二个数字，即<code>a[i] &gt; a[j] &amp;&amp; i &lt; j</code></p><p>求解一个数组中的逆序对数</p><p>首先考虑枚举，对于每一个数字，我们枚举它后面的所有数字，查看是否构成逆序对，时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p><p>接着考虑分治法，将大数组按中点拆分成两个子数组，对于子数组自身的逆序对数量，我们很容易通过递归可以求解，对于两个子数组之间的逆序对数量，我们需要考虑如何求解</p><p><img src="https://soybeanlittlecar.oss-cn-beijing.aliyuncs.com/blog/%E7%AE%97%E6%B3%95-%E5%88%86%E6%B2%BB/00007.png" alt=""></p><p>首先考虑枚举，对于每一个属于第一个子数组中的数字，我们在第二个子数组中枚举每一个数字，找到比它小的构成逆序对，这样最终整体的时间复杂度仍然为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，并没有起到分治优化的效果</p><p>由于我们是需要在一个序列中找到比它大的，我们可以对其中一个子数组进行排序，然后利用二分查找快速确定位置，我们对两个子数组都进行排序，然后对于每一个数字属于第一个子数组，我们利用二分查找找出比其小的分界点</p><p><img src="https://soybeanlittlecar.oss-cn-beijing.aliyuncs.com/blog/%E7%AE%97%E6%B3%95-%E5%88%86%E6%B2%BB/00008.png" alt=""></p><p>排序的时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，计算可逆序对的时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mfrac><mi>n</mi><mn>2</mn></mfrac><mi>l</mi><mi>o</mi><mi>g</mi><mfrac><mi>n</mi><mn>2</mn></mfrac><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O({\frac{n}{2}}log{\frac{n}{2}})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.095em;vertical-align:-0.345em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6954em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6954em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span><span class="mclose">)</span></span></span></span>，最终整体算法时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><msup><mrow><mi>l</mi><mi>o</mi><mi>g</mi></mrow><mn>2</mn></msup><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n{log}^2n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1484em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8984em;"><span style="top:-3.1473em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><p>我们接着考虑优化，对于上述排序与二分查找，我们可以联想到归并排序，归并排序的合并过程其实就是一个给出可逆序对的过程，每个元素合并到数组内时就有确定的数量的数字可以构成它的可逆序对</p><p><img src="https://soybeanlittlecar.oss-cn-beijing.aliyuncs.com/blog/%E7%AE%97%E6%B3%95-%E5%88%86%E6%B2%BB/00009.png" alt=""></p><p>归并的过程可以统计逆序对数量，因此只需要在归并排序的代码基础之上进行简单的修改，对于合并过程，每次右侧数组有数字进入总数组时，统计此时<code>i</code>指针的位置，这样相比于上一种排序和二分，利用归并排序，合并的时间复杂度优化至<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，总复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">MergeCount</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> left, <span class="type">int</span> mid, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="type">int</span> tmp_A[<span class="number">10005</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = left; i &lt;= right; i++) &#123;</span><br><span class="line">        tmp_A[i] = A[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> i = left, j = mid + <span class="number">1</span>, k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tmp_A[i] &lt;= tmp_A[j]) &#123;</span><br><span class="line">            A[k + left] = tmp_A[i++];</span><br><span class="line">            k++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            A[k + left] = tmp_A[j++];</span><br><span class="line">            k++;</span><br><span class="line">            cnt += mid + <span class="number">1</span> - i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid) &#123;</span><br><span class="line">        A[k + left] = tmp_A[i++];</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= right) &#123;</span><br><span class="line">        A[k + left] = tmp_A[j++];</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//合并问题解</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">CountInver</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        cnt += CountInver(A, left, mid);</span><br><span class="line">        cnt += CountInver(A, mid + <span class="number">1</span>, right);</span><br><span class="line">        cnt += MergeCount(A, left, mid, right);</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 分治 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分治 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dijkstra</title>
      <link href="/2023/05/31/dijkstra/"/>
      <url>/2023/05/31/dijkstra/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p><img src="https://soybeanlittlecar.oss-cn-beijing.aliyuncs.com/blog/dijkstra/00001.png" alt=""></p><p><img src="https://soybeanlittlecar.oss-cn-beijing.aliyuncs.com/blog/dijkstra/00002.png" alt=""></p><p><img src="https://soybeanlittlecar.oss-cn-beijing.aliyuncs.com/blog/dijkstra/00003.png" alt=""></p><p>AC源码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 10004</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Infinity 1000000</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> rank_line;<span class="comment">//几号线</span></span><br><span class="line">    <span class="type">char</span> word[<span class="number">20</span>];</span><br><span class="line">    <span class="type">int</span> weight;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">edge</span> *<span class="title">link</span>;</span></span><br><span class="line">&#125; Edge, *Edgeprt;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> op;</span><br><span class="line">    <span class="type">char</span> word[<span class="number">20</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">edge</span> *<span class="title">link</span>;</span></span><br><span class="line">&#125; Node, *Nodeprt;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">hash_table</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="type">int</span> hash_value;</span><br><span class="line">    <span class="type">char</span> word[<span class="number">20</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hash_table</span> *<span class="title">link</span>;</span></span><br><span class="line">&#125; HASH, *Hashprt;</span><br><span class="line">Hashprt table[<span class="number">100000</span>];</span><br><span class="line">Nodeprt G[MAXSIZE];</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(<span class="type">char</span> *word)</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> hash_value = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; word[i] != <span class="string">&#x27;\0&#x27;</span>; i++) &#123;</span><br><span class="line">        hash_value = (hash_value * <span class="number">31</span> + word[i]) % <span class="number">100000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hash_value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Hashprt <span class="title function_">search_hash</span><span class="params">(<span class="type">char</span> word[], <span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="type">int</span> hash_value = hash(word);</span><br><span class="line">    <span class="keyword">if</span> (table[hash_value] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        table[hash_value] = (Hashprt) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(HASH));</span><br><span class="line">        table[hash_value]-&gt;hash_value = hash_value;</span><br><span class="line">        table[hash_value]-&gt;link = <span class="literal">NULL</span>;</span><br><span class="line">        table[hash_value]-&gt;num = num;</span><br><span class="line">        <span class="built_in">strcpy</span>(table[hash_value]-&gt;word, word);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Hashprt p = table[hash_value];</span><br><span class="line">        <span class="keyword">while</span> (p-&gt;link != <span class="literal">NULL</span> &amp;&amp; <span class="built_in">strcmp</span>(p-&gt;word, word) != <span class="number">0</span>) &#123;</span><br><span class="line">            p = p-&gt;link;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(p-&gt;word, word) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">        Hashprt q = (Hashprt) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(HASH));</span><br><span class="line">        q-&gt;link = <span class="literal">NULL</span>;</span><br><span class="line">        q-&gt;hash_value = hash_value;</span><br><span class="line">        q-&gt;num = num;</span><br><span class="line">        <span class="built_in">strcpy</span>(q-&gt;word, word);</span><br><span class="line">        p-&gt;link = q;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">insert_edge</span><span class="params">(<span class="type">char</span> word1[], <span class="type">char</span> word2[], <span class="type">int</span> op, <span class="type">int</span> *num, <span class="type">int</span> rank_line)</span> &#123;</span><br><span class="line">    Hashprt p = search_hash(word1, *num);</span><br><span class="line">    Edgeprt q = (Edgeprt) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Edge));</span><br><span class="line">    q-&gt;link = <span class="literal">NULL</span>;</span><br><span class="line">    q-&gt;weight = <span class="number">1</span>;</span><br><span class="line">    q-&gt;rank_line = rank_line;</span><br><span class="line">    <span class="built_in">strcpy</span>(q-&gt;word, word2);</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        Nodeprt tmp = (Nodeprt) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">        tmp-&gt;op = op;</span><br><span class="line">        <span class="built_in">strcpy</span>(tmp-&gt;word, word1);</span><br><span class="line">        tmp-&gt;link = q;</span><br><span class="line">        G[*num] = tmp;</span><br><span class="line">        (*num)++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Nodeprt d = G[p-&gt;num];</span><br><span class="line">        <span class="keyword">if</span> (d-&gt;link == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            d-&gt;link = q;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Edgeprt f = d-&gt;link;</span><br><span class="line">            <span class="keyword">for</span> (; f-&gt;link != <span class="literal">NULL</span>; f = f-&gt;link);</span><br><span class="line">            f-&gt;link = q;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">char</span> word[])</span> &#123;<span class="comment">//查询一个地点在G表中的位置，也就是num，利用hash查找</span></span><br><span class="line">    <span class="type">int</span> value = hash(word);</span><br><span class="line">    Hashprt p = table[value];</span><br><span class="line">    <span class="keyword">for</span> (; p != <span class="literal">NULL</span> &amp;&amp; <span class="built_in">strcmp</span>(p-&gt;word, word) != <span class="number">0</span>; p = p-&gt;link);</span><br><span class="line">    <span class="keyword">if</span> (p)<span class="keyword">return</span> p-&gt;num;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">dijkstra</span><span class="params">(<span class="type">char</span> word[], <span class="type">int</span> num, <span class="type">int</span> site, <span class="type">int</span> p[], <span class="type">int</span> dis[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> save[<span class="number">2005</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">        dis[i] = Infinity;</span><br><span class="line">        save[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//加入首个结点</span></span><br><span class="line">    dis[site] = <span class="number">0</span>;<span class="comment">//dis对应的是num编号,save对应的也是num编号</span></span><br><span class="line">    Edgeprt q = G[site]-&gt;link;</span><br><span class="line">    <span class="keyword">for</span> (; q != <span class="literal">NULL</span>; q = q-&gt;link) &#123;</span><br><span class="line">        <span class="type">int</span> t = search(q-&gt;word);<span class="comment">//找位置</span></span><br><span class="line">        dis[t] = <span class="number">1</span>;</span><br><span class="line">        p[t] = site;<span class="comment">//设置前驱</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; num; i++) &#123;</span><br><span class="line">        <span class="type">int</span> min = Infinity;</span><br><span class="line">        <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; num; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (save[j] == <span class="number">0</span> &amp;&amp; dis[j] &lt; min) &#123;</span><br><span class="line">                min = dis[j];</span><br><span class="line">                k = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//加入k结点dis已经是新的，不用管</span></span><br><span class="line">        save[k] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//更新k的所有连接的点</span></span><br><span class="line">        q = G[k]-&gt;link;</span><br><span class="line">        <span class="keyword">for</span> (; q != <span class="literal">NULL</span>; q = q-&gt;link) &#123;</span><br><span class="line">            <span class="type">int</span> t = search(q-&gt;word);</span><br><span class="line">            <span class="keyword">if</span> (save[t] == <span class="number">0</span> &amp;&amp; dis[t] &gt;= q-&gt;weight + dis[k]) &#123;</span><br><span class="line">                dis[t] = q-&gt;weight + dis[k];</span><br><span class="line">                p[t] = k;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">back_search_path</span><span class="params">(<span class="type">int</span> path[], <span class="type">int</span> new_path[], <span class="type">int</span> k, <span class="type">int</span> src)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (k == src) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, G[k]-&gt;word);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    new_path[path[k]] = k;</span><br><span class="line">    <span class="keyword">return</span> back_search_path(path, new_path, path[k], src);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">search_line</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    Edgeprt p = G[a]-&gt;link;</span><br><span class="line">    <span class="keyword">for</span> (; p != <span class="literal">NULL</span>; p = p-&gt;link) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(p-&gt;word, G[b]-&gt;word) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> p-&gt;rank_line;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//freopen(&quot;a.in&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line">    <span class="comment">//freopen(&quot;a.out&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line">    FILE *fp = fopen(<span class="string">&quot;bgstations.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="type">int</span> total_num, rank_line, num_line;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">fscanf</span>(fp, <span class="string">&quot;%d&quot;</span>, &amp;total_num);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= total_num; i++) &#123;</span><br><span class="line">        <span class="built_in">fscanf</span>(fp, <span class="string">&quot;%d%d&quot;</span>, &amp;rank_line, &amp;num_line);</span><br><span class="line">        <span class="type">char</span> name1[<span class="number">20</span>], name2[<span class="number">20</span>];</span><br><span class="line">        <span class="type">int</span> op1, op2;</span><br><span class="line">        <span class="built_in">fscanf</span>(fp, <span class="string">&quot;%s%d&quot;</span>, name1, &amp;op1);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; num_line; j++) &#123;</span><br><span class="line">            <span class="built_in">fscanf</span>(fp, <span class="string">&quot;%s%d&quot;</span>, name2, &amp;op2);</span><br><span class="line">            insert_edge(name1, name2, op1, &amp;num, rank_line);</span><br><span class="line">            insert_edge(name2, name1, op2, &amp;num, rank_line);</span><br><span class="line">            <span class="built_in">strcpy</span>(name1, name2);</span><br><span class="line">            op1 = op2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//hash表里面有所有结点的num，对应的G[num];</span></span><br><span class="line">    <span class="type">char</span> begin[<span class="number">20</span>], end[<span class="number">20</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s%s&quot;</span>, begin, end);</span><br><span class="line">    <span class="type">int</span> a = search(begin);</span><br><span class="line">    <span class="type">int</span> path[<span class="number">2005</span>] = &#123;<span class="number">0</span>&#125;, dis[<span class="number">2006</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    dijkstra(begin, num, a, path, dis);</span><br><span class="line">    <span class="type">int</span> b = search(end);</span><br><span class="line">    <span class="type">int</span> new_path[<span class="number">2005</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    back_search_path(path, new_path, b, a);</span><br><span class="line">    <span class="comment">//得到正向路径new_path;起点是a，终点是b</span></span><br><span class="line">    <span class="type">int</span> mid = new_path[a];</span><br><span class="line">    <span class="type">int</span> line = search_line(a, mid);</span><br><span class="line">    <span class="type">int</span> len = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (a != b) &#123;</span><br><span class="line">        a = mid;</span><br><span class="line">        mid = new_path[mid];</span><br><span class="line">        <span class="keyword">if</span> (search_line(a, mid) != line) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;-%d(%d)-%s&quot;</span>, line, len, G[a]-&gt;word);</span><br><span class="line">            line = search_line(a, mid);</span><br><span class="line">            len = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        len++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 最短路径 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dijkstra </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>prim和kruskal的两种实现</title>
      <link href="/2023/05/28/prim%E5%92%8Ckruskal%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%AE%9E%E7%8E%B0/"/>
      <url>/2023/05/28/prim%E5%92%8Ckruskal%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>以judge第七次作业第三题为例</p><p><img src="https://soybeanlittlecar.oss-cn-beijing.aliyuncs.com/blog/prim-kruskal/00001.jpeg" alt=""></p><h1>Prim算法</h1><h2 id="邻接表实现">邻接表实现</h2><h3 id="AC源码">AC源码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Infinity 1000000</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">int</span> adjvex;</span><br><span class="line">    <span class="type">int</span> weight;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">edge</span> *<span class="title">link</span>;</span></span><br><span class="line">&#125; Edge, *Edgeprt;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    Edgeprt link;</span><br><span class="line">&#125; Node, *Nodeprt;</span><br><span class="line">Nodeprt G[<span class="number">205</span>];</span><br><span class="line"><span class="type">int</span> edge_to_weight[<span class="number">205</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">insert_edge</span><span class="params">(<span class="type">int</span> ID, <span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> wei)</span> &#123;</span><br><span class="line">    Edgeprt p = (Edgeprt) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Edge));</span><br><span class="line">    p-&gt;id = ID;</span><br><span class="line">    p-&gt;weight = wei;</span><br><span class="line">    p-&gt;adjvex = b;</span><br><span class="line">    p-&gt;link = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (G[a] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        G[a] = (Nodeprt) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">        G[a]-&gt;link = p;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Edgeprt q = G[a]-&gt;link;</span><br><span class="line">        <span class="keyword">for</span> (; q-&gt;link != <span class="literal">NULL</span>; q = q-&gt;link);</span><br><span class="line">        q-&gt;link = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">prim</span><span class="params">(<span class="type">int</span> dis[], <span class="type">int</span> src, <span class="type">int</span> edges[], <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    Edgeprt p = G[src]-&gt;link;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        dis[i] = Infinity;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; p != <span class="literal">NULL</span>; p = p-&gt;link) &#123;</span><br><span class="line">        dis[p-&gt;adjvex] = p-&gt;weight;</span><br><span class="line">        edges[p-&gt;adjvex] = p-&gt;id;</span><br><span class="line">    &#125;</span><br><span class="line">    dis[src] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> min = Infinity;</span><br><span class="line">        <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dis[j] != <span class="number">0</span> &amp;&amp; dis[j] &lt; min) &#123;</span><br><span class="line">                min = dis[j];</span><br><span class="line">                k = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找到了最近的k号结点</span></span><br><span class="line">        dis[k] = <span class="number">0</span>;<span class="comment">//k到生成树的距离为0</span></span><br><span class="line">        p = G[k]-&gt;link;</span><br><span class="line">        <span class="keyword">for</span> (; p != <span class="literal">NULL</span>; p = p-&gt;link) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dis[p-&gt;adjvex] != <span class="number">0</span> &amp;&amp; p-&gt;weight &lt; dis[p-&gt;adjvex]) &#123;</span><br><span class="line">                dis[p-&gt;adjvex] = p-&gt;weight;</span><br><span class="line">                edges[p-&gt;adjvex] = p-&gt;id;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *e1, <span class="type">const</span> <span class="type">void</span> *e2)</span> &#123;</span><br><span class="line">    <span class="type">int</span> p1 = *(<span class="type">int</span> *) e1;</span><br><span class="line">    <span class="type">int</span> p2 = *(<span class="type">int</span> *) e2;</span><br><span class="line">    <span class="keyword">if</span> (p1 &gt; p2)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (p1 &lt; p2)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//freopen(&quot;a.in&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line">    <span class="comment">//freopen(&quot;a.out&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line">    <span class="type">int</span> num_node, num_edge;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;num_node, &amp;num_edge);</span><br><span class="line">    <span class="type">int</span> id, a, b, wei;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= num_edge; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;id, &amp;a, &amp;b, &amp;wei);</span><br><span class="line">        insert_edge(id, a, b, wei);</span><br><span class="line">        insert_edge(id, b, a, wei);</span><br><span class="line">        edge_to_weight[id] = wei;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> edges[<span class="number">205</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> dis[<span class="number">205</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    prim(dis, <span class="number">0</span>, edges, num_node);</span><br><span class="line">    <span class="comment">//edges里面存着边序号，</span></span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num_node; i++) &#123;</span><br><span class="line">        sum += edge_to_weight[edges[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//实际上只有num_node-1条边，但是由于edges[0]=0无法改变，倒置所有边的下标要后移一位，从1~num_node-1的下标，</span></span><br><span class="line">    qsort(edges, num_node, <span class="keyword">sizeof</span>(edges[<span class="number">0</span>]), cmp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, sum);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; num_node; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, edges[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="邻接表的prim详解">邻接表的prim详解</h3><p>prim算法的两个集合分为已经有的结点集合（最小生成树集合）----<code>Tree</code>，未加入生成树的结点集合<code>Vertex</code></p><p>最开始生成树只有初始结点<code>src</code>，我们需要初始化所有结点到生成树的距离数组<code>dis[]</code></p><p>所有初始距离为<code>Infinity</code>无穷大----自定义一个比所有权重都要大的数值</p><p>以下是重复过程：</p><p>​每次加入一个距离生成树最近的结点<code>node</code>，</p><p>​修改新加入的<code>node</code>到生成树的距离为0</p><p>​然后对于新加入的结点<code>node</code>，去更新所有与<code>node</code>相连，并且对于未加入生成树的集合<code>Vertex</code>的距离</p><p>​同时加入那些更新的距离对应的边</p><hr><p>最开始所有结点都在<code>Vertex</code>中，那么所有结点到生成树的距离就是无穷<code>Infinity</code></p><p>则有初始化代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        dis[i] = Infinity;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>然后加入第一个结点<code>src</code>，加入到生成树后，我们需要执行上面的“重复过程”</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dis[src] = <span class="number">0</span>;#修改距离为<span class="number">0</span></span><br><span class="line">Edgeprt p = G[src]-&gt;link;#更新这个结点所有相连的结点</span><br><span class="line"><span class="keyword">for</span> (; p != <span class="literal">NULL</span>; p = p-&gt;link) &#123;</span><br><span class="line">    dis[p-&gt;adjvex] = p-&gt;weight;#更新结点的距离，由于此时生成树只有一个结点，所以不需要跳过任何结点</span><br><span class="line">    edges[p-&gt;adjvex] = p-&gt;id;#加入更新结点的边</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于第一个结点之后的结点，由于最终有n个结点，因此还需要执行n-1次加入单个结点的过程，外层循环n-1次</p><p>对于<strong>每个</strong>“重复过程”，先寻找<strong>最近的未加入</strong>的结点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> min = Infinity;</span><br><span class="line">        <span class="type">int</span> k = <span class="number">0</span>;#记录找到的结点编号</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dis[j] != <span class="number">0</span> &amp;&amp; dis[j] &lt; min) &#123;#需要找所有结点<span class="number">0</span>~n<span class="number">-1</span>中未加入的结点的距离的最小值</span><br><span class="line">                min = dis[j];<span class="meta">#dis[j]!=0就是对于未加入的结点的一个筛选，</span></span><br><span class="line">                k = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找到了最近的k号结点</span></span><br><span class="line">        dis[k] = <span class="number">0</span>;<span class="comment">//k到生成树的距离为0#加入生成树，距离设置为0</span></span><br></pre></td></tr></table></figure><p>新节点加入生成树之后，我们要去更新那些未加入的结点到生成树的距离</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">p = G[k]-&gt;link;</span><br><span class="line"><span class="keyword">for</span> (; p != <span class="literal">NULL</span>; p = p-&gt;link) &#123;#循环找所有与新加入的结点有边的结点去更新距离（只更新不在生成树的）</span><br><span class="line">    <span class="keyword">if</span> (dis[p-&gt;adjvex] != <span class="number">0</span> &amp;&amp; p-&gt;weight &lt; dis[p-&gt;adjvex]) &#123;#加入dis[p-&gt;adjvex]!=<span class="number">0</span>去筛选不在生成树内的结点</span><br><span class="line">        dis[p-&gt;adjvex] = p-&gt;weight;</span><br><span class="line">        edges[p-&gt;adjvex] = p-&gt;id;#每个更新的结点的边都要加入生成树的边</span><br><span class="line">                 &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>到这里prim算法得到生成树就结束了，这里再对每次更新边的序号做一个小解释</p><p>每次更新结点到生成树的距离的时候都会有一个代码就是</p><p><code>edges[p-&gt;adjvex] = p-&gt;id</code></p><p>每次我们加入一个最近结点之后，都要更新距离，如果一个结点到生成树的距离可以被更新，那么是不是说明这个结点在下一次寻找最近结点的时候是<strong>有可能</strong>被作为最近结点的，所有被更新的结点<strong>都有可能</strong>接入，而我们更新的边，是在更新某个结点之后紧接着进行的，就是说如果这个结点在下一次的过程有可能作为最近结点，那么它作为最近结点加入生成树所对应的边就是我们更新的边，因为一个结点加入生成树是需要连接一条边的（除了第一个初始结点）</p><p>一个结点的距离被更新，它就具有了下一次加入生成树的可能性</p><p>假如它真的能够在下一次加入生成树，那么我们更新的这个距离就是它接入生成树的边的权重</p><p>上面是一个重复性的过程，所有加入生成树的结点都要经历这一过程，也就是他们的边都被加入edges数组，同时这个edges数组的更新是一个不断覆盖的过程，有的结点距离更新了很多次才加入生成树，对应的它的边也更新了很多次，每次更新都会覆盖之前的数值。</p><h2 id="邻接矩阵">邻接矩阵</h2><p>AC代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Infinity 1000000</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">link</span>;</span></span><br><span class="line">&#125; Node, *Nodeprt;</span><br><span class="line"><span class="type">int</span> weight[<span class="number">105</span>][<span class="number">105</span>];</span><br><span class="line"><span class="type">int</span> edge[<span class="number">105</span>][<span class="number">105</span>];</span><br><span class="line"><span class="type">int</span> edge_to_weight[<span class="number">205</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">prim</span><span class="params">(<span class="type">int</span> src, <span class="type">int</span> n, <span class="type">int</span> edges[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> dis[<span class="number">205</span>], k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        dis[i] = Infinity;</span><br><span class="line">    &#125;</span><br><span class="line">    dis[src] = <span class="number">0</span>;<span class="comment">//加入生成树</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (weight[src][i] != <span class="number">0</span>) &#123;</span><br><span class="line">            dis[i] = weight[src][i];</span><br><span class="line">            edges[i] = edge[src][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> min = Infinity;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dis[j] != <span class="number">0</span> &amp;&amp; dis[j] &lt; min) &#123;</span><br><span class="line">                min = dis[j];</span><br><span class="line">                k = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dis[k] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dis[i] != <span class="number">0</span> &amp;&amp; weight[k][i] != <span class="number">0</span> &amp;&amp; weight[k][i] &lt; dis[i]) &#123;</span><br><span class="line">                dis[i] = weight[k][i];</span><br><span class="line">                edges[i] = edge[k][i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *e1, <span class="type">const</span> <span class="type">void</span> *e2)</span> &#123;</span><br><span class="line">    <span class="type">int</span> p1 = *(<span class="type">int</span> *) e1;</span><br><span class="line">    <span class="type">int</span> p2 = *(<span class="type">int</span> *) e2;</span><br><span class="line">    <span class="keyword">return</span> p1 - p2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//freopen(&quot;a.in&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line">    <span class="comment">//freopen(&quot;a.out&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line">    <span class="type">int</span> num_node, num_edge;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;num_node, &amp;num_edge);</span><br><span class="line">    <span class="type">int</span> id, a, b, wei;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num_edge; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;id, &amp;a, &amp;b, &amp;wei);</span><br><span class="line">        edge[a][b] = edge[b][a] = id;</span><br><span class="line">        weight[a][b] = weight[b][a] = wei;</span><br><span class="line">        edge_to_weight[id] = wei;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> edges[<span class="number">105</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    prim(<span class="number">0</span>, num_node, edges);</span><br><span class="line">    qsort(edges, num_node, <span class="keyword">sizeof</span>(edges[<span class="number">0</span>]), cmp);</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; num_node; i++) &#123;</span><br><span class="line">        sum += edge_to_weight[edges[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, sum);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; num_node; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, edges[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>Kruskal算法</h1>]]></content>
      
      
      <categories>
          
          <category> 最小生成树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 最小生成树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>trie树</title>
      <link href="/2023/05/04/trie%E6%A0%91/"/>
      <url>/2023/05/04/trie%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1>引入</h1><p>在大规模的文本中，查询一个单词，通常我们选择从前往后依次查询所有单词，但是在大规模文本中，这样的查询效率过于低下。</p><p>我们思考一个问题，我们通常在英文词典中查询单词的时候，是怎么做的呢？</p><p>比如单词<code>invalid</code>，首先你会去查找字母<code>i</code>开头的那部分，紧接着查找<code>n</code>，以此类推，最终快速找到这个单词，而不是把字典从前往后翻一遍，依次查看所有单词</p><p>因此我们引入树形结构<code>trie树</code></p><h1>性质</h1><p>trie树主要利用公共前缀来节约空间，同时提升查找和插入效率</p><p>trie结构主要基于两个原则：</p><ul><li>根节点不包含字符，除根节点外每一个节点都只包含一个字符。</li><li>从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串。</li><li>每个节点的所有子节点包含的字符都不相同。</li></ul><h1>构造与代码</h1><p>我们需要构建出一颗类似于我们查词典一样的树，比如查询字符串<code>abcd</code>，我们首先只需要考虑字母<code>a</code>，而对于以<code>b, c, d</code>开头的就不需要考虑了。</p><p>对于单词<code>abcd</code>、<code>ackf</code>、<code>ahbd</code>、<code>abce</code>、<code>acdk</code>、<code>ab</code>、<code>abcm</code>、<code>ah</code>，我们可以构建如下一棵树：</p><p><img src="https://soybeanlittlecar.oss-cn-beijing.aliyuncs.com/blog/trie/00001.png" alt=""></p><p>其中用黄圈标记的表示存在以此结点为结尾的单词，对于每一个单词，我们只需要查询到其最后一个字母，看最后一个字母对应的结点是否被标记（黄圈），标记了代表该树中以及存在这个单词。</p><p>这里我们只考虑统计字母（不区分大小写），那么trie树每一层是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>h</mi><mn>26</mn></msup></mrow><annotation encoding="application/x-tex">h^{26}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">26</span></span></span></span></span></span></span></span></span></span></span></span>量级，因此我们可以使用链表或者数组模拟来存储trie树，空间的花费不会超过单词书*单词的长度</p><p>代码实现如下（使用数组模拟）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1000050</span>;<span class="comment">//总边数量&gt;=单词数*单词长度</span></span><br><span class="line"><span class="type">int</span> trie[N][<span class="number">26</span>];</span><br><span class="line"><span class="type">int</span> cnt[N];</span><br><span class="line"><span class="type">int</span> id;<span class="comment">//结点的编号，按照先后顺序记录</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">char</span> s[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; s[i] != <span class="string">&#x27;\0&#x27;</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> x = s[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (trie[p][x] == <span class="number">0</span>) trie[p][x] = ++id;</span><br><span class="line">        p = trie[p][x];</span><br><span class="line">    &#125;</span><br><span class="line">    cnt[p]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">char</span> s[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; s[i] != <span class="string">&#x27;\0&#x27;</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> x = s[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (trie[p][x] == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        p = trie[p][x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt[p];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面来解释这段代码，</p><p><code>id</code>表示一条边的对应关系，比如<code>trie[i][3]=5;</code>第<strong>i</strong>号结点连接了字符<code>d</code>，因为<code>3 = 'd'-'a'</code>；并且这个<strong>d</strong>字符结点的标号是5;</p><p>每次通过标号索引到最终结束的结点，假设最终结点标号是<strong>p</strong>，<code>cnt[p]++</code>，<strong>cnt</strong>存取所有结点作为结束结点的个数，<code>cnt[p]&gt;0</code>就代表标号<strong>p</strong>的结点是结束结点</p><p>我们再次以上述的trie树构造图来说明，插入的顺序为<code>abcd</code>、<code>ackf</code>、<code>ahbd</code>、<code>abce</code>、<code>acdk</code>、<code>ab</code>、<code>abcm</code>、<code>ah</code></p><p>起初，树空，我们插入<code>abcd</code>，</p><p><code>trie[0]['a'-'a']=1;--trie[1]['b'-'a']=2;--trie[2]['c'-'a']=3;--trie[3]['d'-'a']=4;</code></p><p><img src="https://soybeanlittlecar.oss-cn-beijing.aliyuncs.com/blog/trie/00002.png" alt=""></p><p>接着插入<code>ackf</code>，得到</p><p><img src="https://soybeanlittlecar.oss-cn-beijing.aliyuncs.com/blog/trie/00003.png" alt=""></p><p>接着插入<code>ahbd</code>，得到</p><p><img src="https://soybeanlittlecar.oss-cn-beijing.aliyuncs.com/blog/trie/00004.png" alt=""></p><p>接着插入<code>abce</code>，得到</p><p><img src="https://soybeanlittlecar.oss-cn-beijing.aliyuncs.com/blog/trie/00005.png" alt=""></p><p>接着插入<code>acdk</code>，得到</p><p><img src="https://soybeanlittlecar.oss-cn-beijing.aliyuncs.com/blog/trie/00006.png" alt=""></p><p>接着插入<code>ab</code>，得到</p><p><img src="https://soybeanlittlecar.oss-cn-beijing.aliyuncs.com/blog/trie/00007.png" alt=""></p><p>接着插入<code>abcm</code>，得到</p><p><img src="https://soybeanlittlecar.oss-cn-beijing.aliyuncs.com/blog/trie/00008.png" alt=""></p><p>接着插入<code>ah</code>，得到</p><p><img src="https://soybeanlittlecar.oss-cn-beijing.aliyuncs.com/blog/trie/00009.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> trie树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AVL树</title>
      <link href="/2023/04/27/AVL%E6%A0%91/"/>
      <url>/2023/04/27/AVL%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1>平衡二叉树</h1><h2 id="引入">引入</h2><p>我们曾经学习过二叉搜索树（Binary Search Tree，(BST))。它的插入和查找效率可以达到   o(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi></mrow><annotation encoding="application/x-tex">log_2n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal">n</span></span></span></span>)   ，但是在一些情况下，比如输入序列为<code>&#123;1, 2, 3, 4, 5, 6&#125;</code>，二叉搜索树将会退化成为一个单链表，这样对于插入和查找效率又回到了  <strong>o(n)</strong>  。因此引出平衡二叉树</p><p><img src="https://soybeanlittlecar.oss-cn-beijing.aliyuncs.com/blog/AVL/00001.png" alt=""></p><h2 id="性质">性质</h2><p>平衡二叉树具有以下性质</p><ol><li>任意结点的左右子树也是平衡二叉树</li><li>任意结点的左右子树高度差的绝对值小于等于1</li></ol><p>我们定义某个结点的左右子树高度差为平衡因子，平衡二叉树的所有结点的平衡因子都小于属于<code>&#123;-1, 0, 1&#125;</code></p><h2 id="结点组成结构">结点组成结构</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">AVLNode</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="type">int</span> height;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">AVLNode</span> *<span class="title">left</span>, *<span class="title">right</span>;</span></span><br><span class="line">&#125; Node, *Nodeprt;</span><br></pre></td></tr></table></figure><h2 id="失衡">失衡</h2><p>对于一颗平衡二叉树来说，插入一个结点可能导致失衡</p><p><img src="https://soybeanlittlecar.oss-cn-beijing.aliyuncs.com/blog/AVL/00003.png" alt=""></p><p>我们在原本平衡的树上插入20结点，导致失衡，因为13结点的左右子树高度差的绝对值大于1</p><p>这时我们需要相应的操作对这颗树进行调整，我们需要先了解最小不平衡子树的概念</p><h3 id="最小不平衡子树">最小不平衡子树</h3><p>从新插入的结点向上寻找，找到第一个不平衡点（左右子树差值的绝对值大于1）（平衡因子绝对值大于1），上图中，最小不平衡子树为13号结点为根的树。</p><p>往往很多时候第一个不平衡点并不是整棵树的树根，只是一颗子树，这时我们只需要调整子树即可</p><h3 id="旋转">旋转</h3><p>通过旋转操作调整最小不平衡子树，从而最终形成平衡二叉树，以下所有操作的描述起点都是当前对应的第一个不平衡点，也就是最小不平衡子树的树根，以下分类按照不平衡点的位置划分，</p><p>按照引起不平衡的点进行四种类比划分——左左，右右，左右，右左</p><h4 id="左旋（右孩子的右子树）">左旋（右孩子的右子树）</h4><p><img src="https://soybeanlittlecar.oss-cn-beijing.aliyuncs.com/blog/AVL/left-round.png" alt=""></p><ul><li>节点（20）的右孩子（25）代替当前节点（20）的位置</li><li>右孩子（25）的左孩子（24）作为当前结点（20）的右孩子【前提是右孩子（25）有左孩子（24）】</li><li>当前结点（20）变成右孩子（25）的左子树</li></ul><p>例子：</p><p>插入结点20之后，二叉树失衡，进行左旋调整</p><p><img src="https://soybeanlittlecar.oss-cn-beijing.aliyuncs.com/blog/AVL/00004.png" alt=""></p><p>左旋调整代码（右孩子的右子树）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Nodeprt <span class="title function_">right_right</span><span class="params">(Nodeprt tree)</span> &#123;<span class="comment">//左旋</span></span><br><span class="line">    <span class="comment">//结点调整</span></span><br><span class="line">    Nodeprt k = tree-&gt;right;<span class="comment">//保存右孩子，最终成为子树根节点</span></span><br><span class="line">    tree-&gt;right = k-&gt;left;<span class="comment">//k的左孩子作为tree的右子树</span></span><br><span class="line">    k-&gt;left = tree;<span class="comment">//tree作为k的左子树</span></span><br><span class="line">    <span class="comment">//高度调整</span></span><br><span class="line">    k-&gt;height = max(k-&gt;left-&gt;height, k-&gt;right-&gt;height) + <span class="number">1</span>;</span><br><span class="line">    tree-&gt;height = max(tree-&gt;left-&gt;height, tree-&gt;right-&gt;height) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="右旋（左孩子的左子树）">右旋（左孩子的左子树）</h4><p><img src="https://soybeanlittlecar.oss-cn-beijing.aliyuncs.com/blog/AVL/right-round.png" alt=""></p><ul><li>当前结点（20）的左孩子（16）代替当前结点（20）的位置</li><li>左孩子（16）的右子树（18）变成当前结点（20）的左孩子【前提是左孩子（16）有右子树（18）】</li><li>当前结点（20）变成左孩子（16）的右子树</li></ul><p>例子：</p><p>插入结点1之后，二叉树失衡，进行右旋调整</p><p><img src="https://soybeanlittlecar.oss-cn-beijing.aliyuncs.com/blog/AVL/00005.png" alt=""></p><p>右旋调整代码（左孩子的左子树）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Nodeprt <span class="title function_">left_left</span><span class="params">(Nodeprt tree)</span> &#123;<span class="comment">//右旋</span></span><br><span class="line">    <span class="comment">//结点调整</span></span><br><span class="line">    Nodeprt k = tree-&gt;left;<span class="comment">//保存右孩子，最终成为子树根节点</span></span><br><span class="line">    tree-&gt;left = k-&gt;right;<span class="comment">//k的右孩子作为tree的左子树</span></span><br><span class="line">    k-&gt;right = tree;<span class="comment">//tree作为k的右子树</span></span><br><span class="line">    <span class="comment">//高度调整</span></span><br><span class="line">    k-&gt;height = max(k-&gt;left-&gt;height, k-&gt;right-&gt;height) + <span class="number">1</span>;</span><br><span class="line">    tree-&gt;height = max(tree-&gt;left-&gt;height, tree-&gt;right-&gt;height) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="先左旋再右旋（左孩子的右子树）">先左旋再右旋（左孩子的右子树）</h4><p><img src="https://soybeanlittlecar.oss-cn-beijing.aliyuncs.com/blog/AVL/00006.png" alt=""></p><p>新插入的9号结点造成二叉树失衡，向上寻找最小不平衡子树的根节点为13，9在13的左孩子的右子树。先对13的左孩子进行左旋，再对13进行右旋。</p><p>左旋再右旋（左孩子的右子树）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Nodeprt <span class="title function_">left_right</span><span class="params">(Nodeprt tree)</span>&#123;</span><br><span class="line">    tree-&gt;left=right_right(tree-&gt;left);<span class="comment">//左子树左旋</span></span><br><span class="line">    tree=left_left(tree);<span class="comment">//自身右旋</span></span><br><span class="line">    <span class="keyword">return</span> tree;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="先右旋再左旋（右孩子的右子树）">先右旋再左旋（右孩子的右子树）</h4><p><img src="https://soybeanlittlecar.oss-cn-beijing.aliyuncs.com/blog/AVL/00007.png" alt=""></p><p>新插入的14号结点造成二叉树失衡，向上寻找最小不平衡子树的根节点13，14在13的右孩子的左子树，先对右孩子18右旋，再对13左旋。</p><p>右旋再左旋（右孩子的左子树）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Nodeprt <span class="title function_">right_left</span><span class="params">(Nodeprt tree)</span> &#123;</span><br><span class="line">    tree-&gt;right = left_left(tree-&gt;right);</span><br><span class="line">    tree = right_right(tree);</span><br><span class="line">    <span class="keyword">return</span> tree;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="失衡调整总结">失衡调整总结</h3><p>以<strong>A</strong>结点作为最小不平衡子树的<strong>根节点</strong></p><p>插入位置描述调整方式</p><p>​LL在结点A的<strong>左</strong>孩子的<strong>左</strong>子树插入导致A失衡A右旋</p><p>​RR在结点A的<strong>右</strong>孩子的<strong>右</strong>子树插入导致A失衡A左旋</p><p>​LR在结点A的<strong>左</strong>孩子的<strong>右</strong>子树插入导致A失衡A的左子左旋，A右旋</p><p>​RL在结点A的<strong>右</strong>孩子的<strong>左</strong>子树插入导致A失衡A的右子右旋，A左旋</p><p>插入的最终代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Nodeprt <span class="title function_">insert</span><span class="params">(Nodeprt tree, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (tree == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        Nodeprt p = build_node(key);</span><br><span class="line">        tree = p;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &lt; tree-&gt;data) &#123;</span><br><span class="line">        tree-&gt;left = insert(tree-&gt;left, key);<span class="comment">//递归插入左子树</span></span><br><span class="line">        <span class="comment">//在左侧插入，只可能左侧比右侧高了2导致失衡</span></span><br><span class="line">        <span class="keyword">if</span> (tree-&gt;left-&gt;height - tree-&gt;right-&gt;height == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="comment">//判断左子树还是右子树是插入位置</span></span><br><span class="line">            <span class="keyword">if</span> (key &lt; tree-&gt;left-&gt;data) &#123;<span class="comment">//左左</span></span><br><span class="line">                tree = left_left(tree);</span><br><span class="line">            &#125; <span class="keyword">else</span> tree = left_right(tree);<span class="comment">//左右</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; tree-&gt;data) &#123;<span class="comment">//递归插入右子树</span></span><br><span class="line">        tree-&gt;right = insert(tree-&gt;right, key);</span><br><span class="line">        <span class="comment">///在右侧插入，只可能右侧比左侧高2导致失衡</span></span><br><span class="line">        <span class="keyword">if</span> (tree-&gt;right-&gt;height - tree-&gt;left-&gt;height == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="comment">//判断左子树还是右子树插入</span></span><br><span class="line">            <span class="keyword">if</span> (key &gt; tree-&gt;right-&gt;data) &#123;<span class="comment">//右右</span></span><br><span class="line">                tree = right_right(tree);</span><br><span class="line">            &#125; <span class="keyword">else</span> tree = right_left(tree);<span class="comment">//右左</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;不允许插入重复值\n&quot;</span>);</span><br><span class="line">    tree-&gt;height = max(tree-&gt;left-&gt;height, tree-&gt;right-&gt;height) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> tree;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="删除结点">删除结点</h2><p>删除操作过于复杂，后面有机会再补充，和普通二叉树的删除操作一起补充。</p><p>上述代码或者描述有问题的请联系作者（代码还未测试…）</p><p>感谢博主文章<a href="https://blog.csdn.net/weixin_54186646/article/details/124557830?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-4-124557830.nonecase&amp;spm=1018.2226.3001.4187">平衡二叉树（详细解释+完整C语言）_～在下小吴的博客-CSDN博客</a></p>]]></content>
      
      
      <categories>
          
          <category> 平衡二叉树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 平衡二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python学习</title>
      <link href="/2023/04/25/python%E5%AD%A6%E4%B9%A0/"/>
      <url>/2023/04/25/python%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>开启一门新的语言学习是非常痛苦的，但是也充满着新奇与成就感，就像当初学习c的时候。</p><p>本文参照《python程序设计基础与应用》（董付国）的路线进行学习</p><span id="more"></span><h1>python 概述</h1><h1>内置对象、运算符、表达式、关键字</h1><h2 id="python-常用内置对象">python 常用内置对象</h2><p>数字（int，float，complex），字符串（str），字节串（bytes）</p><p>列表（list），元组（tuple），字典（dict），集合（set）</p><p>布尔类型（bool），空类型（None Type），异常（Error）</p><p>文件，其它可迭代对象，编程单元</p><h3 id="常量与变量">常量与变量</h3><p>常量：不能改变的字面值，比如<code>3</code>,<code>&quot;hello world&quot;</code>,<code>(3,4,5)</code></p><p>变量：一般值可以变化，数值和类型都可以改变，python创建变量不需要声明类型和变量名。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">5</span></span><br><span class="line">x = <span class="string">&quot;hello world&quot;</span></span><br><span class="line">x = (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>Ps: 赋值语句的执行顺序是：先计算右侧表达式的值，然后在内存中寻找一个位置把这个值存进去，最后创建变量并<strong>引用</strong>这个内存地址。变量不直接存储值，而是<strong>存储了值的地址或者引用</strong>，因此变量类型随时可变。</p><h3 id="整数、实数、复数">整数、实数、复数</h3><p><code>python</code>的内置数字类型有整数，实数和复数。</p><p>整数的常见进制：</p><ul><li>二进制：以<code>0b</code>开头，每一位数字是<code>0~1</code></li><li>八进制：以<code>0o</code>开头，每一位数字是<code>0~7</code></li><li>十六进制：以<code>0x</code>开头，每一位数字是<code>0~9,a~f</code></li></ul><p><code>python</code>支持<strong>任意大</strong>的数字，不必担心数字溢出。实数运算有一定的误差（和c语言类似），因此实数的比较相同常常使用差值</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">abs</span>(<span class="number">0.4</span> - <span class="number">0.1</span> - <span class="number">0.3</span>) &lt; <span class="number">1e-6</span></span><br></pre></td></tr></table></figure><p><code>python</code>内置支持复数运算，形式上和数学上的复数一致</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = <span class="number">3</span> + <span class="number">4j</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y = <span class="number">5</span> + <span class="number">6j</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x + y</span><br><span class="line">(<span class="number">8</span>+<span class="number">10j</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x * y</span><br><span class="line">(-<span class="number">9</span>+<span class="number">38j</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">abs</span>(x)</span><br><span class="line"><span class="number">5.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x.imag</span><br><span class="line"><span class="number">4.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x.real</span><br><span class="line"><span class="number">5.0</span></span><br></pre></td></tr></table></figure><p><code>python</code>支持在数字之间插入下划线<code>_</code>以便于区分</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1_000_000</span></span><br><span class="line"><span class="number">1000000</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1_2_3_4</span></span><br><span class="line"><span class="number">1234</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1_2</span> + <span class="number">3_4j</span></span><br><span class="line">(<span class="number">12</span>+<span class="number">34j</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1_2.3_45</span></span><br><span class="line"><span class="number">12.345</span></span><br></pre></td></tr></table></figure><h3 id="字符串">字符串</h3><p><code>python</code>中没有字符常量与变量，只有字符串常量和变量，<strong>单个字符也是字符串</strong></p><p><code>python</code>使用单引号、双引号、三引号作为定界符表示字符串，不同定界符之间可以相互嵌套</p><p><code>python 3.x</code>之后支持中文，内置函数<code>len()</code>统计长度的时候，将中文和英文字母都视作一个字符</p><p>字符串支持<code>+</code>和<code>*</code>运算</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = <span class="string">&#x27;hello world&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = <span class="string">&quot;python is a good language&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = <span class="string">&#x27;&#x27;&#x27;Tom said, &quot;Let&#x27;s go.&quot;&#x27;&#x27;&#x27;</span><span class="comment">#不同定界符的嵌套</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(x)</span><br><span class="line">Tom said, <span class="string">&quot;Let&#x27;s go.&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = <span class="string">&#x27;good &#x27;</span> + <span class="string">&#x27;morning&#x27;</span><span class="comment">#字符串拼接</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line"><span class="string">&#x27;good morning&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = <span class="string">&#x27;good &#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = x + <span class="string">&#x27;morning&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line"><span class="string">&#x27;good morning&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x * <span class="number">3</span><span class="comment">#字符串重复</span></span><br><span class="line"><span class="string">&#x27;good morninggood morninggood morning&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="列表、元组、字典、集合">列表、元组、字典、集合</h3><p>列表，元组，字典，集合是<code>python</code>内置的容器对象，其中可包含和持有多个元素</p><p>另外，map，zip，filter，enumerate 等迭代器对象是python中常用的内置对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]<span class="comment">#创建列表对象</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x_tuple = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)<span class="comment">#创建元组对象</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x_dict = &#123;<span class="string">&#x27;a&#x27;</span>:<span class="number">97</span>, <span class="string">&#x27;b&#x27;</span>:<span class="number">98</span>, <span class="string">&#x27;c&#x27;</span>:<span class="number">99</span>&#125;<span class="comment">#创建字典对象，元素为“键:值”</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x_set = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;<span class="comment">#创建集合对象</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(x_list[<span class="number">1</span>])<span class="comment">#下标访问</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(x_tuple[<span class="number">1</span>])<span class="comment">#下标访问</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(x_dict[<span class="string">&#x27;a&#x27;</span>])<span class="comment">#下标访问，下标是“键”</span></span><br><span class="line"><span class="number">97</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x_set[<span class="number">1</span>]<span class="comment">#集合不支持下标访问</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: <span class="string">&#x27;set&#x27;</span> <span class="built_in">object</span> <span class="keyword">is</span> <span class="keyword">not</span> subscriptable</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">3</span> <span class="keyword">in</span> x_set<span class="comment">#测试成员是否包含在内</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><h2 id="python-运算符与表达式">python 运算符与表达式</h2><h3 id="算数运算符">算数运算符</h3><ol><li><code>+</code>不仅可以用于算数的加法，还可以用于列表，元组，字符串的拼接。（不支持不同内置类型的对象之间的相加或者相连）</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">3</span> + <span class="number">5</span> &lt;&lt; <span class="number">1</span><span class="comment">#算数优先级高于位运算</span></span><br><span class="line"><span class="number">16</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">3</span> + (<span class="number">5</span> &lt;&lt; <span class="number">1</span>)</span><br><span class="line"><span class="number">13</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] + [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]<span class="comment">#两个列表的连接</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) + (<span class="number">4</span>,)<span class="comment">#两个元组的连接</span></span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;abcd&#x27;</span> + <span class="string">&#x27;1234&#x27;</span><span class="comment">#两个字符串的连接</span></span><br><span class="line"><span class="string">&#x27;abcd1234&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;A&#x27;</span> + <span class="number">1</span><span class="comment">#不同类型的对象，报错</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: can only concatenate <span class="built_in">str</span> (<span class="keyword">not</span> <span class="string">&quot;int&quot;</span>) to <span class="built_in">str</span></span><br></pre></td></tr></table></figure><ol start="2"><li><code>*</code>除了算数乘法，还可以用于列表，元组，字符串这几个类型和正整数的乘法，表示序列的重复，生成新的序列对象</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] * <span class="number">3</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) * <span class="number">3</span></span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;abc&#x27;</span> * <span class="number">3</span></span><br><span class="line"><span class="string">&#x27;abcabcabc&#x27;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>运算符<code>/</code>和<code>//</code>在python中分别表示算数除法和算数整除</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">3</span> / <span class="number">2</span></span><br><span class="line"><span class="number">1.5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">15</span> / <span class="number">4</span></span><br><span class="line"><span class="number">3.75</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">15.0</span> / <span class="number">4</span></span><br><span class="line"><span class="number">3.75</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">15</span> // <span class="number">4</span><span class="comment">#如果有一个是实数，结果以实数的&quot;形式&quot;呈现</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">15.0</span> // <span class="number">4</span><span class="comment">#如果有一个是实数，结果以实数的&quot;形式&quot;呈现</span></span><br><span class="line"><span class="number">3.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>-<span class="number">15</span> // <span class="number">4</span><span class="comment">#向下取整</span></span><br><span class="line">-<span class="number">4</span></span><br></pre></td></tr></table></figure><ol start="4"><li><code>%</code>用于取模，还可以用于字符串格式化</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">789</span> % <span class="number">23</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;%c,%d&#x27;</span> % (<span class="number">65</span>,<span class="number">65</span>)<span class="comment">#将65分别格式化为字符和整数</span></span><br><span class="line"><span class="string">&#x27;A,65&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;%f,%s&#x27;</span> % (<span class="number">65</span>,<span class="number">65</span>)<span class="comment">#将65分别格式化为实数和字符串</span></span><br><span class="line"><span class="string">&#x27;65.000000,65&#x27;</span></span><br></pre></td></tr></table></figure><ol start="5"><li><code>**</code>表示幂运算</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">3</span> ** <span class="number">2</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">3</span> ** <span class="number">0.5</span></span><br><span class="line"><span class="number">3.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">3</span> ** <span class="number">3</span> ** <span class="number">3</span><span class="comment">#幂运算从右往左</span></span><br><span class="line"><span class="number">6561</span></span><br></pre></td></tr></table></figure><h3 id="关系运算符">关系运算符</h3><p>要求操作数之间可以比较大小，可以连用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1</span> &lt; <span class="number">3</span> &lt; <span class="number">5</span><span class="comment">#等价于1 &lt; 3 &amp;&amp; 3&lt; 5</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">3</span> &lt; <span class="number">5</span> &gt; <span class="number">2</span><span class="comment">#等价于3 &lt; 5 &amp;&amp; 5 &gt; 2</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;hello&#x27;</span> &gt; <span class="string">&#x27;world&#x27;</span><span class="comment">#比较字典序</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] &lt; [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]<span class="comment">#列表比较类似于字符串</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;hello&#x27;</span> &gt; <span class="number">3</span><span class="comment">#不同类型无法比较</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: <span class="string">&#x27;&gt;&#x27;</span> <span class="keyword">not</span> supported between instances of <span class="string">&#x27;str&#x27;</span> <span class="keyword">and</span> <span class="string">&#x27;int&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125; == &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;<span class="comment">#测试所有元素是否都相等</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>&#125; &gt; &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;<span class="comment">#测试包含与被包含关系</span></span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure><h3 id="成员测试运算符">成员测试运算符</h3><p><code>in</code>用于测试一个对象是否包含另一个对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">3</span> <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">5</span> <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>, <span class="number">1</span>)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;abc&#x27;</span> <span class="keyword">in</span> <span class="string">&#x27;abcdef&#x27;</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> (<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>):</span><br><span class="line"><span class="built_in">print</span>(i, end=<span class="string">&#x27;\t&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="集合运算符">集合运算符</h3><p>集合的交集，并集，对称差集分别采用<code>&amp;, |, ^</code>实现，差集使用<code>-</code>实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125; | &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125; &amp; &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">&#123;<span class="number">3</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125; ^ &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125; - &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure><h3 id="逻辑运算符">逻辑运算符</h3><p>逻辑运算符<code>and, or, not</code>连接条件表达式（类似于c语言的&amp;&amp;，||，！），<code>and 和 or</code>具有逻辑短路，或者是惰性求值的特点，只计算一个表达式必须计算的值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">3</span> &gt; <span class="number">4</span> <span class="keyword">and</span> a &gt; <span class="number">3</span><span class="comment">#只求了第一个表达式</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">3</span> &gt; <span class="number">4</span> <span class="keyword">or</span> a &gt; <span class="number">3</span><span class="comment">#求了两个表达式，然后才发现a未定义</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">NameError: name <span class="string">&#x27;a&#x27;</span> <span class="keyword">is</span> <span class="keyword">not</span> defined</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">3</span> &lt; <span class="number">5</span> <span class="keyword">or</span> a &gt; <span class="number">3</span><span class="comment">#只求了第一个表达式</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">3</span> <span class="keyword">and</span> <span class="number">5</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">4</span> <span class="keyword">and</span> <span class="number">5</span>&gt;<span class="number">2</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">3</span> <span class="keyword">not</span> <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure><p><code>and 和 or</code> 的返回值不一定是<code>true 或者 false</code>，而是返回最后一个<strong>计算</strong>的表达式的值，作为整个表达式的值</p><p><code>not</code>返回结果一定是<code>true 或者 false</code></p><p>补充：<code>python</code>支持<code>访问符号'.'  和 +=，-=， *=， /=，//=， **=， ^=</code>，但是<strong>不支持++和–</strong></p><p>但是形式上可以写成<code>++ 和 --</code>， 但是一般有不同解释含义</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>i = <span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>++i<span class="comment">#解释为两个正号</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>+(+i)<span class="comment">#等价于++i</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>i++<span class="comment">#不支持，报错</span></span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span></span><br><span class="line">    i++</span><br><span class="line">       ^</span><br><span class="line">SyntaxError: invalid syntax</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>--i<span class="comment">#解释为两个负号</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>---i<span class="comment">#解释为三个负号</span></span><br><span class="line">-<span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>i--<span class="comment">#不支持，报错</span></span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span></span><br><span class="line">    i--</span><br><span class="line">       ^</span><br><span class="line">SyntaxError: invalid syntax</span><br></pre></td></tr></table></figure><h2 id="python-常用内置函数用法">python 常用内置函数用法</h2><p>内置函数不需要导入任何外部模块就可以直接使用，具有非常快的运行速度。</p><ul><li>通常使用<code>&gt;&gt;&gt; dir(__builtins__)</code>查看所有的内置函数和内置对象</li><li>使用<code>help(函数名)</code>可以查看某个函数的使用方法</li></ul><h3 id="类型转换与判断">类型转换与判断</h3><h4 id="bin-、oct-、hex">bin()、oct()、hex()</h4><p>内置函数<code>bin()、oct()、hex()</code>用来将整数转换成为二进制、八进制、十六进制，这三个函数都要求参数必须为<strong>整数</strong>，但是<strong>不要求一定是十进制</strong>，格式为<code>bin(x),oct(x),hex(x)</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">bin</span>(<span class="number">555</span>)</span><br><span class="line"><span class="string">&#x27;0b1000101011&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">oct</span>(<span class="number">555</span>)</span><br><span class="line"><span class="string">&#x27;0o1053&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">hex</span>(<span class="number">555</span>)</span><br><span class="line"><span class="string">&#x27;0x22b&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="float-、complex">float()、complex()</h4><p><code>float()</code>用来将其它类型数据转换为实数，格式为<code>float(x)</code>，x为数字或字符串</p><p><code>complex()</code>函数可以用来生成复数，格式为<code>complex(x, y)</code>，x和y分别代表实部和虚部，如果只有一个数字<code>complex(x)</code>，x代表实部</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">float</span>(<span class="number">3</span>)<span class="comment">#整数转换为实数</span></span><br><span class="line"><span class="number">3.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">float</span>(<span class="string">&#x27;3.5&#x27;</span>)<span class="comment">#数字字符转换为实数</span></span><br><span class="line"><span class="number">3.5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)<span class="comment">#无穷大，inf不区分大小写</span></span><br><span class="line">inf</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">complex</span>(<span class="number">3</span>)<span class="comment">#指定实部，创建复数</span></span><br><span class="line">(<span class="number">3</span>+<span class="number">0j</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">complex</span>(<span class="number">3</span>, <span class="number">5</span>)<span class="comment">#指定实部和虚部</span></span><br><span class="line">(<span class="number">3</span>+<span class="number">5j</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">complex</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">(inf+<span class="number">0j</span>)</span><br></pre></td></tr></table></figure><h4 id="int">int()</h4><p>内置函数<code>int()</code>用来获取实数的整体部分，或者把字符串按照指定的进制转换为十进制数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">int</span>(<span class="number">3.13</span>)<span class="comment">#获取整数部分</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">int</span>(<span class="string">&#x27;111&#x27;</span>, <span class="number">2</span>)<span class="comment">#按照二进制解析这个字符串，再换成十进制</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">int</span>(<span class="string">&#x27;1111&#x27;</span>, <span class="number">8</span>)<span class="comment">#八进制解析，换成十进制</span></span><br><span class="line"><span class="number">585</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">int</span>(<span class="string">&#x27;1234&#x27;</span>, <span class="number">16</span>)<span class="comment">#十六进制解析，换成十进制</span></span><br><span class="line"><span class="number">4660</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">int</span>(<span class="string">&#x27;0o1234&#x27;</span>, <span class="number">0</span>)<span class="comment">#0表示按照字符串自身指定的进制解析，这里按照八进制</span></span><br><span class="line"><span class="number">668</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">int</span>(<span class="string">&#x27;   345\n\t&#x27;</span>)<span class="comment">#忽略两侧空白符</span></span><br><span class="line"><span class="number">345</span></span><br></pre></td></tr></table></figure><h4 id="ord-、chr-、str">ord()、chr()、str()</h4><p><code>ord()</code>函数返回单个字符的ascll码，<code>chr()</code>函数返回asclll码对应的字符，<code>str()</code>函数直接将任意类型参数转换为字符串</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"><span class="number">97</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">chr</span>(<span class="number">65</span>)</span><br><span class="line"><span class="string">&#x27;A&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">str</span>(<span class="number">1234</span>)<span class="comment">#直接变成字符串类型</span></span><br><span class="line"><span class="string">&#x27;1234&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">str</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"><span class="string">&#x27;[1, 2, 3, 4]&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">str</span>((<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>))</span><br><span class="line"><span class="string">&#x27;(1, 2, 3)&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">str</span>(&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;)</span><br><span class="line"><span class="string">&#x27;&#123;1, 2, 3&#125;&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="list-、tuple-、dict-、set">list()、tuple()、dict()、set()</h4><p>同理，<code>list()、tuple()、dict()、set()</code>分别用来把参数指定的可迭代对象转换为列表、元组、字典、集合。或者不带参数的时候直接创建空列表、空元组、空字典、空集合。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">5</span>))</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">tuple</span>(_)<span class="comment">#_代表上一次的正确输出</span></span><br><span class="line">(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">dict</span>(<span class="built_in">zip</span>(<span class="string">&#x27;1234&#x27;</span>, <span class="string">&#x27;abcde&#x27;</span>))</span><br><span class="line">&#123;<span class="string">&#x27;1&#x27;</span>: <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;2&#x27;</span>: <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;3&#x27;</span>: <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;4&#x27;</span>: <span class="string">&#x27;d&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">set</span>(<span class="string">&#x27;1112234&#x27;</span>)<span class="comment">#自动去重</span></span><br><span class="line">&#123;<span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;1&#x27;</span>&#125;</span><br></pre></td></tr></table></figure><h4 id="eval">eval()</h4><p>内置函数<code>eval()</code>用来计算字符串的值，有时也可以用来实现类型转换</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">eval</span>(<span class="string">&#x27;3+5&#x27;</span>)</span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">eval</span>(<span class="string">b&#x27;3+5&#x27;</span>)<span class="comment">#引号前面加上b变成字节串</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">eval</span>(<span class="string">&#x27;9&#x27;</span>)</span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">eval</span>(<span class="string">&#x27;09&#x27;</span>)<span class="comment">#不合法的前导0</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">  File <span class="string">&quot;&lt;string&gt;&quot;</span>, line <span class="number">1</span></span><br><span class="line">    09</span><br><span class="line">    ^</span><br><span class="line">SyntaxError: leading zeros <span class="keyword">in</span> decimal integer literals are <span class="keyword">not</span> permitted; use an 0o prefix <span class="keyword">for</span> octal integers</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">int</span>(<span class="string">&#x27;09&#x27;</span>)</span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">str</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]))</span><br><span class="line">[<span class="string">&#x27;[&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;,&#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;,&#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;,&#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;]&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">eval</span>(<span class="built_in">str</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]))</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure><h4 id="type-、isinstance">type()、isinstance()</h4><p>内置函数<code>type() 和 isinstance()</code>可以查看和判断数据类型</p><p><code>type(obj), isinstance(obj, type)</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>([<span class="number">2</span>])</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;list&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(&#123;<span class="number">3</span>&#125;) <span class="keyword">in</span> (<span class="built_in">list</span>, <span class="built_in">tuple</span>, <span class="built_in">dict</span>)</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>(<span class="number">3</span>, <span class="built_in">int</span>)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>(<span class="number">3j</span>, (<span class="built_in">int</span>, <span class="built_in">float</span>, <span class="built_in">complex</span>))</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><h4 id="max-、min-、sum">max()、min()、sum()</h4><p><code>max()、min()、sum()</code>分别用于计算列表、元组和其它包含有限个可迭代对象中所有元素最大值，最小值以及所有元素之和</p><p>​下面代码生成十个随机数的列表，然后分别计算列表的最大值，最小值，所有元素之和，平均值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> choices</span><br><span class="line">a = choices(<span class="built_in">range</span>(<span class="number">1</span>,<span class="number">101</span>), k=<span class="number">10</span>)<span class="comment">#10个1~100之间的随机数</span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">max</span>(a),<span class="built_in">min</span>(a),<span class="built_in">sum</span>(a))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sum</span>(a)/<span class="built_in">len</span>(a))</span><br></pre></td></tr></table></figure><p><code>max()、min()</code>函数还支持key参数，key就是比较规则，可以是函数、lambda表达式或者其它类型的可调用对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">max</span>(<span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;111&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;2&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">max</span>([<span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;111&#x27;</span>])<span class="comment">#列表的元素是字符串，按照字典序比较</span></span><br><span class="line"><span class="string">&#x27;2&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">max</span>([<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;111&#x27;</span>], key=<span class="built_in">len</span>)</span><br><span class="line"><span class="string">&#x27;111&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="基本输入和输出">基本输入和输出</h3><p><code>input() 和 output()</code>是python的基本输入输出函数，<code>input()</code>用于接收用户键盘输入，<code>output()</code>用于把数据按照指定的格式输出的指定位置。</p><p>不论输入什么内容，<code>input()</code>一律返回字符串，必要的时候需要用到<code>int()、float()、eval()</code>等函数进行输入转换</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = <span class="built_in">input</span>(<span class="string">&#x27;please input: &#x27;</span>)<span class="comment">#输入提示</span></span><br><span class="line">please <span class="built_in">input</span>: <span class="number">345</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line"><span class="string">&#x27;345&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(x)</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;str&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">int</span>(x)</span><br><span class="line"><span class="number">345</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">eval</span>(x)</span><br><span class="line"><span class="number">345</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = <span class="built_in">input</span>(<span class="string">&#x27;please input: &#x27;</span>)</span><br><span class="line">please <span class="built_in">input</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line"><span class="string">&#x27;[1, 2, 3]&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(x)</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;str&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">eval</span>(x)<span class="comment">#这里不要用list()转换，否则变成下面那样</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(x)</span><br><span class="line">[<span class="string">&#x27;[&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;,&#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;,&#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;]&#x27;</span>]</span><br></pre></td></tr></table></figure><p><code>print()</code>函数默认格式:</p><p><code>print(value1, value2, value3, ..., sep=' ', end='\n', file=sys.stdout, flush=False)</code></p><ul><li><code>sep</code>参数为分隔符，默认为空格，可以修改为指定样式</li><li><code>end</code>参数为结束符，默认为换行符</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, sep=<span class="string">&#x27;\t&#x27;</span>)<span class="comment">#分隔为tab</span></span><br><span class="line"><span class="number">1</span><span class="number">3</span><span class="number">5</span><span class="number">7</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    <span class="built_in">print</span>(i, end=<span class="string">&#x27; &#x27;</span>)<span class="comment">#每次打印不换行</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span></span><br></pre></td></tr></table></figure><h3 id="排序与逆序">排序与逆序</h3><p><code>sorted()</code>函数可以对列表，元组，字典，集合或者其它有限长度的可迭代对象进行排序并且返回新列表，支持<strong>key</strong>参数指定排序规则，</p><p><code>sorted()</code> 函数有三个参数：<code>iterable</code>、<code>key</code> 和 <code>reverse</code>。其中 <code>iterable</code> 是必需的序列，而 <code>key</code> 和 <code>reverse</code> 是可选的。</p><p><code>sorted(iterable, key = None, reverse = False)</code></p><ul><li><code>iterable</code>: 必需。要排序的序列（列表、元组、字符串）或集合（字典、集合、冻结集合）或任何其他迭代器。</li><li><code>key</code>: 可选。用于确定排序顺序的函数。默认值为 <code>None</code>。</li><li><code>reverse</code>: 可选。布尔值。如果为 <code>False</code>，则按升序排列；如果为 <code>True</code>，则按降序排列。默认值为 <code>False</code>。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">11</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> random</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>random.shuffle(x)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line">[<span class="number">8</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">10</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sorted</span>(x)</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sorted</span>(x, key=<span class="keyword">lambda</span> item:<span class="built_in">len</span>(<span class="built_in">str</span>(item)), reverse=<span class="literal">True</span>)</span><br><span class="line"><span class="comment">#转换为字符串长度之后，按照降序排列</span></span><br><span class="line">[<span class="number">10</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sorted</span>(x,key=<span class="built_in">str</span>)<span class="comment">#字符串升序</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x<span class="comment">#排序之后并不会改变原本的序列</span></span><br><span class="line">[<span class="number">8</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">10</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = [<span class="string">&#x27;aaaa&#x27;</span>, <span class="string">&#x27;bc&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;ba&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sorted</span>(x, key=<span class="keyword">lambda</span> item: (<span class="built_in">len</span>(item), item))</span><br><span class="line"><span class="comment">#多关键字排序，先长度，再正常比较（字典序）</span></span><br><span class="line">[<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;ba&#x27;</span>, <span class="string">&#x27;bc&#x27;</span>, <span class="string">&#x27;aaaa&#x27;</span>]</span><br></pre></td></tr></table></figure><p><code>reversed()</code>函数可以对可迭代对象（生成器对象和zip、map、filter、enumerate等类似迭代器对象除外）进行翻转（首尾交换）并返回可迭代的reversed对象，不会改变原始序列</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = [<span class="string">&#x27;aaaa&#x27;</span>, <span class="string">&#x27;bc&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;ba&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">reversed</span>(x))<span class="comment">#reversed对象是迭代器对象，返回值</span></span><br><span class="line">[<span class="string">&#x27;ba&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;bc&#x27;</span>, <span class="string">&#x27;aaaa&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">reversed</span>(x)</span><br><span class="line">&lt;list_reverseiterator <span class="built_in">object</span> at <span class="number">0x00000241DFBD6980</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> item <span class="keyword">in</span> <span class="built_in">reversed</span>(x):<span class="comment">#这里有点类似c语言的指针和数组？（不是很懂，但是感觉可以类比）</span></span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(item, end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">...</span><br><span class="line">ba b d bc aaaa</span><br></pre></td></tr></table></figure><h3 id="枚举与迭代">枚举与迭代</h3><p><code>enumerate()</code>函数可以用来枚举可迭代对象中的元素，返回可迭代的enumerate对象，其中每个元素都是包含索引和值的元组。</p><p>既可以把enumerate转换成为列表，元组 ，集合，也可以直接用for循环遍历其中的元素</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">enumerate</span>(<span class="string">&#x27;abcd&#x27;</span>)</span><br><span class="line">&lt;<span class="built_in">enumerate</span> <span class="built_in">object</span> at <span class="number">0x00000241DF814F80</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">enumerate</span>(<span class="string">&#x27;abcd&#x27;</span>))</span><br><span class="line">[(<span class="number">0</span>, <span class="string">&#x27;a&#x27;</span>), (<span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>), (<span class="number">2</span>, <span class="string">&#x27;c&#x27;</span>), (<span class="number">3</span>, <span class="string">&#x27;d&#x27;</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">enumerate</span>([<span class="string">&#x27;your&#x27;</span>, <span class="string">&#x27;name&#x27;</span>]))</span><br><span class="line">[(<span class="number">0</span>, <span class="string">&#x27;your&#x27;</span>), (<span class="number">1</span>, <span class="string">&#x27;name&#x27;</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> index, value <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="built_in">range</span>(<span class="number">10</span>,<span class="number">15</span>)):</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>((index,value), end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">...</span><br><span class="line">(<span class="number">0</span>, <span class="number">10</span>) (<span class="number">1</span>, <span class="number">11</span>) (<span class="number">2</span>, <span class="number">12</span>) (<span class="number">3</span>, <span class="number">13</span>) (<span class="number">4</span>, <span class="number">14</span>)</span><br></pre></td></tr></table></figure><h3 id="map-、reduce-、filter-函数">map()、reduce()、filter()函数</h3><p>内置函数<code>map()</code>把一个可调用对象<code>func</code>依次映射到一个或者多个可迭代对象的每个元素上，返回一个<code>map</code>对象，<code>map</code>对象属于迭代器类型，其中每个元素是原可迭代对象元素经过<code>func</code>处理后的结果，不对原可迭代对象做任何修改</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">str</span>, <span class="built_in">range</span>(<span class="number">5</span>)))<span class="comment">#把range对象中的元素转换为字符串</span></span><br><span class="line">[<span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;4&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">add5</span>(<span class="params">v</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> v+<span class="number">5</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">map</span>(add5,<span class="built_in">range</span>(<span class="number">10</span>)))<span class="comment">#把单参数函数映射到一个可迭代对象的所有元素</span></span><br><span class="line">[<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">x, y</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> x+y</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">map</span>(add, <span class="built_in">range</span>(<span class="number">5</span>), <span class="built_in">range</span>(<span class="number">5</span>, <span class="number">10</span>)))<span class="comment">#把双参数函数映射到两个可迭代对象上</span></span><br><span class="line">[<span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">11</span>, <span class="number">13</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x, y: x+y, <span class="built_in">range</span>(<span class="number">5</span>), <span class="built_in">range</span>(<span class="number">5</span>, <span class="number">10</span>)))</span><br><span class="line"><span class="comment">#使用lambda同样实现功能，这个lambda表达式相当于一个函数</span></span><br><span class="line">[<span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">11</span>, <span class="number">13</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> random</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = random.randint(<span class="number">1</span>, <span class="number">1e30</span>)<span class="comment">#生成指定范围内的随机数</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line"><span class="number">666450695718944706028625082522</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">str</span>(x)))<span class="comment">#提取大整数每位上的数字</span></span><br><span class="line">[<span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">2</span>]</span><br></pre></td></tr></table></figure><p>标准库<code>functools</code>中的函数<code>reduce()</code>可以将一个接收<strong>两个参数的函数</strong>以迭代的方式<strong>从左往右</strong>依次作用到一个<strong>序列</strong>或者<strong>迭代器对象</strong>的所有元素上，并且允许指定一个初始值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>reduce(<span class="keyword">lambda</span> x, y: x+y, <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">8</span>))<span class="comment">#lambda表达式相当于函数</span></span><br><span class="line">这个程序的执行等效于((((((<span class="number">1</span>+<span class="number">2</span>)+<span class="number">3</span>)+<span class="number">4</span>)+<span class="number">5</span>)+<span class="number">6</span>)+<span class="number">7</span>)</span><br></pre></td></tr></table></figure><p>内置函数<code>filter()</code>将一个单参数函数作用到一个可迭代对象上，返回其中使得该函数返回值等价于<code>True</code>的那些元素组成的filter对象，如果指定函数为<code>None</code>，则返回可迭代对象中等价于<code>True</code>的元素。filter对象是迭代器对象，在使用时可以把filter对象转换为列表，元组，集合，也可以使用for循环直接遍历其中的元素</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>seq = [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;x41&#x27;</span>, <span class="string">&#x27;?!&#x27;</span>, <span class="string">&#x27;***&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">x</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> x.isalnum()<span class="comment">#isalnum()是字符串的方法，用于测试x是否包含字母或者数字</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">filter</span>(func, seq)</span><br><span class="line">&lt;<span class="built_in">filter</span> <span class="built_in">object</span> at <span class="number">0x000001F5CDE06EC0</span>&gt;<span class="comment">#返回filter对象</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">filter</span>(func, seq))</span><br><span class="line">[<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;x41&#x27;</span>]<span class="comment">#filter对象转换为列表</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">filter</span>(<span class="built_in">str</span>.isalnum, seq))<span class="comment">#也可以这样直接使用isalnum</span></span><br><span class="line">[<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;x41&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>seq<span class="comment">#不改变原有的列表</span></span><br><span class="line">[<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;x41&#x27;</span>, <span class="string">&#x27;?!&#x27;</span>, <span class="string">&#x27;***&#x27;</span>]</span><br></pre></td></tr></table></figure><h3 id="range-函数">range()函数</h3><p><code>range()</code>是python常用的一个内置函数，有三种用法，下面的step解释为<strong>步数</strong></p><ol><li><code>range(stop)</code>，默认起始数字为<strong>0</strong>，结束数字为<strong>stop-1</strong>，步数默认为<strong>1</strong></li><li><code>range(start, stop)</code>，起始数字<strong>start</strong>，结束数字<strong>stop-1</strong>，步数默认为<strong>1</strong></li><li><code>range(start, stop, step)</code>，起始数字<strong>start</strong>，结束数字<strong>stop-1</strong>，步数默认为<strong>step</strong></li></ol><p>ps：当<code>step &lt; 0</code>时，start应该比stop大</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">range</span>(<span class="number">5</span>)</span><br><span class="line"><span class="built_in">range</span>(<span class="number">0</span>, <span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(_)<span class="comment">#_代表上一次的正确输出</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>, <span class="number">2</span>))</span><br><span class="line">[<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">9</span>, <span class="number">0</span>, -<span class="number">2</span>))<span class="comment">#step是负数，start比stop大</span></span><br><span class="line">[<span class="number">9</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(<span class="number">3</span>,end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">...</span><br><span class="line"><span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><h3 id="zip-函数">zip()函数</h3><p><code>zip()</code>函数用来把多个可迭代对象中对应位置上的元素组合到一起，返回一个zip对象，其中每个元素都是包含原来多个可迭代对象对应位置上元素的<strong>元组</strong>，最终结果zip对象中包含的元素个数取决于所有参数可迭代对象中<strong>最短</strong>的那个</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">zip</span>(<span class="string">&#x27;abcd&#x27;</span>, <span class="string">&#x27;1234&#x27;</span>)<span class="comment">#返回zip对象，形成元组</span></span><br><span class="line">&lt;<span class="built_in">zip</span> <span class="built_in">object</span> at <span class="number">0x000001F5CDE33F00</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">zip</span>(<span class="string">&#x27;abcd&#x27;</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]))<span class="comment">#取可迭代对象中最短的那个</span></span><br><span class="line">[(<span class="string">&#x27;a&#x27;</span>, <span class="number">1</span>), (<span class="string">&#x27;b&#x27;</span>, <span class="number">2</span>), (<span class="string">&#x27;c&#x27;</span>, <span class="number">3</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">zip</span>(<span class="string">&#x27;abcd&#x27;</span>))</span><br><span class="line">[(<span class="string">&#x27;a&#x27;</span>,), (<span class="string">&#x27;b&#x27;</span>,), (<span class="string">&#x27;c&#x27;</span>,), (<span class="string">&#x27;d&#x27;</span>,)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">zip</span>(<span class="string">&#x27;123&#x27;</span>,  <span class="string">&#x27;abc&#x27;</span>, <span class="string">&#x27;,.!&#x27;</span>))</span><br><span class="line">[(<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;,&#x27;</span>), (<span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;.&#x27;</span>), (<span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;!&#x27;</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> item <span class="keyword">in</span> <span class="built_in">zip</span>(<span class="string">&#x27;abcd&#x27;</span>, <span class="built_in">range</span>(<span class="number">3</span>)):</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(item, end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">...</span><br><span class="line">(<span class="string">&#x27;a&#x27;</span>, <span class="number">0</span>) (<span class="string">&#x27;b&#x27;</span>, <span class="number">1</span>) (<span class="string">&#x27;c&#x27;</span>, <span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = <span class="built_in">zip</span>(<span class="string">&#x27;abcd&#x27;</span>, <span class="string">&#x27;1234&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(x)</span><br><span class="line">[(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;1&#x27;</span>), (<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;2&#x27;</span>), (<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;3&#x27;</span>), (<span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;4&#x27;</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(x)<span class="comment">#zip对象只能遍历一次，访问过的元素就不复存在了</span></span><br><span class="line">[]</span><br></pre></td></tr></table></figure><p>ps：zip、enumerate、filter、map对象，以及生成器对象都有上述特点，遍历一次之后，访问过的元素不复存在，这里的访问指的是访问到元素，而不是访问对象</p><h1>python序列结构</h1><h2 id="python序列结构概述">python序列结构概述</h2><p>python序列属于容器类结构，类似于其他语言中的数组</p><p>有序序列：列表，元组，字符串------可以直接使用整数<strong>索引</strong>取访问指定位置，支持切片</p><p>无序序列：字典，集合</p><p>可变序列：列表，字典，集合-------可以修改元素的<strong>引用</strong>，可以增加或者删除元素</p><h2 id="列表">列表</h2><p>列表是包含若干元素的<strong>有序连续内存</strong>空间。同一个列表可以同时包含多种数据类型，同时含义整数，实数，字符串，列表，元组，字典，集合，函数以及其他的任意对象。<code>[]</code>表示空列表</p><h3 id="列表的创建与删除">列表的创建与删除</h3><p>使用 <code>=</code> 直接赋值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a_list = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a_list = []</span><br></pre></td></tr></table></figure><p>使用<code>list()</code>函数把元组、range对象、字符串、字典、集合或其它有限长度的<strong>可迭代对象</strong>转换为列表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>((<span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">9</span>))<span class="comment">#元组转列表</span></span><br><span class="line">[<span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">9</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>, <span class="number">2</span>))<span class="comment">#range对象转列表</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="string">&#x27;hello world&#x27;</span>)<span class="comment">#字符串转列表</span></span><br><span class="line">[<span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;w&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;d&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(&#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>&#125;)<span class="comment">#集合转列表</span></span><br><span class="line">[<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(&#123;<span class="string">&#x27;a&#x27;</span>:<span class="number">3</span>, <span class="string">&#x27;b&#x27;</span>:<span class="number">4</span>, <span class="string">&#x27;c&#x27;</span>:<span class="number">5</span>&#125;)<span class="comment">#字典中的“键”转列表</span></span><br><span class="line">[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(&#123;<span class="string">&#x27;a&#x27;</span>:<span class="number">3</span>, <span class="string">&#x27;b&#x27;</span>:<span class="number">4</span>, <span class="string">&#x27;c&#x27;</span>:<span class="number">6</span>&#125;.items())<span class="comment">#字典中的元素转列表</span></span><br><span class="line">[(<span class="string">&#x27;a&#x27;</span>, <span class="number">3</span>), (<span class="string">&#x27;b&#x27;</span>, <span class="number">4</span>), (<span class="string">&#x27;c&#x27;</span>, <span class="number">6</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = <span class="built_in">list</span>()<span class="comment">#创建空列表</span></span><br></pre></td></tr></table></figure><p>当一个列表不再使用，可以使用del命令删除</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> x<span class="comment">#删除列表对象</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x<span class="comment">#删除后无法再访问，报错</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">NameError: name <span class="string">&#x27;x&#x27;</span> <span class="keyword">is</span> <span class="keyword">not</span> defined</span><br></pre></td></tr></table></figure><h3 id="列表元素访问">列表元素访问</h3><p>列表属于有序序列，可以使用整数作为下标随机访问任意位置上的元素，0下标表示第一个元素（以此类推，和c语言数组类似）</p><p>列表还支持<strong>负整数</strong>作为下标，-1表示最后一个元素，-2表示最后第二个元素，以此类推，支持反向索引</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = <span class="built_in">list</span>(<span class="string">&#x27;python&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line">[<span class="string">&#x27;p&#x27;</span>, <span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;t&#x27;</span>, <span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;n&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x[<span class="number">1</span>]</span><br><span class="line"><span class="string">&#x27;y&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x[-<span class="number">3</span>]</span><br><span class="line"><span class="string">&#x27;h&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="列表常用方法">列表常用方法</h3><p>列表常用方法（method）（这里对method进行解释：python中，属性是对象的状态，方法是对象的行为，属性是对象的变量，方法是对象的函数）</p><h4 id="append-、insert-、extend">append()、insert()、extend()</h4><p><code>append()</code>方法用于向列表尾部<strong>追加</strong>一个元素（强调<strong>元素整体</strong>），格式<code>list.append(x)</code></p><p><code>insert()</code>方法用于向列表<strong>任意指定位置</strong>插入一个元素，<code>list.insert(index, obj)</code>，这里也强调<strong>元素</strong></p><p><code>extend()</code>方法用于将另一个<strong>可迭代对象</strong>中的<strong>所有元素</strong>追加至当前列表尾部（强调其中的元素），<code>list.extend(可迭代对象)</code></p><p>三个方法都没有返回值，但是会修改原本的列表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x.append(<span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x.insert(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x.extend([<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x.append(&#123;<span class="number">1</span>, <span class="number">2</span>&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, &#123;<span class="number">1</span>, <span class="number">2</span>&#125;]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x.extend(&#123;<span class="number">1</span>, <span class="number">2</span>&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, &#123;<span class="number">1</span>, <span class="number">2</span>&#125;, <span class="number">1</span>, <span class="number">2</span>]</span><br></pre></td></tr></table></figure><h4 id="pop-、remove-、del">pop()、remove() 、del</h4><p><code>pop()</code>方法用于<strong>删除并返回</strong>指定位置（默认最后一个）的元素，如果指定位置不是合法索引则抛出异常，格式为<code>list.pop(index)</code>，如果不填写index，那么默认为-1，也就是最后一个元素</p><p><code>remove()</code>方法用于删除列表中<strong>第一个值与参数相等的元素</strong>，如果列表中<strong>不存在</strong>该元素则抛出异常，格式为<code>list.remove(obj)</code>，<code>obj</code>是元素，可以任意指定类型（应该）</p><p><code>del</code><strong>命令</strong>（不是方法）用于删除列表指定位置的<strong>单个元素</strong>，格式为<code>del listname[index]</code>，如果要删除多个元素可以用切片</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x.pop()</span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x.pop(<span class="number">0</span>)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x.remove(<span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line">[<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> x[<span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line">[<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure><h4 id="count-、index">count()、index()</h4><p><code>count()</code>方法用于返回列表中指定元素出现的次数，格式为<code>list.count(obj)</code>（如果列表中不存在就返回0）</p><p><code>index()</code>方法用于返回指定<strong>元素</strong>在列表中<strong>首次</strong>出现的位置，如果该元素不在列表中就抛出异常，格式为<code>list.index(x[,start[,end]])</code></p><ul><li>没有start和end参数，范围默认整个列表</li><li>只有start参数<code>list.index(x, start)</code>，从start开始到列表尾部（包括start下标）</li><li>不能只有end参数，而没有start参数。同时start和end参数格式为<code>list.index(x, start, end)</code></li><li>区间搜索范围<code>[start, end)</code>左闭右开</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x.count(<span class="number">3</span>)</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x.index(<span class="number">2</span>)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x.index(<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x.index(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">ValueError: <span class="number">2</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">in</span> <span class="built_in">list</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x.index(<span class="number">4</span>)</span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x.index(<span class="number">4</span>,<span class="number">0</span>,<span class="number">5</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">ValueError: <span class="number">4</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">in</span> <span class="built_in">list</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x.index(<span class="number">4</span>, <span class="number">0</span>, <span class="number">6</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">ValueError: <span class="number">4</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">in</span> <span class="built_in">list</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x.index(<span class="number">4</span>, <span class="number">0</span> ,<span class="number">7</span>)</span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure><h3 id="列表对象支持的运算符">列表对象支持的运算符</h3><p><code>+</code>可以连接两个列表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = x + [<span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line">[<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure><p><code>*</code>可以用于正整数和列表相乘，表示序列的重复</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = x * <span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure><p><code>in</code>进行成员测试，是否包含某个元素</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">3</span> <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">3</span> <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="string">&#x27;3&#x27;</span>]</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure><p>关系运算符可以用来比较两个列表大小</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>] &gt; [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>]</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>] == [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>]</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure><h3 id="内置函数对列表的操作（举例集合）">内置函数对列表的操作（举例集合）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">11</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> random</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>random.shuffle(x)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line">[<span class="number">3</span>, <span class="number">6</span>, <span class="number">10</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">9</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">all</span>(x)</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">any</span>(x)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">max</span>(x)</span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">min</span>(x)</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">max</span>(x, key=<span class="built_in">str</span>)</span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sum</span>(x)</span><br><span class="line"><span class="number">55</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">len</span>(x)</span><br><span class="line"><span class="number">11</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">zip</span>(x, [<span class="number">1</span>]*<span class="number">11</span>))</span><br><span class="line">[(<span class="number">3</span>, <span class="number">1</span>), (<span class="number">6</span>, <span class="number">1</span>), (<span class="number">10</span>, <span class="number">1</span>), (<span class="number">8</span>, <span class="number">1</span>), (<span class="number">4</span>, <span class="number">1</span>), (<span class="number">2</span>, <span class="number">1</span>), (<span class="number">0</span>, <span class="number">1</span>), (<span class="number">5</span>, <span class="number">1</span>), (<span class="number">7</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">1</span>), (<span class="number">9</span>, <span class="number">1</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">zip</span>(<span class="built_in">range</span>(<span class="number">1</span>, <span class="number">4</span>)))</span><br><span class="line">[(<span class="number">1</span>,), (<span class="number">2</span>,), (<span class="number">3</span>,)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">zip</span>([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>], [<span class="number">1</span>, <span class="number">2</span>]))</span><br><span class="line">[(<span class="string">&#x27;a&#x27;</span>, <span class="number">1</span>), (<span class="string">&#x27;b&#x27;</span>, <span class="number">2</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">enumerate</span>(x))</span><br><span class="line">[(<span class="number">0</span>, <span class="number">3</span>), (<span class="number">1</span>, <span class="number">6</span>), (<span class="number">2</span>, <span class="number">10</span>), (<span class="number">3</span>, <span class="number">8</span>), (<span class="number">4</span>, <span class="number">4</span>), (<span class="number">5</span>, <span class="number">2</span>), (<span class="number">6</span>, <span class="number">0</span>), (<span class="number">7</span>, <span class="number">5</span>), (<span class="number">8</span>, <span class="number">7</span>), (<span class="number">9</span>, <span class="number">1</span>), (<span class="number">10</span>, <span class="number">9</span>)]</span><br></pre></td></tr></table></figure><h3 id="列表推导式">列表推导式</h3><p>列表推导式可以使用非常简洁的方式对列表或其它可迭代对象的元素进行遍历，过滤或者再次计算，快速生成满足特定需求的新列表</p><p>列表推导式逻辑上等价于一个循环语句，只是形式上更加简洁</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>aList = [x+x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">30</span>)]</span><br><span class="line">相当于</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>aList = []</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">30</span>):</span><br><span class="line"><span class="meta">... </span>    aList.append(x+x)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>freshFruit = [<span class="string">&#x27; banana&#x27;</span>, <span class="string">&#x27;loganberry &#x27;</span>, <span class="string">&#x27;passion fruit &#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>aList = [w.strip() <span class="keyword">for</span> w <span class="keyword">in</span> freshFruit]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>aList</span><br><span class="line">[<span class="string">&#x27;banana&#x27;</span>, <span class="string">&#x27;loganberry&#x27;</span>, <span class="string">&#x27;passion fruit&#x27;</span>]</span><br><span class="line">相当于</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>aList = []</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> item <span class="keyword">in</span> freshFruit:</span><br><span class="line"><span class="meta">... </span>    aList.append(item.strip())<span class="comment">#字符串方法strip()用来删除两侧空白符</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>aList</span><br><span class="line">[<span class="string">&#x27;banana&#x27;</span>, <span class="string">&#x27;loganberry&#x27;</span>, <span class="string">&#x27;passion fruit&#x27;</span>]</span><br></pre></td></tr></table></figure><p>eg1：使用列表推导式实现嵌套列表的平铺</p><p>先遍历列表中嵌套的子列表，然后遍历子列表中的元素进行展开</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>vec = [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[num <span class="keyword">for</span> elem <span class="keyword">in</span> vec <span class="keyword">for</span> num <span class="keyword">in</span> elem]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>result = []</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> elem <span class="keyword">in</span> vec:</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">for</span> num <span class="keyword">in</span> elem:</span><br><span class="line"><span class="meta">... </span>            result.append(num)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>result</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br></pre></td></tr></table></figure><p>eg2：在列表推导式中使用<code>if</code>过滤掉不符号要求的元素，例子过于复杂就不写了（写了也无法理解，后面会学吧应该）</p><h3 id="切片">切片</h3><p>切片也可以适用于元组，字符串，range对象等，但是列表的切片具有非常强大的功能</p><p>切片形式<code>[start:end:step]</code>-----貌似和列表的index方法很像，<code>list.index(x[,start[,end]])</code></p><p>start表示起始位置，默认为0（step&gt;0时）或者-1（step&lt;0时）</p><p>end默认为列表长度（step&gt;0时），区间为<code>[start,end)</code>，左闭右开</p><p>start为0时可以省略，end为列表长度时可以省略，step为1时可以省略（省略步长时要省略最后一个冒号）</p><p>step为负整数时，表示负切片，此时start需要在end右侧</p><p>一：使用切片获取列表中部分元素</p><p>使用切片可以返回列表中部分元素组成的新列表，切片超出原列表范围时不会报错，系统会自行截断</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>aList = [<span class="number">3</span>, <span class="number">4</span> ,<span class="number">5</span> ,<span class="number">6</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">15</span>, <span class="number">17</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>aList[::]<span class="comment">#返回原列表中所有元素组成的新列表</span></span><br><span class="line">[<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">15</span>, <span class="number">17</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>aList[::-<span class="number">1</span>]<span class="comment">#返回逆向的新列表</span></span><br><span class="line">[<span class="number">17</span>, <span class="number">15</span>, <span class="number">13</span>, <span class="number">11</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>aList[::<span class="number">2</span>]<span class="comment">#每隔一个取一个元素</span></span><br><span class="line">[<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>aList[<span class="number">3</span>:<span class="number">6</span>]<span class="comment">#范围下标从3~5</span></span><br><span class="line">[<span class="number">6</span>, <span class="number">7</span>, <span class="number">9</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>aList[<span class="number">0</span>:<span class="number">100</span>]<span class="comment">#越界自动截断</span></span><br><span class="line">[<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">15</span>, <span class="number">17</span>]</span><br></pre></td></tr></table></figure><p>二：使用切片为列表增加元素</p><p>使用切片为列表任意位置添加新元素，<strong>不影响列表对象的存储地址，属于原地操作</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>aList = [<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>aList[<span class="built_in">len</span>(aList):]<span class="comment">#取的范围越界了，返回空列表</span></span><br><span class="line">[]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>aList[<span class="built_in">len</span>(aList):] = [<span class="number">9</span>]<span class="comment">#在新位置直接赋值</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>aList[:<span class="number">0</span>] = [<span class="number">1</span>, <span class="number">2</span>]<span class="comment">#直接插入到下标为0的位置</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>aList[<span class="number">3</span>:<span class="number">3</span>] = [<span class="number">4</span>]<span class="comment">#直接插入到下标为3的位置</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>aList</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>]</span><br></pre></td></tr></table></figure><p>相应的还有替换，修改，删除列表中的元素，用法都很相似，都是利用切片返回一个位置，对某个位置进行修改，也可以和<code>del</code>命令结合使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; aList = [3, 5, 7, 9, 11]</span><br><span class="line">&gt;&gt;&gt; del aList[:3]</span><br><span class="line">&gt;&gt;&gt; aList</span><br><span class="line">[9, 11]</span><br><span class="line">&gt;&gt;&gt; aList = [3, 5, 6, 7, 9]</span><br><span class="line">&gt;&gt;&gt; del aList[::2]</span><br><span class="line">&gt;&gt;&gt; aList</span><br><span class="line">[5, 7]</span><br></pre></td></tr></table></figure><h2 id="元组和生成器表达式">元组和生成器表达式</h2><h3 id="元组创建与元素访问">元组创建与元素访问</h3><p>可以把元组看作是轻量级的列表，支持和列表中类似的操作，但是功能更加强大</p><p>形式上，所有元素放在一对圆括号内，元素之间使用逗号相隔，只有一个元素时必须在最后位置加上一个逗号</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(x)</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;tuple&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x[<span class="number">0</span>]<span class="comment">#支持下标的双向访问</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x[-<span class="number">1</span>]</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x[<span class="number">1</span>] = <span class="number">4</span><span class="comment">#元组中元素的引用不可变</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: <span class="string">&#x27;tuple&#x27;</span> <span class="built_in">object</span> does <span class="keyword">not</span> support item assignment</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = (<span class="number">3</span>,)<span class="comment">#一个元素必须有一个逗号</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line">(<span class="number">3</span>,)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = ()<span class="comment">#空元组</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = <span class="built_in">tuple</span>()<span class="comment">#空元组</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">tuple</span>(<span class="built_in">range</span>(<span class="number">5</span>))<span class="comment">#把其它可迭代对象转换为元组</span></span><br><span class="line">(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure><h3 id="元组和列表的异同点">元组和列表的异同点</h3><p><strong>相同点</strong>：都是有序序列，支持下标的双向索引，可以使用<code>count(),index()</code>方法，可以使用<code>len(),map(),filter()</code>等大量内置函数，以及<code>+,*,in</code>运算符操作</p><p><strong>不同点</strong>：元组是不可变序列，不能改变顺序，不能修改元素的引用，<strong>无法增添或者删除元素</strong>，支持切片访问，但是切片不能用来修改访问。</p><p>因此元组可以视作“常量列表”，“静态列表”</p><p>作为不可变序列，元组和整数，字符串一样，可以<strong>作为字典的键</strong>，或者作为集合的元素</p><h3 id="生成器表达式">生成器表达式</h3><p>生成器表达式（generator expression）的语法与列表推导式非常相似，形式上使用圆括号作为定界符。</p><p>生成器表达式的结果是一个生成器对象，具有<strong>惰性求值</strong>的特点，只在需要时生成新元素（每个元素只生成一次），比列表推导式效率更高，占用空间非常少，适合大数据处理</p><p>对于生成器对象，可以转化为列表或者元组，也可以使用生成器对象的<code>__next()__</code>方法或者内置函数<code>next()</code>进行遍历，或者直接使用for循环遍历，但是只能从前往后，没有任何方法访问已经访问过的元素，也不支持下标访问。</p><hr><p><strong>当所有元素都被访问过后，如果需要再次访问，需要重新创建生成器对象，</strong><code>enumerate、filter、map、zip</code><strong>等其它迭代器对象也具有同样的特点</strong></p><hr><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>g = ((i+<span class="number">2</span>)**<span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>))<span class="comment">#创建生成器对象</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g</span><br><span class="line">&lt;generator <span class="built_in">object</span> &lt;genexpr&gt; at <span class="number">0x000001D98DDE9A10</span>&gt;<span class="comment">#at后面是地址</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">tuple</span>(g)<span class="comment">#转换为元组，</span></span><br><span class="line">(<span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>, <span class="number">100</span>, <span class="number">121</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(g)<span class="comment">#不可二次访问</span></span><br><span class="line">[]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g = ((i+<span class="number">2</span>)**<span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>))<span class="comment">#重新创建</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(g)</span><br><span class="line">[<span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>, <span class="number">100</span>, <span class="number">121</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g = ((i+<span class="number">2</span>)**<span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g.__next__()<span class="comment">#使用__next__()方法访问</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g.__next__()</span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(g)<span class="comment">#使用next()函数访问</span></span><br><span class="line"><span class="number">16</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g = ((i+<span class="number">2</span>)**<span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> item <span class="keyword">in</span> g:<span class="comment">#使用for循环访问</span></span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(item, end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">...</span><br><span class="line"><span class="number">4</span> <span class="number">9</span> <span class="number">16</span> <span class="number">25</span> <span class="number">36</span> <span class="number">49</span> <span class="number">64</span> <span class="number">81</span> <span class="number">100</span> <span class="number">121</span> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g = <span class="built_in">map</span>(<span class="built_in">str</span>, <span class="built_in">range</span>(<span class="number">20</span>))<span class="comment">#构造map迭代器对象</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;2&#x27;</span> <span class="keyword">in</span> g<span class="comment">#一次&#x27;in&#x27;判断会把整个对象访问一遍</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;2&#x27;</span> <span class="keyword">in</span> g<span class="comment">#访问过一次没了</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;8&#x27;</span> <span class="keyword">in</span> g<span class="comment">#没了</span></span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure><h2 id="字典">字典</h2><p>字典是包含若干个“键:值”元素的无序可变序列，每个元素包含“键”和“值”两个部分，表示一种映射或者是对应关系，也称作关联数组，不同元素以逗号分隔</p><p>“键”可以是python中任意<strong>不可变数据</strong>，比如整数，实数，复数，字符串，元组等类型作为散列数据</p><p>其它可变类型比如列表，集合，字典等不能作为“键”</p><p>“键”不允许重复，但是“值”允许重复，类似于一个hash映射</p><h3 id="字典的创建与删除">字典的创建与删除</h3><p>使用<code>=</code>直接赋值给一个变量，或者使用内置类<code>dict</code>以不同形式创建字典，可以使用del命令直接删除</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>aDict = &#123;<span class="string">&#x27;server&#x27;</span>: <span class="string">&#x27;db.diver&#x27;</span>, <span class="string">&#x27;database&#x27;</span>: <span class="string">&#x27;mysql&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>aDict</span><br><span class="line">&#123;<span class="string">&#x27;server&#x27;</span>: <span class="string">&#x27;db.diver&#x27;</span>, <span class="string">&#x27;database&#x27;</span>: <span class="string">&#x27;mysql&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = <span class="built_in">dict</span>()<span class="comment">#空字典</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = &#123;&#125;<span class="comment">#空字典</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>keys = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = <span class="built_in">dict</span>(<span class="built_in">zip</span>(keys, values))<span class="comment">#使用zip进行映射</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d</span><br><span class="line">&#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;d&#x27;</span>: <span class="number">4</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = <span class="built_in">dict</span>(name=<span class="string">&#x27;Dong&#x27;</span>, age=<span class="number">39</span>)<span class="comment">#以关键参数的形式创建字典</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d</span><br><span class="line">&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Dong&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">39</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>aDict = <span class="built_in">dict</span>.fromkeys([<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;age&#x27;</span>, <span class="string">&#x27;sex&#x27;</span>])<span class="comment">#创建”值“为空的字典</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>aDict</span><br><span class="line">&#123;<span class="string">&#x27;name&#x27;</span>: <span class="literal">None</span>, <span class="string">&#x27;age&#x27;</span>: <span class="literal">None</span>, <span class="string">&#x27;sex&#x27;</span>: <span class="literal">None</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> aDict<span class="comment">#del命令直接删除</span></span><br></pre></td></tr></table></figure><h3 id="字典元素的访问">字典元素的访问</h3><p>字典使用”键“进行索引，如果字典中不存在某个”键“，会抛出异常</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>aDict = &#123;<span class="string">&#x27;age&#x27;</span>: <span class="number">39</span>, <span class="string">&#x27;score&#x27;</span>: [<span class="number">98</span>,<span class="number">97</span>], <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Dong&#x27;</span>, <span class="string">&#x27;sex&#x27;</span>: <span class="string">&#x27;male&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>aDict[<span class="string">&#x27;age&#x27;</span>]</span><br><span class="line"><span class="number">39</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>aDict[<span class="string">&#x27;address&#x27;</span>]<span class="comment">#不存在对应”键“，异常</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">KeyError: <span class="string">&#x27;address&#x27;</span></span><br></pre></td></tr></table></figure><p>字典特有的<code>get()</code>方法，指定“键”返回特定的“值”，并且允许不存在该“键”时返回特定的“值”，（默认为None）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>aDict.get(<span class="string">&#x27;address&#x27;</span>,<span class="string">&#x27;Not exist&#x27;</span>)<span class="comment">#指定”键“，如果不存在就返回指定的默认值</span></span><br><span class="line"><span class="string">&#x27;Not exist&#x27;</span></span><br></pre></td></tr></table></figure><p>可以对字典对象进行迭代或者遍历，默认遍历字典的“键”，如果需要遍历字典的元素，必须使用字典对象的<code>items()</code>方法明确说明，如果需要遍历字典的“值”，必须使用字典对象的<code>values()</code>方法进行说明。当使用<code>len(),max(),min(),sum(),sorted()</code>等内置函数时，也遵循同样的规定</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>aDict = &#123;<span class="string">&#x27;age&#x27;</span>: <span class="number">39</span>, <span class="string">&#x27;score&#x27;</span>: [<span class="number">98</span>,<span class="number">97</span>], <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Dong&#x27;</span>, <span class="string">&#x27;sex&#x27;</span>: <span class="string">&#x27;male&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> item <span class="keyword">in</span> aDict:</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(item, end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">...</span><br><span class="line">age score name sex </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> item <span class="keyword">in</span> aDict.items():</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(item,end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">...</span><br><span class="line">(<span class="string">&#x27;age&#x27;</span>, <span class="number">39</span>) (<span class="string">&#x27;score&#x27;</span>, [<span class="number">98</span>, <span class="number">97</span>]) (<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;Dong&#x27;</span>) (<span class="string">&#x27;sex&#x27;</span>, <span class="string">&#x27;male&#x27;</span>) </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> item <span class="keyword">in</span> aDict.values():</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(item,end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">...</span><br><span class="line"><span class="number">39</span> [<span class="number">98</span>, <span class="number">97</span>] Dong male </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>aDict</span><br><span class="line">&#123;<span class="string">&#x27;age&#x27;</span>: <span class="number">39</span>, <span class="string">&#x27;score&#x27;</span>: [<span class="number">98</span>, <span class="number">97</span>], <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Dong&#x27;</span>, <span class="string">&#x27;sex&#x27;</span>: <span class="string">&#x27;male&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>aDict.items()</span><br><span class="line">dict_items([(<span class="string">&#x27;age&#x27;</span>, <span class="number">39</span>), (<span class="string">&#x27;score&#x27;</span>, [<span class="number">98</span>, <span class="number">97</span>]), (<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;Dong&#x27;</span>), (<span class="string">&#x27;sex&#x27;</span>, <span class="string">&#x27;male&#x27;</span>)])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>aDict.values()</span><br><span class="line">dict_values([<span class="number">39</span>, [<span class="number">98</span>, <span class="number">97</span>], <span class="string">&#x27;Dong&#x27;</span>, <span class="string">&#x27;male&#x27;</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>aDict.keys()</span><br><span class="line">dict_keys([<span class="string">&#x27;age&#x27;</span>, <span class="string">&#x27;score&#x27;</span>, <span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;sex&#x27;</span>])</span><br></pre></td></tr></table></figure><h3 id="字典元素的添加、修改与删除">字典元素的添加、修改与删除</h3><p>如果使用指定的“键”为字典元素赋值时，有两种含义</p><ul><li>如果该“键”存在，则表示修改该“键”对应的“值”</li><li>如果该“键”不存在，则表示重新添加一个新的“键:值”</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>aDict = &#123;<span class="string">&#x27;age&#x27;</span>: <span class="number">39</span>, <span class="string">&#x27;score&#x27;</span>: [<span class="number">98</span>,<span class="number">97</span>], <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Dong&#x27;</span>, <span class="string">&#x27;sex&#x27;</span>: <span class="string">&#x27;male&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>aDict[<span class="string">&#x27;age&#x27;</span>]=<span class="number">28</span><span class="comment">#原本存在则修改</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>aDict</span><br><span class="line">&#123;<span class="string">&#x27;age&#x27;</span>: <span class="number">28</span>, <span class="string">&#x27;score&#x27;</span>: [<span class="number">98</span>, <span class="number">97</span>], <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Dong&#x27;</span>, <span class="string">&#x27;sex&#x27;</span>: <span class="string">&#x27;male&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>aDict[<span class="string">&#x27;address&#x27;</span>] = <span class="string">&#x27;beijing&#x27;</span><span class="comment">#原本不存在则添加</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>aDict</span><br><span class="line">&#123;<span class="string">&#x27;age&#x27;</span>: <span class="number">28</span>, <span class="string">&#x27;score&#x27;</span>: [<span class="number">98</span>, <span class="number">97</span>], <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Dong&#x27;</span>, <span class="string">&#x27;sex&#x27;</span>: <span class="string">&#x27;male&#x27;</span>, <span class="string">&#x27;address&#x27;</span>: <span class="string">&#x27;beijing&#x27;</span>&#125;</span><br></pre></td></tr></table></figure><p>使用字典对象的<code>updata()</code>方法可以将另一个字典的全部”键：值“全部更新到原字典中，更新规则和上方两个一样</p><p>使用<code>pop()</code>和<code>popitem()</code>方法弹出并删除指定元素</p><p><code>pop(key[,default])</code>，弹出对应键‘key’的值，可以设置default参数作为不存在key时的返回值</p><p><code>popitem()</code>无参数，返回最后插入的键值，返回形式为一个元组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>aDict = &#123;<span class="string">&#x27;age&#x27;</span>: <span class="number">37</span>, <span class="string">&#x27;score&#x27;</span>: [<span class="number">98</span>, <span class="number">97</span>], <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Dong&#x27;</span>, <span class="string">&#x27;sex&#x27;</span>: <span class="string">&#x27;male&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>aDict.update(&#123;<span class="string">&#x27;age&#x27;</span>: <span class="number">39</span>, <span class="string">&#x27;a&#x27;</span>: <span class="number">80</span>&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>aDict</span><br><span class="line">&#123;<span class="string">&#x27;age&#x27;</span>: <span class="number">39</span>, <span class="string">&#x27;score&#x27;</span>: [<span class="number">98</span>, <span class="number">97</span>], <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Dong&#x27;</span>, <span class="string">&#x27;sex&#x27;</span>: <span class="string">&#x27;male&#x27;</span>, <span class="string">&#x27;a&#x27;</span>: <span class="number">80</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>aDict.popitem()</span><br><span class="line">(<span class="string">&#x27;a&#x27;</span>, <span class="number">80</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>aDict.pop(<span class="string">&#x27;age&#x27;</span>)</span><br><span class="line"><span class="number">39</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>aDict</span><br><span class="line">&#123;<span class="string">&#x27;score&#x27;</span>: [<span class="number">98</span>, <span class="number">97</span>], <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Dong&#x27;</span>, <span class="string">&#x27;sex&#x27;</span>: <span class="string">&#x27;male&#x27;</span>&#125;</span><br></pre></td></tr></table></figure><h2 id="集合">集合</h2><p>集合中元素不可变，比如整数，实数，复数，字符串，元组等，元素不可重复</p><h3 id="集合的创建和删除">集合的创建和删除</h3><p>直接赋值或者使用<code>set()</code>函数将可迭代对象转换为集合，同样可以使用del命令删除集合</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = &#123;<span class="number">3</span>, <span class="number">5</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a_set = <span class="built_in">set</span>(<span class="built_in">range</span>(<span class="number">4</span>,<span class="number">14</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a_set</span><br><span class="line">&#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b_set = ([<span class="number">0</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b_set</span><br><span class="line">[<span class="number">0</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure><h3 id="集合操作与运算">集合操作与运算</h3><h4 id="集合元素的增加与删除">集合元素的增加与删除</h4><p><code>add(elem)</code>方法增添新元素，如果元素已经存在就会异常</p><p><code>update(another_set)</code>方法更新集合，类似字典的更新，自动去重，添加原本没有的元素</p><p><code>pop()</code>方法删除集合中<strong>任意元素</strong>，如果集合为空就异常，返回的元素作为返回值</p><p><code>remove(elem)</code>方法删除<strong>指定元素</strong>，不存在就抛出异常</p><p><code>discard(elem)</code>方法删除<strong>指定元素</strong>，不存在则忽略</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>表达式树</title>
      <link href="/2023/04/20/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%A0%91/"/>
      <url>/2023/04/20/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>表达式树可以用于表达式的计算，形式为一颗二叉树，非常形象，下面我们通过前中后缀表达式的详细规则构建表达式树</p><span id="more"></span><p><strong>Ps: 以下代码只是经过简单的数据测试（目前来看没什么问题），如果出现数据计算错误，请联系作者</strong></p><p>针对以下前中后缀表达式的输入情况说明：</p><ol><li>输入数据仅仅支持<code>+ , -, *, /</code>四种运算，如果有其它运算要求，例如幂<code>^</code>、<code>%</code>运算，可以自行上网搜寻文章，对运算进行扩充，也可以参照作者文章<code>c语言模板/多位数计算器</code>进行计算符号扩充的理解</li><li>输入的三种表达式中，除了中缀表达式有括号在其中（不会产生任何数字的歧义），但是对于前缀和后缀表达式，不同数字之间需要添加空格，这里的数字指的是一个完整的数字，在后缀表达式<code>123 54 +</code>中，比如<code>123</code>和<code>54</code>区分，<code>123</code>和<code>54</code>分别作为一个完整的数字存在，因此需要区分，至于其它情况，数字和操作符之间，操作符和操作符之间，可以不添加空格，但是为了结构的一致性，建议添加空格</li><li>计算仅仅支持<code>int</code>范围内的计算，并且对于<code>/</code>运算，采取的是向下取整，如果对于计算的方式有不同需求的，可以自行修改</li></ol><p>构建表达式树之前，我们定义一个结点栈，用来存储表达式树构建过程中的元素，栈内每一个元素的本质是一颗子树。</p><p>同时给出表达式树构建之前所需的一些自定义函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 1005</span></span><br><span class="line"><span class="keyword">typedef</span> ElemType <span class="type">int</span>;<span class="comment">//这里根据单位数字或者是多位数字，自行选择类型，int 或 char</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    ElemType elem;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">left</span>, *<span class="title">right</span>;</span></span><br><span class="line">&#125; Node, *Nodeprt;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">stack</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> top;</span><br><span class="line">    Nodeprt data[MAXSIZE];</span><br><span class="line">&#125; Stack;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">(Stack *s)</span> &#123;<span class="comment">//初始化栈</span></span><br><span class="line">    s-&gt;top = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">empty</span><span class="params">(Stack *s)</span> &#123;<span class="comment">//判断栈空</span></span><br><span class="line">    <span class="keyword">return</span> s-&gt;top == <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">full</span><span class="params">(Stack *s)</span> &#123;<span class="comment">//判断栈满</span></span><br><span class="line">    <span class="keyword">return</span> s-&gt;top == MAXSIZE - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">push</span><span class="params">(Stack *s, Nodeprt item)</span> &#123;<span class="comment">//元素入栈</span></span><br><span class="line">    <span class="keyword">if</span> (full(s)) <span class="keyword">return</span>;</span><br><span class="line">    s-&gt;data[++s-&gt;top] = item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Nodeprt <span class="title function_">pop</span><span class="params">(Stack *s)</span> &#123;<span class="comment">//弹出栈顶元素</span></span><br><span class="line">    <span class="keyword">if</span> (empty(s)) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> s-&gt;data[s-&gt;top--];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ElemType <span class="title function_">get_top_data</span><span class="params">(Stack *s)</span> &#123;<span class="comment">//获取栈顶元素，只是获取，不是弹出</span></span><br><span class="line">    <span class="keyword">return</span> s-&gt;data[s-&gt;top]-&gt;elem;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Nodeprt <span class="title function_">build_node</span><span class="params">(ElemType Data)</span> &#123;<span class="comment">//单个数字的表达式树，可以用char 进行统一</span></span><br><span class="line">    Nodeprt p = (Nodeprt) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    p-&gt;elem = Data;</span><br><span class="line">    p-&gt;left = p-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Nodeprt <span class="title function_">build_node</span><span class="params">(ElemType Data, <span class="type">int</span> flag)</span> &#123;<span class="comment">//因为树的结点的统一性，我们选择将data统一为int，用负数表示对应的操作符</span></span><br><span class="line">    Nodeprt p = (Nodeprt) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    <span class="keyword">if</span> (flag)Data = -Data;</span><br><span class="line">    p-&gt;elem = Data;</span><br><span class="line">    p-&gt;left = p-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">priority</span><span class="params">(<span class="type">char</span> ch)</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (ch) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//符号优先级定义，在中缀转表达式树，中缀转后缀会用到，根据其它的一些数学运算，可以适当扩充</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">cal_operator_tree</span><span class="params">(Nodeprt root)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;elem&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">switch</span>(-root-&gt;elem)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:<span class="keyword">return</span> cal_operator_tree(root-&gt;left)+ cal_operator_tree(root-&gt;right);</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:<span class="keyword">return</span> cal_operator_tree(root-&gt;left)- cal_operator_tree(root-&gt;right);</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:<span class="keyword">return</span> cal_operator_tree(root-&gt;left)* cal_operator_tree(root-&gt;right);</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:<span class="keyword">return</span> cal_operator_tree(root-&gt;left)/ cal_operator_tree(root-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> root-&gt;elem;</span><br><span class="line">&#125;<span class="comment">//递归计算左右子树的数值</span></span><br></pre></td></tr></table></figure><h2 id="中缀表达式">中缀表达式</h2><p>表达式树构建规则：先将中缀表达式按照计算优先级套上一层一层括号，然后按照以下几条规则从左往右遍历中缀表达式</p><ol><li>如果某个字符是<strong>数字</strong>，那么直接进入结点栈;（这里如果是多位数字，请自行处理形成一个完整的数字，比如字符串&quot;123&quot;变成123；</li><li>如果某个字符是’('，直接进入符号栈；</li><li>如果某个字符是’)‘，依次退出符号栈的操作符，直至遇到’('，对于每个弹出的操作符，都要和数字栈中弹出的两个结点进行结合形成新的结点，并且作为新的结点进入结点栈；</li><li>如果某个字符是<strong>操作符</strong>，从符号栈中依次弹出比当前<strong>操作符</strong>优先级高的字符（同样，对于每个弹出的字符，都要进行与结点栈的结合操作），然后再将<strong>当前操作符</strong>入符号栈;</li><li>最后遍历完中缀表达式之后，如果符号栈非空，那就依次弹出符号栈内的操作符，对于每个操作符都要与结点栈内弹出的两个结点进行结合，然后形成新的结点再进入结点栈，最终结点栈内的唯一结点就是<strong>表达式树的根</strong></li><li>对于每个操作符和结点结合的顺序说明，从结点栈内弹出的<strong>第一个</strong>结点作为<strong>右</strong>儿子，<strong>第二个</strong>弹出的结点作为<strong>左</strong>儿子。</li></ol><p>代码如下（均为函数封装形式）（下方代码仅仅针对单位数字，例如<code>0,1,2,3,4,5,6,7,8,9</code>）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">Nodeprt <span class="title function_">build_operator_tree</span><span class="params">(<span class="type">char</span> *s)</span> &#123;</span><br><span class="line">    Stack *stack_node=(Stack*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Stack));</span><br><span class="line">    Stack *stack_operator=(Stack*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Stack));</span><br><span class="line">    init(stack_node);</span><br><span class="line">    init(stack_operator);</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">&#x27; &#x27;</span>)<span class="keyword">continue</span>;<span class="comment">//空格直接跳过</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">isdigit</span>(s[i])) &#123;<span class="comment">//是数字</span></span><br><span class="line">             Nodeprt tmp = build_node(s[i], <span class="number">0</span>);</span><br><span class="line">                push(stack_node, tmp);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//其它所有情况作为与数字的一个区分</span></span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                Nodeprt tmp = build_node(<span class="string">&#x27;(&#x27;</span>, <span class="number">1</span>);</span><br><span class="line">                push(stack_operator, tmp);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> (!empty(stack_operator) &amp;&amp; get_top_data(stack_operator) != <span class="string">&#x27;(&#x27;</span>) &#123;<span class="comment">//栈非空，直到&#x27;(&#x27;</span></span><br><span class="line">                    Nodeprt p = pop(stack_operator);</span><br><span class="line">                    p-&gt;right = pop(stack_node);</span><br><span class="line">                    p-&gt;left = pop(stack_node);</span><br><span class="line">                    push(stack_node, p);</span><br><span class="line">                &#125;</span><br><span class="line">                pop(stack_operator);<span class="comment">//把左括号弹出来</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;+&#x27;</span> || s[i] == <span class="string">&#x27;-&#x27;</span> || s[i] == <span class="string">&#x27;*&#x27;</span> || s[i] == <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> (!empty(stack_operator) &amp;&amp; priority((get_top_data(stack_operator))) &gt;= priority(s[i])) &#123;</span><br><span class="line">                    Nodeprt p = pop(stack_operator);</span><br><span class="line">                    p-&gt;right = pop(stack_node);</span><br><span class="line">                    p-&gt;left = pop(stack_node);</span><br><span class="line">                    push(stack_node, p);</span><br><span class="line">                &#125;</span><br><span class="line">                Nodeprt p = build_node(s[i], <span class="number">1</span>);</span><br><span class="line">                push(stack_operator, p);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!empty(stack_operator)) &#123;</span><br><span class="line">        Nodeprt p = pop(stack_operator);</span><br><span class="line">        p-&gt;right = pop(stack_node);</span><br><span class="line">        p-&gt;left = pop(stack_node);</span><br><span class="line">        push(stack_node, p);</span><br><span class="line">    &#125;</span><br><span class="line">    Nodeprt root = stack_node-&gt;data[stack_node-&gt;top];</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> s[MAXSIZE];</span><br><span class="line">    gets(s);</span><br><span class="line">    Nodeprt root= build_operator_tree(s);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果需要计算多位数字数字，我们需要对数字读入部分进行修改，仔细分析一下，我们会发现，每个结点的结构体定义的符号类型是<code>char</code>，但是对于多位数字，我们假定为<code>int</code>类型，无法存储在<code>char</code>里面，接下来讨论两种储存方式。</p><ol><li>我们可以定义</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">left</span>,*<span class="title">right</span>;</span></span><br><span class="line">&#125;Node,*Nodeprt;</span><br></pre></td></tr></table></figure><p>​在结构体内同时使用<code>char ,int</code>，由于区分了符号栈和结点栈，我们可以很方便的读取完整的数字，区分数字和操作符（结点的构造稍微有一点不同），同时在表达式树构建完成之后，所有的数字都是叶结点，其它的是操作符结点，容易区分，只需在遍历过程中加一个小判断（是否为叶结点）即可；</p><ol start="2"><li><p>同时定义<code>char ,int</code>有些浪费空间，我们来考虑一下一个合法的中缀表达式的规则</p><ul><li>不能存在负数，所有负数<code>x</code>都可以转换成<code>0 - (-x)</code>的形式，从而转换成非负数。</li><li><code>int</code>存储范围包括负数，但是我们只需要利用非负数，因此负数区间是空闲的</li><li>所有操作符的<strong>Ascll</strong>码独立，不会重复；</li></ul><p>基于这几点规则，我们可以用负数存储操作符，对于某个操作符<code>ch</code>,我们定义它在结点中存储的数值为<code>0 - ascll(ch)</code></p><p>这样我们的结点中只需要定义<code>int</code>即可</p></li></ol><p>我们以第二种为例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">Nodeprt <span class="title function_">build_operator_tree</span><span class="params">(<span class="type">char</span> *s)</span> &#123;</span><br><span class="line">    Stack *stack_node=(Stack*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Stack));</span><br><span class="line">    Stack *stack_operator=(Stack*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Stack));</span><br><span class="line">    init(stack_node);</span><br><span class="line">    init(stack_operator);</span><br><span class="line">    <span class="type">int</span> flag = <span class="number">0</span>, num = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//flag作为多位数字处理的一个标记，如果flag是1，表示继续处理数字，否则表示结束数字的处理，从而分隔完整的数字</span></span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">&#x27; &#x27;</span>)<span class="keyword">continue</span>;<span class="comment">//空格直接跳过</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">isdigit</span>(s[i])) &#123;<span class="comment">//是数字</span></span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">            num *= <span class="number">10</span>;</span><br><span class="line">            num += s[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//其它所有情况作为与数字的一个区分</span></span><br><span class="line">            <span class="keyword">if</span> (flag == <span class="number">1</span>) &#123;</span><br><span class="line">                Nodeprt tmp = build_node(num, <span class="number">0</span>);</span><br><span class="line">                push(stack_node, tmp);</span><br><span class="line">                num = <span class="number">0</span>;</span><br><span class="line">                flag = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                Nodeprt tmp = build_node(<span class="string">&#x27;(&#x27;</span>, <span class="number">1</span>);</span><br><span class="line">                push(stack_operator, tmp);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> (!empty(stack_operator) &amp;&amp; get_top_data(stack_operator) != -<span class="string">&#x27;(&#x27;</span>) &#123;<span class="comment">//栈非空，直到&#x27;(&#x27;</span></span><br><span class="line">                    Nodeprt p = pop(stack_operator);</span><br><span class="line">                    p-&gt;right = pop(stack_node);</span><br><span class="line">                    p-&gt;left = pop(stack_node);</span><br><span class="line">                    push(stack_node, p);</span><br><span class="line">                &#125;</span><br><span class="line">                pop(stack_operator);<span class="comment">//把左括号弹出来</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;+&#x27;</span> || s[i] == <span class="string">&#x27;-&#x27;</span> || s[i] == <span class="string">&#x27;*&#x27;</span> || s[i] == <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> (!empty(stack_operator) &amp;&amp; priority(-(get_top_data(stack_operator))) &gt;= priority(s[i])) &#123;</span><br><span class="line">                    Nodeprt p = pop(stack_operator);</span><br><span class="line">                    p-&gt;right = pop(stack_node);</span><br><span class="line">                    p-&gt;left = pop(stack_node);</span><br><span class="line">                    push(stack_node, p);</span><br><span class="line">                &#125;</span><br><span class="line">                Nodeprt p = build_node(s[i], <span class="number">1</span>);</span><br><span class="line">                push(stack_operator, p);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!empty(stack_operator)) &#123;</span><br><span class="line">        Nodeprt p = pop(stack_operator);</span><br><span class="line">        p-&gt;right = pop(stack_node);</span><br><span class="line">        p-&gt;left = pop(stack_node);</span><br><span class="line">        push(stack_node, p);</span><br><span class="line">    &#125;</span><br><span class="line">    Nodeprt root = stack_node-&gt;data[stack_node-&gt;top];</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> s[MAXSIZE];</span><br><span class="line">    gets(s);</span><br><span class="line">    Nodeprt root= build_operator_tree(s);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="前缀表达式">前缀表达式</h2><p>前缀表达式运算符优先级已经由自身的符号顺序决定，表达式内没有括号，因此无需操作符栈，只需要一个结点栈即可</p><p>表达式树构建规则：</p><ol><li><strong>从后往前</strong>遍历前缀表达式，对于每一个遍历到的元素，形成一个结点</li><li>如果当前元素是数字，直接进入结点栈</li><li>如果是操作符，那就依次从结点栈内弹出两个结点，第一个弹出的作为右儿子，第二个弹出的作为左儿子，然后与当前操作符形成一个新的结点（树），再进入结点栈中</li></ol><p><strong>Ps：我们在从后往前遍历前缀表达式的过程中，假如某个多位数字是1234，但是从后往前读取得到的多位数字是4321，因此对于每次数字存储前，都需要对当前数字进行逆转</strong></p><p>重复以上规则，最终结点栈中仅剩一个结点，也就是表达式树的根结点</p><p>代码如下（以多位数字为例，用<code>int</code>同时存储数字和操作符—详细请看上文的中缀表达式构建方式说明）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">reverse_num</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> s[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span> (num) &#123;</span><br><span class="line">        s[cnt++] = num % <span class="number">10</span>;</span><br><span class="line">        num /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; cnt; i++) &#123;</span><br><span class="line">        num *= <span class="number">10</span>;</span><br><span class="line">        num += s[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Nodeprt <span class="title function_">build_operator_tree</span><span class="params">(<span class="type">char</span> *s)</span> &#123;</span><br><span class="line">    Stack *stack_node = (Stack *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Stack));</span><br><span class="line">    init(stack_node);</span><br><span class="line">    <span class="type">int</span> flag = <span class="number">0</span>, num = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//flag作为多位数字处理的一个标记，如果flag是1，表示继续处理数字，否则表示结束数字的处理，从而分隔完整的数字</span></span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;<span class="comment">//从后往前遍历</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isdigit</span>(s[i])) &#123;<span class="comment">//是数字</span></span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">            num *= <span class="number">10</span>;</span><br><span class="line">            num += s[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//一定是操作符</span></span><br><span class="line">            <span class="keyword">if</span> (flag == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">//这里虽然是从后往前遍历，但是数字读取反了，比如原来是31，结果读取成了13，需要扭转数字</span></span><br><span class="line">                num = reverse_num(num);</span><br><span class="line">                Nodeprt tmp = build_node(num, <span class="number">0</span>);</span><br><span class="line">                push(stack_node, tmp);</span><br><span class="line">                num = <span class="number">0</span>;</span><br><span class="line">                flag = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;+&#x27;</span> || s[i] == <span class="string">&#x27;-&#x27;</span> || s[i] == <span class="string">&#x27;*&#x27;</span> || s[i] == <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">                Nodeprt p = build_node(s[i], <span class="number">1</span>);</span><br><span class="line">                p-&gt;right = pop(stack_node);</span><br><span class="line">                p-&gt;left = pop(stack_node);</span><br><span class="line">                push(stack_node, p);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Nodeprt root = stack_node-&gt;data[stack_node-&gt;top];</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="后缀表达式">后缀表达式</h2><p>后缀表达式的运算符优先级已经由符号顺序决定，没有括号限制，因此无需符号栈，只要一个结点栈即可</p><p>表达式树构建规则：</p><ol><li>从前往后遍历后缀表达式，对于每个元素处理成为一个结点</li><li>如果是数字，直接进入结点栈</li><li>如果是操作符，那就依次从结点栈内弹出两个结点，第一个弹出的作为右儿子，第二个弹出的作为左儿子，然后与当前操作符形成一个新的结点（树），再进入结点栈中</li></ol><p>Ps：从前往后遍历不存在读取的数字相反的情况（参考前缀表达式），因此无需逆转数字</p><p>代码如下（以多位数字位例子，用<code>int</code>同时存储数字和操作符—详细请看上文的中缀表达式构建方式说明）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Nodeprt <span class="title function_">build_operator_tree</span><span class="params">(<span class="type">char</span> *s)</span> &#123;</span><br><span class="line">    Stack *stack_node = (Stack *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Stack));</span><br><span class="line">    init(stack_node);</span><br><span class="line">    <span class="type">int</span> flag = <span class="number">0</span>, num = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//flag作为多位数字处理的一个标记，如果flag是1，表示继续处理数字，否则表示结束数字的处理，从而分隔完整的数字</span></span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= len - <span class="number">1</span>; i++) &#123;<span class="comment">//从后往前遍历</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isdigit</span>(s[i])) &#123;<span class="comment">//是数字</span></span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">            num *= <span class="number">10</span>;</span><br><span class="line">            num += s[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//一定是操作符</span></span><br><span class="line">            <span class="keyword">if</span> (flag == <span class="number">1</span>) &#123;</span><br><span class="line">                Nodeprt tmp = build_node(num, <span class="number">0</span>);</span><br><span class="line">                push(stack_node, tmp);</span><br><span class="line">                num = <span class="number">0</span>;</span><br><span class="line">                flag = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;+&#x27;</span> || s[i] == <span class="string">&#x27;-&#x27;</span> || s[i] == <span class="string">&#x27;*&#x27;</span> || s[i] == <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">                Nodeprt p = build_node(s[i], <span class="number">1</span>);</span><br><span class="line">                p-&gt;right = pop(stack_node);</span><br><span class="line">                p-&gt;left = pop(stack_node);</span><br><span class="line">                push(stack_node, p);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Nodeprt root = stack_node-&gt;data[stack_node-&gt;top];</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 表达式树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 表达式树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构</title>
      <link href="/2023/03/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/2023/03/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<ul><li>本文所有内容均出自微信公众号&quot;labuladong&quot;,公众号本身代码均以java代码块形式呈现，本文将以c语言呈现。文章类似转载，但是已经声明出处，并修改代码为c语言，此内容主要是记录博主自身学习过程，有疑惑建议翻看原文</li></ul><span id="more"></span><h1>数据结构</h1><h2 id="链表">链表</h2><h3 id="合并两个有序链表">合并两个有序链表</h3><p><img src="https://soybeanlittlecar.oss-cn-beijing.aliyuncs.com/blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E5%8D%95%E9%93%BE%E8%A1%A8.jpg" alt="两个链表合并"></p><p>采用双指针实现，这里封装函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">link</span>;</span></span><br><span class="line">&#125; Node, *Nodeprt;</span><br><span class="line"></span><br><span class="line">Nodeprt <span class="title function_">mergeTwoLists</span><span class="params">(Nodeprt l1, Nodeprt l2)</span> &#123;</span><br><span class="line">    <span class="comment">//这里用两个指针分别指向两条链表的头结点，最终返回链表头节点,默认单增</span></span><br><span class="line">    Nodeprt head = (Nodeprt) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    Nodeprt p = head;<span class="comment">//虚拟头结点</span></span><br><span class="line">    <span class="keyword">while</span> (l1 != <span class="literal">NULL</span> &amp;&amp; l2 != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p1-&gt;data &gt; p2-&gt;data) &#123;</span><br><span class="line">            p-&gt;link = l2;</span><br><span class="line">            l2 = l2-&gt;link;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            p-&gt;link = l1;</span><br><span class="line">            l1 = l1-&gt;link;</span><br><span class="line">        &#125;</span><br><span class="line">        p = p-&gt;link;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p1 != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        p-&gt;link = l1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p2 != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        p-&gt;link = l2;</span><br><span class="line">    &#125;</span><br><span class="line">    p = head-&gt;link;<span class="comment">//重新指向头结点</span></span><br><span class="line">    <span class="built_in">free</span>(head);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="合并k个有序链表">合并k个有序链表</h3><p><img src="https://soybeanlittlecar.oss-cn-beijing.aliyuncs.com/blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%90%88%E5%B9%B6k%E4%B8%AA%E5%8D%95%E9%93%BE%E8%A1%A8.jpg" alt="合并k个有序链表"></p><p>合并k个有序链表的难点在于如何快速得到k个链表当中的最小节点并且接到链表上</p><p>这里采用<strong>优先队列(二叉堆)</strong>，把链表节点放到一个最小堆里面，每次获得k个节点中的最小节点。最开始堆中都是k条链表的头，每次弹出一个元素的同时，对应链表需要后移一位，然后将新的头插入到最小堆中，然后调整堆</p><p>最小堆模板</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MinData -1001</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElementType;<span class="comment">//自定义数据类型； </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">HeapStruct</span> &#123;</span></span><br><span class="line">    ElementType *Elements;<span class="comment">//存储堆元素的数组，指针数组</span></span><br><span class="line">    <span class="type">int</span> size;    <span class="comment">//堆的当前元素个数； </span></span><br><span class="line">    <span class="type">int</span> capacity;<span class="comment">//堆的最大容量 </span></span><br><span class="line">&#125; MinHeap, *MinHeapPrt;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">IsFull</span><span class="params">(MinHeapPrt H)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (H-&gt;size == Maxsize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">IsEmpty</span><span class="params">(MinHeapPrt H)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (H-&gt;size == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MinHeapPrt <span class="title function_">Create</span><span class="params">(<span class="type">int</span> Maxsize)</span> &#123;</span><br><span class="line">    <span class="comment">//创建容量为Maxsize的空的最小堆</span></span><br><span class="line">    <span class="comment">//从1开始插入元素，0留给哨兵； </span></span><br><span class="line">    MinHeapPrt H = (MinHeapPrt) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(MinHeap));</span><br><span class="line">    H-&gt;Elements = (ElementType *) <span class="built_in">malloc</span>((Maxsize + <span class="number">1</span>) * <span class="keyword">sizeof</span>(ElementType));</span><br><span class="line">    H-&gt;size = <span class="number">0</span>;</span><br><span class="line">    H-&gt;capacity = Maxsize;</span><br><span class="line">    H-&gt;Elements[<span class="number">0</span>] = MinData;<span class="comment">//随便找一个特别小，比所有输入数据小的元素就行； </span></span><br><span class="line">    <span class="comment">//MinData.定义哨兵为小于堆中所有可能元素的值，便于以后更快操作</span></span><br><span class="line">    <span class="keyword">return</span> H;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">insert</span><span class="params">(MinHeapPrt H, ElementType item)</span> &#123;</span><br><span class="line">    <span class="comment">//将元素item插入最小堆H，其中H-&gt;Elements[0]已经定义为哨兵；</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">if</span> (IsFull(H)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;最小堆已满&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    i = ++H-&gt;size;<span class="comment">//i指向插入后的最后一个元素位置； </span></span><br><span class="line">    <span class="keyword">for</span> (; H-&gt;Elements[i / <span class="number">2</span>] &gt; item; i /= <span class="number">2</span>)<span class="comment">//完全二叉树有i/2表示父结点的性质；如果父结点比目标item大，</span></span><br><span class="line">        <span class="comment">//这里会有i=1的情况，但是有哨兵存在，哨兵保证了所有输入数据都比哨兵大，如果没有哨兵，可以加一句i&gt;1; </span></span><br><span class="line">        <span class="comment">//哨兵效率更高； </span></span><br><span class="line">        H-&gt;Elements[i] = H-&gt;Elements[i / <span class="number">2</span>];<span class="comment">//保证有序性，把大小不符合的往下过滤， </span></span><br><span class="line">    H-&gt;Elements[i] = item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ElementType <span class="title function_">deleteMin</span><span class="params">(MinHeapPrt H)</span> &#123;</span><br><span class="line">    <span class="comment">//从最小堆中去除键值最小的元素，删除结点</span></span><br><span class="line">    <span class="type">int</span> parent, child;</span><br><span class="line">    ElementType MinItem, temp;</span><br><span class="line">    <span class="keyword">if</span> (IsEmpty(H)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;最小堆已空&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    MinItem = H-&gt;Elements[<span class="number">1</span>];<span class="comment">//从根结点找最小值；</span></span><br><span class="line">    <span class="comment">//用最小堆中最后一个元素从根结点开始向上过滤下层结点，就是先把最后一个元素放到根的位置</span></span><br><span class="line">    temp = H-&gt;Elements[H-&gt;size--];<span class="comment">//先赋值，再减减 </span></span><br><span class="line">    <span class="keyword">for</span> (parent = <span class="number">1</span>; parent * <span class="number">2</span> &lt;= H-&gt;size; parent = child) &#123;<span class="comment">//判断保证存在左子； </span></span><br><span class="line">        child = parent * <span class="number">2</span>;<span class="comment">//左子</span></span><br><span class="line">        <span class="keyword">if</span> ((child != H-&gt;size) &amp;&amp; (H-&gt;Elements[child] &gt; H-&gt;Elements[child + <span class="number">1</span>])) <span class="comment">//判断保证有左子的同时还有右子； </span></span><br><span class="line">            child++;<span class="comment">//左子比右子大 </span></span><br><span class="line">        <span class="keyword">if</span> (temp &lt;= H-&gt;Elements[child])<span class="keyword">break</span>;<span class="comment">//调整值比左右子都小；那就放在父的位置 </span></span><br><span class="line">        <span class="keyword">else</span><span class="comment">//移动temp元素到下一层 </span></span><br><span class="line">            H-&gt;Elements[parent] = H-&gt;Elements[child];<span class="comment">//向上过滤，往上移 </span></span><br><span class="line">    &#125;</span><br><span class="line">    H-&gt;Elements[parent] = temp;</span><br><span class="line">    <span class="keyword">return</span> MinItem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现合并k个链表</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Nodeprt <span class="title function_">mergerKLists</span><span class="params">(Nodeprt lists[], <span class="type">int</span> k)</span> &#123;<span class="comment">//传入一个指针数组，里面是k个头节点指针</span></span><br><span class="line">    Nodeprt head = (Nodeprt) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    Nodeprt p = head;</span><br><span class="line">    MinHeapPrt H = Create(k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">        insert(H, lists[i]-&gt;data);<span class="comment">//k个头节点插入最小堆</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!IsEmpty(H)) &#123;<span class="comment">//堆非空</span></span><br><span class="line">        Nodeprt q = (Nodeprt) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">        q-&gt;data = deleteMin(H);<span class="comment">//弹出堆顶元素</span></span><br><span class="line">        q-&gt;link = <span class="literal">NULL</span>;</span><br><span class="line">        p-&gt;link = q;</span><br><span class="line">        p = p-&gt;link;</span><br><span class="line">    &#125;</span><br><span class="line">    p = head-&gt;link;<span class="comment">//p作为链表头节点</span></span><br><span class="line">    <span class="built_in">free</span>(head);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="寻找单链表的倒数第k个结点">寻找单链表的倒数第k个结点</h3><p>从前往后找第k个节点非常简单，从后往前找k个节点也只是需要遍历两次，但是有没有更好的方法只遍历一次呢</p><p>有个非常巧妙的思路，当从前往后遍历k个时，拿一个指针指向头节点，那么当第一个指针到末尾时，第二个指针就指向倒数第k个节点了</p><p><img src="https://soybeanlittlecar.oss-cn-beijing.aliyuncs.com/blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%AF%BB%E6%89%BE%E9%93%BE%E8%A1%A8%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9-1.jpg" alt=""></p><p><img src="https://soybeanlittlecar.oss-cn-beijing.aliyuncs.com/blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%AF%BB%E6%89%BE%E9%93%BE%E8%A1%A8%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9-2.jpg" alt=""></p><p><img src="https://soybeanlittlecar.oss-cn-beijing.aliyuncs.com/blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%AF%BB%E6%89%BE%E9%93%BE%E8%A1%A8%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9-3.jpg" alt=""></p><h3 id="寻找单链表的中点">寻找单链表的中点</h3><p>单链表终点的一次遍历方法与上文类似，使用双指针(快慢指针)</p><h2 id="数组">数组</h2><h3 id="最长连续回文子串">最长连续回文子串</h3><p>对于一个给定的字符串，寻找其最长的连续的回文子串</p><p>难点：回文串的长度可能是奇数也可能是偶数，假如是奇数，那么有中心字符，如果是偶数，得从两个相邻的字符去向两侧寻找；因此先实现一个对于某个确定点找回文串的函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">palindrome</span><span class="params">(<span class="type">char</span> s[], <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (l &gt;= <span class="number">0</span> &amp;&amp; r &lt;= len - <span class="number">1</span> &amp;&amp; s[l] == s[r]) &#123;</span><br><span class="line">        l--;</span><br><span class="line">        r++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//具体细节可以使用指针来实现返回值</span></span><br><span class="line"><span class="comment">//然后就可寻找任意以s[i]为中心的回文串，或者以s[i]和s[i+1]为中心的回文串</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line"><span class="comment">//考虑所有情况，每次对于返回的长度进行比较，保留最长的即可</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="前缀和数组">前缀和数组</h3><p>前缀和用于速快频繁的计算一个索引区间内的元素之和</p><h4 id="一维前缀和">一维前缀和</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//我们可以定义一个类似于一维前缀和的二维数组</span></span><br><span class="line"><span class="comment">//预处理的时候将每一位累加起来</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">s[i] = s[i - <span class="number">1</span>] + x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这样对于任何原数组的区间和，例如区间[l,r];</span></span><br><span class="line"><span class="comment">//我们可以快速用s[r]-s[l-1]实现</span></span><br></pre></td></tr></table></figure><h4 id="二维矩阵的前缀和">二维矩阵的前缀和</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> sum[<span class="number">100</span>][<span class="number">100</span>];<span class="comment">//sum[i][j]表示从左上角(0,0)到(i,j)构成的矩形区域的和</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">sum[i][j] = x + sum[i - <span class="number">1</span>][j] + sum[i][j - <span class="number">1</span>] - sum[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="差分数组">差分数组</h3><h4 id="一维差分">一维差分</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对于正常的对一个广义连续的区间进行统一的加或者减去一个数字，常常使用循环遍历这个区间</span></span><br><span class="line"><span class="comment">//但是对于多次的加减操作非常麻烦，因此引出差分数组</span></span><br><span class="line"><span class="comment">//对于正常数组nums[],我们定义差分数组diff[100],diff[i]=nums[i]-nums[i-1];</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;nums[i]);</span><br><span class="line">    diff[i]=nums[i]-nums[i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于原来的<code>nums[]</code>数组，每次修改区间<code>[left,right]</code>，修改值为k，这里以加法为例子，我们只需在差分数组的<code>diff[left]+=k;diff[right+1]-=k</code>;这样操作，这样有什么用处呢？</p><p>对于diff[left]+=k；我们累加的时候，从<code>nums[left]~nums[right]</code>之间的每一个数字，都加上了k，但是<code>nuns[right+1]</code>以及之后的数字不需要＋k了，因此在<code>diff[right+1]-=k</code>；进行弥补，使得这个<code>-k</code>和前面的<code>+k</code>抵消，从而实现了修改区间<code>[left,right]</code>，区间的每个数字都加上了k。</p><p>在最后访问第i个位置的数字<code>nums[i]</code>的时候（是经过很多次修改之后的nums[i])，我们累加<code>diff[1]，diff[2].......diff[i]</code>,将i个数字加起来作为修改后的<code>nums[i]</code>数值。</p><ul><li><p>写在结尾: 再次鸣谢公众号&quot;labuladong&quot;,公众号中有很多写的优质的文章和资源，对于部分算法也有着非常透彻的分析，对于本菜菜的学习有着非常大的帮助。</p><p><a href="https://mp.weixin.qq.com/s/GOOgO5Wp48jM9jSPzqJwOQ">原作者laluladong</a></p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> c语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划</title>
      <link href="/2023/03/27/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
      <url>/2023/03/27/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
      
        <content type="html"><![CDATA[<ul><li>本文为作者的动态规划学习的历程，部分内容选自公众号labuladong，部分来自洛谷刷题时或者是平常作业中遇到的问题，进而在csdn的优质文章中学习或者是洛谷的题解中学习。文中各种dp并不按照广义的学习路线设置，属于作者自身的一个学习过程</li></ul><span id="more"></span><h3 id="四维dp问题">四维dp问题</h3><p>动态规划问题通常为一维或者二维，很少出现四维。</p><p>对于四维dp，有如下几个特点，</p><ul><li>dp范围非常小，通常在10~50左右，保证在O(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>n</mi><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">n^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span>)时间内能够解决。</li><li>无法拆分成为两个二维，第一个二维能取到最优解，但是在此前提下，第二个二维dp只能取到局部最优，两者的和并不一定是全局最优解。</li><li>根据题目信息可以归纳出四维之间的特殊关系</li></ul><p>下面举两个例子来进行说明</p><ol><li><a href="https://www.luogu.com.cn/problem/P1004">洛谷p1004</a></li></ol><p>题目要求在<code>n*n</code>的方格中从左上角取到左下角取两次，计算两次取数的最大结果</p><p>分析：定义<code>dp[i][j][k][p]</code>为第一次到达ij，第二次到达kp位置时的总数值，对于每一个点，只能从其左侧一格或者上侧一格到达。对于两次取数的两种状态，一共有四种综合转移情况</p><p>因此我们可以考虑状态转移方程</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>p</mi><mo stretchy="false">]</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>k</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>p</mi><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>p</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>k</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>p</mi><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>p</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">)</mo><mo>+</mo><mi>m</mi><mi>a</mi><mi>p</mi><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>p</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dp[i][j][k][p]=max(dp[i-1][j][k-1][p],dp[i-1][j][k][p-1],dp[i][j-1][k-1][p],dp[i][j-1][k][p-1])+map[k][p]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal">p</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal">p</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal">p</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">])</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">ma</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal">p</span><span class="mclose">]</span></span></span></span></span></p><p>我们来分析这个方程，四种位置变化的组合，最后加上对于转移到<code>(k,p)</code>点的数值<code>map[k][p]</code></p><p>也许你会有疑惑为什么不加上转移到<code>(i,j)</code>点的数值<code>map[i][j]</code>;别急，听我慢慢解释</p><p>两次移动虽然用一个方程表示，但是实质上是两次取数的过程，第一个人从左上到右下取完之后才进行第二个人取数（第一个人取过的位置都会变成0，但是对于我们的dp过程，我们不方便将<code>map[][]</code>的某一个位置的数值变成0）</p><p>但是不论如何取数，即使两个人的位置有重合，对于重合点的数值<code>map[][]</code>,我们都可以都只加一次，也就是加上<code>map[k][p]</code>,而对于<code>map[i][j]</code>,我们将讨论相关条件来决定是否加入。</p><p>对于状态转移之后，也就是<code>dp[i][j][k][p]</code>点，表示已经到达这个状态的最大数值，那么到达此状态之后，我们可以将次状态分为两种情况</p><ol><li>点<code>(i,j)和(k,p)</code>重合，那么意味着我们只用将这个点的数值计算一次，也就是<code>map[k][p]</code>,不用考虑<code>map[i][j]</code>；</li><li>点<code>(i,j)和(k,p)</code>不重合，对于点<code>(k,p)</code>我们计算了其数值<code>map[k][p]</code>,那么对于到达点<code>(i,j)</code>的数值<code>map[i][j]</code>没有计算，那么我们只需要加上<code>map[i][j]</code>即可；</li></ol><p>到此状态转移方程分析结束，代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="built_in">map</span>[<span class="number">11</span>][<span class="number">11</span>];</span><br><span class="line"><span class="type">int</span> dp[<span class="number">11</span>][<span class="number">11</span>][<span class="number">11</span>][<span class="number">11</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//freopen(&quot;a.in&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line">    <span class="comment">//freopen(&quot;a.out&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> x, y, z;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;x, &amp;y, &amp;z);</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">0</span> &amp;&amp; y == <span class="number">0</span> &amp;&amp; z == <span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">map</span>[x][y] = z;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n; k++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> p = <span class="number">1</span>; p &lt;= n; p++) &#123;</span><br><span class="line">                    dp[i][j][k][p] = max(dp[i][j][k][p], dp[i - <span class="number">1</span>][j][k - <span class="number">1</span>][p] + <span class="built_in">map</span>[k][p]);</span><br><span class="line">                    dp[i][j][k][p] = max(dp[i][j][k][p], dp[i - <span class="number">1</span>][j][k][p - <span class="number">1</span>] + <span class="built_in">map</span>[k][p]);</span><br><span class="line">                    dp[i][j][k][p] = max(dp[i][j][k][p], dp[i][j - <span class="number">1</span>][k - <span class="number">1</span>][p] + <span class="built_in">map</span>[k][p]);</span><br><span class="line">                    dp[i][j][k][p] = max(dp[i][j][k][p], dp[i][j - <span class="number">1</span>][k][p - <span class="number">1</span>] + <span class="built_in">map</span>[k][p]);</span><br><span class="line">                    <span class="keyword">if</span> (i != k || j != p)dp[i][j][k][p] += <span class="built_in">map</span>[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, dp[n][n][n][n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><a href="https://www.luogu.com.cn/problem/P1006">洛谷p1006</a></li></ol><p>这道题和上面的方格取数有很大的相似处，但是也有部分不同，两个人的路径无法交叉,矩阵大小<strong>m行n列</strong></p><p>分析：路径无法交叉，意味着从左上角的同一点出发时就只能一个人向下并且到达右下顶点的左侧，一个人向右迈出第一步并且到达右下顶点的上侧；</p><p><img src="https://soybeanlittlecar.oss-cn-beijing.aliyuncs.com/blog/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E4%BC%A0%E7%BA%B8%E6%9D%A1-1.png" alt=""></p><p>这里是对于起始点和终点的判定防止交叉;这里我们假定开始向下的为第一个人，向右的是第二个人</p><p>同理我们定义<code>dp[i][j][k][p]</code>表示第一个人到达<code>[i][j]</code>，第二个人到达<code>[k][p]</code>位置时的数值（好感度）总和</p><p>考虑第一个人，他能涉及的区域应该为矩形<code>左上角(1,1),右下角(m,n-1)</code>，因此外层循环如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n<span class="number">-1</span>; j++) &#123;</span><br><span class="line">            <span class="comment">//balabala</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然状态转移考虑的时候我们考虑两个人同时进行位置改变，但是实质上是第一个人到达<code>(i,j)</code>，在此前提之下，因为事实情况是第一个人已经到达这个确定的位置（这个位置已经是合法的了），那么说明第二个人的路径没有和第一个人当前的路径有重合，我们再来考虑第二个人，因为不能有路径交叉，第一个人的考虑范围为矩形<code>左上角(1,j+1)，右下角(m-1,n)</code>;</p><p>因为这个<code>(i,j)</code>能涉及的范围包括整个矩形<code>(1,1),(i,j)</code>;所以让<code>p&gt;j</code>即可保证无重合;状态转移方程如下</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>p</mi><mo stretchy="false">]</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>k</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>p</mi><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>p</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>k</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>p</mi><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>p</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">)</mo><mo>+</mo><mi>m</mi><mi>a</mi><mi>p</mi><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>p</mi><mo stretchy="false">]</mo><mo>+</mo><mi>m</mi><mi>a</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dp[i][j][k][p]=max(dp[i-1][j][k-1][p],dp[i-1][j][k][p-1],dp[i][j-1][k-1][p],dp[i][j-1][k][p-1])+map[k][p]+map[i][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal">p</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal">p</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal">p</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">])</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">ma</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal">p</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">ma</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span></span></p><p>整体代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="built_in">map</span>[<span class="number">53</span>][<span class="number">53</span>];</span><br><span class="line"><span class="type">int</span> dp[<span class="number">52</span>][<span class="number">52</span>][<span class="number">52</span>][<span class="number">52</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;m, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;<span class="built_in">map</span>[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= m - <span class="number">1</span>; k++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> p = <span class="number">1</span> + j; p &lt;= n; p++) &#123;</span><br><span class="line">                    dp[i][j][k][p] = max(dp[i][j][k][p], dp[i - <span class="number">1</span>][j][k - <span class="number">1</span>][p] + <span class="built_in">map</span>[k][p] + <span class="built_in">map</span>[i][j]);</span><br><span class="line">                    dp[i][j][k][p] = max(dp[i][j][k][p], dp[i - <span class="number">1</span>][j][k][p - <span class="number">1</span>] + <span class="built_in">map</span>[k][p] + <span class="built_in">map</span>[i][j]);</span><br><span class="line">                    dp[i][j][k][p] = max(dp[i][j][k][p], dp[i][j - <span class="number">1</span>][k - <span class="number">1</span>][p] + <span class="built_in">map</span>[k][p] + <span class="built_in">map</span>[i][j]);</span><br><span class="line">                    dp[i][j][k][p] = max(dp[i][j][k][p], dp[i][j - <span class="number">1</span>][k][p - <span class="number">1</span>] + <span class="built_in">map</span>[k][p] + <span class="built_in">map</span>[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, dp[m][n - <span class="number">1</span>][m - <span class="number">1</span>][n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里是四维，但是仔细想一下，从左上角到右下角，因为两人路径互不干扰，因此可以假设两人同时进行，步数一样</p><p>那么可以得到方程<code>i+j=p+q</code>,因此只需要枚举三个坐标i，j，k即可得到第四个坐标q（q从j+1开始），降低阶数到3阶；</p><h3 id="背包问题">背包问题</h3><h4 id="01背包">01背包</h4><p>​有n件物品，每一件物品有对应的价值value和重量weight，有背包最大容量max，如何选取物品，在不超过背包容量的情况下取得最大的总价值</p><p>​分析：我们可以定义<code>dp[i][j]</code>为考虑前i件物品，背包容量为j，能装下的最大价值</p><p>​在前i-1件物品考虑完的情况下，我们考虑第i件物品，对应的<code>value[i]和weight[i]</code>,</p><ul><li>如果背包此时的<code>j&lt;weight[i]</code>，那么无法装下第i件物品，那么考虑前i件物品和考虑前i-1件物品的价值是一样的，状态转移方程为：</li></ul><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dp[i][j]=dp[i-1][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span></span></p><ul><li>如果背包装得下，也就是<code>j&gt;weight[i]</code>，那么此时有两种取向，装第i件商品和不装第i件商品，取两者的最大值，状态转移方程为：</li></ul><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mi>w</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">]</mo><mo>+</mo><mi>v</mi><mi>a</mi><mi>l</mi><mi>u</mi><mi>e</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">dp[i][j]=max(dp[i][j],dp[i-1][j-weight[i]]+value[i])</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal">e</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">h</span><span class="mord mathnormal">t</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">u</span><span class="mord mathnormal">e</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">])</span></span></span></span></span></p><p>因此代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> max_num 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> max_weight 200</span></span><br><span class="line"><span class="type">int</span> weight[<span class="number">202</span>], value[<span class="number">202</span>];</span><br><span class="line"><span class="type">int</span> dp[max_num][max_weight];<span class="comment">//dp[i][j]表示考虑前i件商品，有j的容量能取到的最大价值 </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> n, m;<span class="comment">//m就是定义的最大容量 </span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;weight[i], &amp;value[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &lt; weight[i])dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = max(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - weight[i]] + value[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, dp[n][m]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>优化：滚动数组（后面有时间再写详细优化解释）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> dp[max_weight];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = m; j &gt;= weight[i]; j--) &#123;</span><br><span class="line">dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="多重背包">多重背包</h4><p>​对于n件商品，每一件对应有价值value和weight，每一件商品有num件，对于容量为max的背包，如何选取商品获得最大价值</p><p>​分析：将每一件商品的num件都进行拆解，转换成数据量更大的01背包问题，问题在于，数据量更大可能超时，因此需要进行优化</p><p>​考虑这样一个问题，对于一种商品的num件，我们可以选取任意件，但是有没有更好的方法表示这任意件商品呢？</p><p>​这里我们讨论关于<strong>二进制优化</strong>，给你一个数字k，你可以将其表示成为</p><p>​    <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>=</mo><mn>1</mn><mo>+</mo><mn>2</mn><mo>+</mo><mn>4</mn><mo>+</mo><mn>8</mn><mo>+</mo><mn>16</mn><mo>+</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>+</mo><msup><mn>2</mn><mi>m</mi></msup><mo>+</mo><mi>t</mi></mrow><annotation encoding="application/x-tex">k=1+2+4+8+16+......+2^m+t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">8</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">16</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord">......</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7477em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">t</span></span></span></span>;这里的m取最大值，然后剩余一个数字t，举个例子：</p><ul><li>27=1+2+4+8+12；</li><li>49=1+2+4+8+16+17；</li><li>235=1+2+4+8+16+32+64+108；</li></ul><p>这样有什么用呢？对于数字27，原来数字15=1*15（需要15个1来表示15），现在可以<strong>压缩</strong>成15=1+2+12；11=1+2+8；</p><p>也就是对于数字的分解<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>=</mo><mn>1</mn><mo>+</mo><mn>2</mn><mo>+</mo><mn>4</mn><mo>+</mo><mn>8</mn><mo>+</mo><mn>16</mn><mo>+</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>+</mo><msup><mn>2</mn><mi>m</mi></msup><mo>+</mo><mi>t</mi></mrow><annotation encoding="application/x-tex">k=1+2+4+8+16+......+2^m+t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">8</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">16</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord">......</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7477em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">t</span></span></span></span>，对于任意小于等于k的数字q，q可以用k的分解数字组合而成，从而进行<strong>压缩</strong></p><p>这样我们也可以对num件同样的物品进行<strong>二进制压缩</strong>，把每个压缩的数字作为一个整体的新的物品</p><p>代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> max_num 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> max_weight 200</span></span><br><span class="line"><span class="type">int</span> weight[<span class="number">202</span>], value[<span class="number">202</span>];</span><br><span class="line"><span class="type">int</span> dp[max_num][max_weight];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="type">int</span> v, w, num;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;v, &amp;w, &amp;num);</span><br><span class="line">        <span class="comment">//对num进行2进制拆解，1，2，4，8，16 .........以及一个无法继续取到的余数</span></span><br><span class="line">        <span class="type">int</span> k = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (k &lt;= num) &#123;</span><br><span class="line">            value[cnt] = v * k;</span><br><span class="line">            weight[cnt++] = w * k;</span><br><span class="line">            num -= k;</span><br><span class="line">            k &lt;&lt;= <span class="number">1</span>;<span class="comment">//k乘以2</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            value[cnt] = v * num;</span><br><span class="line">            weight[cnt++] = w * num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">//那么就是前cnt件商品</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= cnt - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &lt; weight[i])dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = max(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - weight[i]] + value[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, dp[cnt][m]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="分组背包">分组背包</h4><p>一共有m组物品，每一组物品对应有s[i]个，对应每个物体有value和weight；背包容量为max，每一组物品中最多只能选择一个，如何选取获得最大的价值</p><p>分析：与01背包的差别在于，每一组的个数更多了，因此原来的考虑第i个物品，变成了考虑第i组物品</p><p>我们依然定义<code>dp[i][j]</code>为前i组物品，j容量对应的最大价值。</p><p>我们来考虑第i组物品，一共有s[i]个，假设不取i组的物品</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo separator="true">;</mo></mrow><annotation encoding="application/x-tex">dp[i][j]=dp[i-1][j];</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mpunct">;</span></span></span></span></span></p><p>然后再依次考虑第i组所有物品对应的情况，遍历该组的每一个物品，考虑其取与不取对应的最大价值</p><p>当然需要前提判断，当前容量j能够放下我们考虑的物品，<code>if(j&gt;=s[i][k])</code>,第i组的第k个物品</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mi>w</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo><mo stretchy="false">]</mo><mo>+</mo><mi>v</mi><mi>a</mi><mi>l</mi><mi>u</mi><mi>e</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">dp[i][j]=max(dp[i][j],dp[i-1][j-weight[i][k]]+value[i][k])</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal">e</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">h</span><span class="mord mathnormal">t</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">]]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">u</span><span class="mord mathnormal">e</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">])</span></span></span></span></span></p><p>因此代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> max_num 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> max_weight 200</span></span><br><span class="line"><span class="type">int</span> weight[<span class="number">100</span>][max_weight], value[<span class="number">100</span>][max_num];</span><br><span class="line"><span class="type">int</span> s[<span class="number">100</span>];<span class="comment">//表示每一组有多少个物品</span></span><br><span class="line"><span class="type">int</span> dp[<span class="number">100</span>][max_weight];<span class="comment">//前i组，最大价值 </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;s[i]);<span class="comment">//有很多个组，每个组最多只能选择一个物品 </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= s[i]; j++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;value[i][j], &amp;weight[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            dp[i][j] = dp[i - <span class="number">1</span>][j];<span class="comment">//不选第i组，从前i-1组里面选择</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= s[i]; k++) &#123;<span class="comment">//遍历第i组的所有物品 </span></span><br><span class="line">                <span class="keyword">if</span> (j &gt;= weight[i][k])</span><br><span class="line">                    dp[i][j] = max(dp[i][j], dp[i - <span class="number">1</span>][j - weight[i][k]] + value[i][k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, dp[n][m]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="完全背包">完全背包</h4><p>一共有n种物品，每个物品有无限个，对应有value和weight，背包容量为max，求解取到的最大价值</p><p>分析：如果我们把每一种物品的无限数量进行拆分，依然是01背包问题，或者是多重背包问题（只是这里无上限，不好进行优化），我们只需要在01背包基础上枚举每一种物品取的数量k即可，代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> max_num 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> max_weight 200</span></span><br><span class="line"><span class="type">int</span> weight[<span class="number">202</span>], value[<span class="number">202</span>];</span><br><span class="line"><span class="type">int</span> dp[<span class="number">100</span>][<span class="number">200</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这里看作01背包</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= max_weight; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k * weight[i] &lt;= j; k++) &#123;</span><br><span class="line">                dp[i][j] = max(dp[i][j], dp[i - <span class="number">1</span>][j - k * weight[i]] + k * value[i]);</span><br><span class="line">            &#125;<span class="comment">//去遍历对于每件商品的所有取值情况，取最大的价值的情况作为结果</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们仔细分析这段代码，显然发现</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mi>k</mi><mo>∗</mo><mi>w</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">]</mo><mo>+</mo><mi>k</mi><mo>∗</mo><mi>v</mi><mi>a</mi><mi>l</mi><mi>u</mi><mi>e</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi>k</mi><mo>=</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>3</mn><mo separator="true">,</mo><mn>4</mn></mrow><annotation encoding="application/x-tex">dp[i][j]=max(dp[i-1][j],dp[i-1][j-k*weight[i]]+k*value[i])... k=1,2,3,4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal">e</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">h</span><span class="mord mathnormal">t</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">u</span><span class="mord mathnormal">e</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">])</span><span class="mord">...</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">4</span></span></span></span></span></p><p>我们将j替换成<code>j-weight[i]</code>有</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mi>w</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">]</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mi>w</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mi>k</mi><mo>∗</mo><mi>w</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">]</mo><mo>+</mo><mi>k</mi><mo>∗</mo><mi>v</mi><mi>a</mi><mi>l</mi><mi>u</mi><mi>e</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi>k</mi><mo>=</mo><mn>2</mn><mo separator="true">,</mo><mn>3</mn><mo separator="true">,</mo><mn>4</mn><mo separator="true">,</mo><mn>5</mn><mo separator="true">,</mo><mn>6</mn></mrow><annotation encoding="application/x-tex">dp[i][j-weight[i]]=max(dp[i-1][j-weight[i]],dp[i-1][j-k*weight[i]]+k*value[i])...k=2,3,4,5,6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal">e</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">h</span><span class="mord mathnormal">t</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal">e</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">h</span><span class="mord mathnormal">t</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal">e</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">h</span><span class="mord mathnormal">t</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">u</span><span class="mord mathnormal">e</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">])</span><span class="mord">...</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">6</span></span></span></span></span></p><p>观察两个式子，我们发现两个式子可以把k给抵消掉（采用<strong>递归</strong>的形式消去k）（递归的过程是j从小到大递归，因此在代码的循环部分j也要从小到大），两个式子整合为下面式子 <strong>（读者可以自己多列举几个k的数值去理解这里是如何整合的）</strong></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mi>w</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">]</mo><mo>+</mo><mi>v</mi><mi>a</mi><mi>l</mi><mi>u</mi><mi>e</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">dp[i][j]=max(dp[i-1][j],dp[i][j-weight[i]]+value[i])</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal">e</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">h</span><span class="mord mathnormal">t</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">u</span><span class="mord mathnormal">e</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">])</span></span></span></span></span></p><p>因此代码在时间复杂度上可以优化成这样（三维到二维）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> max_weight 200</span></span><br><span class="line"><span class="type">int</span> weight[<span class="number">202</span>], value[<span class="number">202</span>];</span><br><span class="line"><span class="type">int</span> dp[<span class="number">100</span>][<span class="number">200</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &lt; weight[i])dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = max(dp[i - <span class="number">1</span>][j], dp[i][j - weight[i]] + value[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, dp[n][m]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="背包问题总结">背包问题总结</h4><p>四种背包问题在本质上都可以解释为01背包问题，简单的二维dp，只是附加了不同的条件，需要对应不同的方法去<strong>优化加强版的01背包</strong>，这些优化都是基于时间上的优化，但是背包问题普遍都可以使用<strong>滚动数组优化空间</strong>到一维。滚动数组优化以及各种背包问题的循环嵌套顺序，遍历顺序（从小到大或者是从大到小），可以自己尝试画出二维的递归表格，通过填涂表格的形式更好的理解嵌套和遍历顺序。</p><p>当然，嵌套和遍历顺序我们也可以通过状态转移方程推出，背包问题属于最基础形式的动态规划问题。</p>]]></content>
      
      
      
        <tags>
            
            <tag> c语言 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>typedef介绍</title>
      <link href="/2023/03/23/typedef%E4%BB%8B%E7%BB%8D/"/>
      <url>/2023/03/23/typedef%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><ul><li><p><em><strong>typedef解释</strong></em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">link</span>;</span></span><br><span class="line">&#125;<span class="comment">//通常使用这种方法创建链表结点，但是每次使用&quot;结点&quot;，我们都需要敲出&quot;struct node&quot;</span></span><br><span class="line"> <span class="comment">//同样，使用自引用指针需要&quot;struct node *&quot;，非常的麻烦，而且在一个c语言文件中不只有一类结点时非常混乱</span></span><br></pre></td></tr></table></figure><p>基于此我们引入&quot;typedef&quot;,typedef 类似于重命名操作，和&quot;define&quot;非常相似</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> max 1000 <span class="comment">//这里我们把max&quot;转换&quot;成1000(本人菜菜，想不到专业的话来解释，因此使用“转换”一词)</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> elementType <span class="comment">//这里我们使用 typedef 重命名 int 为 elementType</span></span><br><span class="line"><span class="comment">//typedef 的作用对象一般是&quot;类型&quot;，</span></span><br><span class="line">    <span class="comment">//类型包含系统自带的类型：char, short, int, long, long long, float, double等等</span></span><br><span class="line">    <span class="comment">//也包含用户自定义的类型：结构体</span></span><br><span class="line"><span class="comment">//考虑链表结点的创建</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">link</span>;</span></span><br><span class="line">&#125;<span class="comment">//这里的struct node就是用户自定义类型，因此可以使用typedef进行&quot;改名&quot;操作</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">link</span>;</span><span class="comment">//到这一步还未完成重命名操作，因此不可以用重命名之后的指针来替换struct node *</span></span><br><span class="line">&#125;Node,*Nodeptr;<span class="comment">//一般把重命名的名字写在大括号后面。</span></span><br><span class="line"><span class="comment">//这里的操作可以解释为以下两条语句</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> <span class="title">Node</span>;</span><span class="comment">//Node 表示struct node</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> * <span class="title">Nodeptr</span>;</span><span class="comment">//Nodeptr 表示struct node *</span></span><br><span class="line"><span class="comment">//考虑如下代码</span></span><br><span class="line"><span class="type">int</span> *a, b;<span class="comment">//这里的a是int*型的指针，而b是int整型</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">a</span>, <span class="title">b</span>;</span><span class="comment">//这里a是struct node *型的指针，b却是自定义类型struct node;</span></span><br><span class="line">Nodeptr a, b;<span class="comment">//这里用Nodeptr表示struct node *,不是简单的替换关系，a和b都是struct node* 型的指针。</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> c语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c语言模板</title>
      <link href="/2023/03/20/c%E8%AF%AD%E8%A8%80%E6%A8%A1%E6%9D%BF/"/>
      <url>/2023/03/20/c%E8%AF%AD%E8%A8%80%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<ul><li><p>本文主要是一些常用的c语言代码模板，包含部分简单算法，提供的代码解释也仅限于代码注释，请读者自行理解使用</p><span id="more"></span><h1>数据结果模板</h1><h2 id="链表">链表</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">element</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line"></span><br><span class="line">&#125; ElemType; <span class="comment">//创建元素类型；</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">link</span>;</span><span class="comment">//自引用指针；</span></span><br><span class="line"></span><br><span class="line">&#125; Node, *Nodeprt; <span class="comment">//创建链表和自引用指针类型；</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Nodeprt <span class="title function_">createList</span><span class="params">(<span class="type">int</span> n)</span>;<span class="comment">//创建n个结点的链表；</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getLength</span><span class="params">(Nodeprt <span class="built_in">list</span>)</span>;<span class="comment">//获得链表长度；</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">destroyList</span><span class="params">(Nodeprt <span class="built_in">list</span>)</span>;<span class="comment">//销毁一个表；</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printList</span><span class="params">(Nodeprt <span class="built_in">list</span>)</span>;<span class="comment">//输出一个表；</span></span><br><span class="line">Nodeprt <span class="title function_">insertFirst</span><span class="params">(Nodeprt <span class="built_in">list</span>, ElemType elem)</span>;<span class="comment">//链表开头插入一个元素；</span></span><br><span class="line">Nodeprt <span class="title function_">insertList_rank</span><span class="params">(Nodeprt <span class="built_in">list</span>, ElemType elem)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//有序链表插入相应结点；</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">insertNode1</span><span class="params">(Nodeprt <span class="built_in">list</span>, <span class="type">int</span> n, ElemType elem)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第n个结点之后插入一个结点</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">insertList</span><span class="params">(Nodeprt <span class="built_in">list</span>, Nodeprt p, ElemType elem)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//链表某一结点后面插入带某个元素的结点；</span></span><br><span class="line">Nodeprt <span class="title function_">searchNode</span><span class="params">(Nodeprt <span class="built_in">list</span>, ElemType elem)</span>; <span class="comment">//链表里查找某个元素，返回地址；</span></span><br><span class="line">Nodeprt <span class="title function_">deleteNode</span><span class="params">(Nodeprt <span class="built_in">list</span>, Nodeprt p)</span>; <span class="comment">//链表里面删除某一元素和结点p；</span></span><br><span class="line">ElemType <span class="title function_">read</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">buildlist</span><span class="params">(<span class="type">int</span> n)</span>;<span class="comment">//构建循环链表； </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//p=p-&gt;link;指向下一个结点；</span></span><br><span class="line">    <span class="comment">/*q-&gt;link=p-&gt;link;</span></span><br><span class="line"><span class="comment">    p-&gt;link=q;</span></span><br><span class="line"><span class="comment">    在p后面插入结点q*/</span></span><br><span class="line">    <span class="comment">/*q=p-&gt;link;</span></span><br><span class="line"><span class="comment">    p-&gt;link=q-&gt;link;</span></span><br><span class="line"><span class="comment">    free(q);</span></span><br><span class="line"><span class="comment">    删除p的下一个结点*/</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Nodeprt <span class="title function_">createList</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    Nodeprt p, q, <span class="built_in">list</span> = <span class="literal">NULL</span>;</span><br><span class="line">    p = (Nodeprt) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node)); <span class="comment">//Node结构大小的指针</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        q = (Nodeprt) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">        q-&gt;data = read(); <span class="comment">//读取一个元素；read自己写</span></span><br><span class="line">        <span class="comment">//根据题目的输入方法自己写合适的输入函数；</span></span><br><span class="line">        q-&gt;link = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">list</span> == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">list</span> = p = q;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            p-&gt;link = q;</span><br><span class="line">        &#125;</span><br><span class="line">        p = q; <span class="comment">//时间复杂度为n</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">getLength</span><span class="params">(Nodeprt <span class="built_in">list</span>)</span> &#123;</span><br><span class="line">    Nodeprt p;<span class="comment">//p为遍历所有结点的指针；</span></span><br><span class="line">    <span class="type">int</span> n = <span class="number">0</span>; <span class="comment">//长度初值；</span></span><br><span class="line">    <span class="keyword">for</span> (p = <span class="built_in">list</span>; p != <span class="literal">NULL</span>; p-&gt;link = p) &#123;</span><br><span class="line">        n++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Nodeprt <span class="title function_">insertFirst</span><span class="params">(Nodeprt <span class="built_in">list</span>, ElemType elem)</span> &#123;</span><br><span class="line">    Nodeprt p = (Nodeprt) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    p-&gt;data = elem; <span class="comment">//读入新的数据结点到开头；</span></span><br><span class="line">    p-&gt;link = <span class="built_in">list</span>;</span><br><span class="line">    <span class="keyword">return</span> p;<span class="comment">//p是新的起点；</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">insertNode</span><span class="params">(Nodeprt <span class="built_in">list</span>, Nodeprt p, ElemType elem)</span> &#123;<span class="comment">//p之后插入 </span></span><br><span class="line">    Nodeprt q = (Nodeprt) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    q-&gt;data = elem;</span><br><span class="line">    q-&gt;link = p-&gt;link;</span><br><span class="line">    p-&gt;link = q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">insertNode1</span><span class="params">(Nodeprt <span class="built_in">list</span>, <span class="type">int</span> n, ElemType elem)</span> &#123;</span><br><span class="line">    <span class="comment">//在第n个结点之后插入</span></span><br><span class="line">    Nodeprt p = <span class="built_in">list</span>, q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;link == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        p = p-&gt;link; <span class="comment">//n-1次后，p表示指向n的指针;</span></span><br><span class="line">        <span class="comment">//list算作第一个结点;</span></span><br><span class="line">    &#125;</span><br><span class="line">    q = (Nodeprt) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    q-&gt;data = elem;</span><br><span class="line">    q-&gt;link = p-&gt;link; <span class="comment">//新元素指向</span></span><br><span class="line">    p-&gt;link = q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Nodeprt <span class="title function_">insertList_rank</span><span class="params">(Nodeprt <span class="built_in">list</span>, ElemType elem)</span> &#123;</span><br><span class="line">    Nodeprt p, q, r;</span><br><span class="line">    r = (Nodeprt) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    r-&gt;data = elem;</span><br><span class="line">    r-&gt;link = <span class="literal">NULL</span>; <span class="comment">//创建新数据点</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">list</span> == <span class="literal">NULL</span>) &#123; <span class="comment">//空表</span></span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (p = <span class="built_in">list</span>; p != <span class="literal">NULL</span> &amp;&amp; elem &gt; p-&gt;data; q = p, p = p-&gt;link); <span class="comment">//找到插入点</span></span><br><span class="line">    <span class="comment">// 应该data是升序排列 q就是插入点指针</span></span><br><span class="line">    <span class="comment">//这里的比较大小，如果是单个元素可以直接比较，</span></span><br><span class="line">    <span class="comment">//如果是结构体,比较元素或者//需要另外写比较函数； </span></span><br><span class="line">    <span class="comment">//插入点在q后，p前 </span></span><br><span class="line">    <span class="keyword">if</span> (p == <span class="built_in">list</span>) &#123; <span class="comment">//没有q，在头指针前插入 </span></span><br><span class="line">        r-&gt;link = p;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        q-&gt;link = r;</span><br><span class="line">        r-&gt;link = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Nodeprt <span class="title function_">deleteNode</span><span class="params">(Nodeprt <span class="built_in">list</span>, Nodeprt p)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="built_in">list</span>) &#123;<span class="comment">//删除首结点 </span></span><br><span class="line">        <span class="built_in">list</span> = p-&gt;link;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Nodeprt q = (Nodeprt) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">        q = p-&gt;link;</span><br><span class="line">        p-&gt;link = q-&gt;link;</span><br><span class="line">        <span class="built_in">free</span>(q);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">buildlist</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line"></span><br><span class="line">    Nodeprt p, <span class="built_in">list</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        Nodeprt r = (Nodeprt) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">        r-&gt;data = read();</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">list</span> == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">list</span> = p = r;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            p-&gt;link = r;</span><br><span class="line">            p = p-&gt;link;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;link = <span class="built_in">list</span>;<span class="comment">//循环链表，把结尾和开头接上 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="栈">栈</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 1000</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">elem</span> &#123;</span></span><br><span class="line"></span><br><span class="line">&#125; ElemType;</span><br><span class="line">ElemType STACK[MAXSIZE];</span><br><span class="line"><span class="type">int</span> top = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化堆栈 </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">initStack</span><span class="params">()</span> &#123;</span><br><span class="line">    top = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试堆栈是否为空</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> top == <span class="number">-1</span>;<span class="comment">//栈空返回1，否则返回0 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试栈是否已满</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isFull</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> top == MAXSIZE - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//进栈</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Error</span><span class="params">(<span class="type">char</span> s[])</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, s);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">push</span><span class="params">(ElemType s[], ElemType item)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isFull()) &#123;</span><br><span class="line">        Error(<span class="string">&quot;Full Stack!&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        s[++top] = item;<span class="comment">//先++再赋值 </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出栈</span></span><br><span class="line">ElemType <span class="title function_">pop</span><span class="params">(ElemType s[])</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">        Error(<span class="string">&quot;Empty Stack!&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> s[top--];<span class="comment">//弹出s[top],再-- </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h2 id="队列">队列</h2><h3 id="一般队列">一般队列</h3><h3 id="优先队列-基于堆实现">优先队列(基于堆实现)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MinData -1001</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElementType;<span class="comment">//自定义数据类型； </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">HeapStruct</span> &#123;</span></span><br><span class="line">    ElementType *Elements;<span class="comment">//存储堆元素的数组，指针数组</span></span><br><span class="line">    <span class="type">int</span> size;    <span class="comment">//堆的当前元素个数； </span></span><br><span class="line">    <span class="type">int</span> capacity;<span class="comment">//堆的最大容量 </span></span><br><span class="line">&#125; MinHeap, *MinHeapPrt;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">IsFull</span><span class="params">(MinHeapPrt H)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (H-&gt;size == Maxsize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">IsEmpty</span><span class="params">(MinHeapPrt H)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (H-&gt;size == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MinHeapPrt <span class="title function_">Create</span><span class="params">(<span class="type">int</span> Maxsize)</span> &#123;</span><br><span class="line">    <span class="comment">//创建容量为Maxsize的空的最小堆</span></span><br><span class="line">    <span class="comment">//从1开始插入元素，0留给哨兵； </span></span><br><span class="line">    MinHeapPrt H = (MinHeapPrt) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(MinHeap));</span><br><span class="line">    H-&gt;Elements = (ElementType *) <span class="built_in">malloc</span>((Maxsize + <span class="number">1</span>) * <span class="keyword">sizeof</span>(ElementType));</span><br><span class="line">    H-&gt;size = <span class="number">0</span>;</span><br><span class="line">    H-&gt;capacity = Maxsize;</span><br><span class="line">    H-&gt;Elements[<span class="number">0</span>] = MinData;<span class="comment">//随便找一个特别小，比所有输入数据小的元素就行； </span></span><br><span class="line">    <span class="comment">//MinData.定义哨兵为小于堆中所有可能元素的值，便于以后更快操作</span></span><br><span class="line">    <span class="keyword">return</span> H;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">insert</span><span class="params">(MinHeapPrt H, ElementType item)</span> &#123;</span><br><span class="line">    <span class="comment">//将元素item插入最小堆H，其中H-&gt;Elements[0]已经定义为哨兵；</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">if</span> (IsFull(H)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;最小堆已满&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    i = ++H-&gt;size;<span class="comment">//i指向插入后的最后一个元素位置； </span></span><br><span class="line">    <span class="keyword">for</span> (; H-&gt;Elements[i / <span class="number">2</span>] &gt; item; i /= <span class="number">2</span>)<span class="comment">//完全二叉树有i/2表示父结点的性质；如果父结点比目标item大，</span></span><br><span class="line">        <span class="comment">//这里会有i=1的情况，但是有哨兵存在，哨兵保证了所有输入数据都比哨兵大，如果没有哨兵，可以加一句i&gt;1; </span></span><br><span class="line">        <span class="comment">//哨兵效率更高； </span></span><br><span class="line">        H-&gt;Elements[i] = H-&gt;Elements[i / <span class="number">2</span>];<span class="comment">//保证有序性，把大小不符合的往下过滤， </span></span><br><span class="line">    H-&gt;Elements[i] = item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ElementType <span class="title function_">deleteMin</span><span class="params">(MinHeapPrt H)</span> &#123;</span><br><span class="line">    <span class="comment">//从最小堆中去除键值最小的元素，删除结点</span></span><br><span class="line">    <span class="type">int</span> parent, child;</span><br><span class="line">    ElementType MinItem, temp;</span><br><span class="line">    <span class="keyword">if</span> (IsEmpty(H)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;最小堆已空&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    MinItem = H-&gt;Elements[<span class="number">1</span>];<span class="comment">//从根结点找最小值；</span></span><br><span class="line">    <span class="comment">//用最小堆中最后一个元素从根结点开始向上过滤下层结点，就是先把最后一个元素放到根的位置</span></span><br><span class="line">    temp = H-&gt;Elements[H-&gt;size--];<span class="comment">//先赋值，再减减 </span></span><br><span class="line">    <span class="keyword">for</span> (parent = <span class="number">1</span>; parent * <span class="number">2</span> &lt;= H-&gt;size; parent = child) &#123;<span class="comment">//判断保证存在左子； </span></span><br><span class="line">        child = parent * <span class="number">2</span>;<span class="comment">//左子</span></span><br><span class="line">        <span class="keyword">if</span> ((child != H-&gt;size) &amp;&amp; (H-&gt;Elements[child] &gt; H-&gt;Elements[child + <span class="number">1</span>])) <span class="comment">//判断保证有左子的同时还有右子； </span></span><br><span class="line">            child++;<span class="comment">//左子比右子大 </span></span><br><span class="line">        <span class="keyword">if</span> (temp &lt;= H-&gt;Elements[child])<span class="keyword">break</span>;<span class="comment">//调整值比左右子都小；那就放在父的位置 </span></span><br><span class="line">        <span class="keyword">else</span><span class="comment">//移动temp元素到下一层 </span></span><br><span class="line">            H-&gt;Elements[parent] = H-&gt;Elements[child];<span class="comment">//向上过滤，往上移 </span></span><br><span class="line">    &#125;</span><br><span class="line">    H-&gt;Elements[parent] = temp;</span><br><span class="line">    <span class="keyword">return</span> MinItem;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">adjust_MinHeap</span><span class="params">(MinHeapPrt H, <span class="type">int</span> p)</span> &#123;</span><br><span class="line">    <span class="comment">//保证数据已经形成了一颗完全二叉树，根是H，需要调整第p个结点为根的最小堆；</span></span><br><span class="line">    <span class="type">int</span> parent, child;</span><br><span class="line">    ElementType temp;</span><br><span class="line">    temp = H-&gt;Elements[p];<span class="comment">//以p为根的最小堆；,前提是p的左右子树都是最小堆；一般模型，某个根的左右子树都是最大堆或者最小堆，通过调整根让其整体成为最大/最小堆； </span></span><br><span class="line">    <span class="keyword">for</span> (parent = p; parent * <span class="number">2</span> &lt;= H-&gt;size; parent = child) &#123;</span><br><span class="line">        child = parent * <span class="number">2</span>;<span class="comment">//左</span></span><br><span class="line">        <span class="keyword">if</span> ((child != H-&gt;size) &amp;&amp; (H-&gt;Elements[child] &gt; H-&gt;Elements[child + <span class="number">1</span>])) &#123;</span><br><span class="line">            child++;<span class="comment">//左比右大 </span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (temp &lt;= H-&gt;Elements[child])<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            H-&gt;Elements[parent] = H-&gt;Elements[child];<span class="comment">//向下过滤，向上移动； </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    H-&gt;Elements[parent] = temp;<span class="comment">//调整了堆 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Build_MinHeap</span><span class="params">(MinHeapPrt H)</span> &#123; <span class="comment">/* 调整H-&gt;Data[]中的元素，使满足最小堆的有序性  */</span></span><br><span class="line">    <span class="comment">/* 这里假设所有H-&gt;Size个元素已经存在H-&gt;Elements[]中 */</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="comment">/* 从最后一个结点的父节点开始，到根结点1 */</span></span><br><span class="line">    <span class="comment">//所有叶结点已经是最大堆或者最小堆；从最后一个满足（根不符合，但是根的左右子树都满足最大堆，最小堆的结构开始调整） </span></span><br><span class="line">    <span class="keyword">for</span> (i = H-&gt;size / <span class="number">2</span>; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">        adjust_MinHeap(H, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单调队列-以递减为例">单调队列(以递减为例)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Maxsize 10000</span></span><br><span class="line"><span class="type">int</span> queue_num[Maxsize], queue_site[Maxsize];</span><br><span class="line"><span class="comment">//num存储队列数值，site存取对应数值在原先的数组里面的位置；</span></span><br><span class="line"><span class="type">int</span> head = <span class="number">0</span>, rear = <span class="number">0</span>;<span class="comment">//rear-1表示当前队尾的位置，head表示当前对头的位置 </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> n, x, k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">        <span class="keyword">if</span> (head != rear) &#123;<span class="comment">//队列非空</span></span><br><span class="line">            <span class="comment">//单调队列的单调情况有：增，减，自定义</span></span><br><span class="line">            <span class="comment">//下面以递减为例子</span></span><br><span class="line">            <span class="keyword">while</span> (head != rear &amp;&amp; queue_site[head] &lt;= i - k)head++;<span class="comment">//如果队首元素不在扫描区间内部，从队首弹出</span></span><br><span class="line">            <span class="keyword">while</span> (head != rear &amp;&amp; queue_num[rear - <span class="number">1</span>] &lt;= x)rear--;<span class="comment">//队尾元素比新元素小或者等于，从队尾弹出</span></span><br><span class="line">            queue_num[rear] = x;</span><br><span class="line">            queue_site[rear++] = i;<span class="comment">//新元素入队 </span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//队列空了，</span></span><br><span class="line">            queue_num[rear] = x;</span><br><span class="line">            queue_site[rear++] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="树">树</h2><h3 id="哈夫曼树-基于最小堆实现最小加权">哈夫曼树(基于最小堆实现最小加权)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">HuffmanTree</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> weight;</span><br><span class="line">    HuffmanTree left, right;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//需要最小堆实现； </span></span><br><span class="line">HuffmanTree <span class="title function_">Huffman</span><span class="params">(MinHeapPrt H)</span> &#123;</span><br><span class="line">    <span class="comment">//假设H-&gt;size个权值已经存在H-&gt;Elements[]-&gt;weight里面了</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    HuffmanTree T;</span><br><span class="line">    BuildMinHeap(H);<span class="comment">//将H-&gt;Elements[]按照权值调整为最小堆</span></span><br><span class="line">    <span class="type">int</span> k = H-&gt;size;<span class="comment">//在下面合并过程中size会被改变，需要维持不变 </span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; k; i++) &#123;<span class="comment">//做H-&gt;size-1次合并</span></span><br><span class="line">        T = (HuffmanTree) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> TreeNode));</span><br><span class="line">        T-&gt;left = deleteMin(H);<span class="comment">//从最小堆里面删除一个结点作为新T的左子</span></span><br><span class="line">        T-&gt;right = deleteMin(H);<span class="comment">//从最小堆里面删除一个结点作为新T的右子；</span></span><br><span class="line">        T-&gt;weight = T-&gt;left-&gt;weight + T-&gt;right-&gt;weight;</span><br><span class="line">        <span class="comment">//计算新权值；</span></span><br><span class="line">        insert(H, T);<span class="comment">//将新T插入最小堆； </span></span><br><span class="line">    &#125;</span><br><span class="line">    T = deleteMin(H);</span><br><span class="line">    <span class="keyword">return</span> T;<span class="comment">///时间复杂度为nlogn；</span></span><br><span class="line">    <span class="comment">//构造一颗哈夫曼树； </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="图">图</h2><h3 id="最小生成树">最小生成树</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXVER  512</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INFINITY   32767<span class="comment">//定义无穷大 </span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Prim</span><span class="params">(<span class="type">int</span> weights[][MAXVER], <span class="type">int</span> n, <span class="type">int</span> src, <span class="type">int</span> edges[])</span> &#123; <span class="comment">//weights为权重数组、n为顶点个数、src为最小树的第一个顶点、edge为最小生成树边</span></span><br><span class="line">    <span class="comment">//定义edge[i]为顶点i的前序顶点，就是edge[i]顶点之后就是i顶点 </span></span><br><span class="line">    <span class="type">int</span> minweight[MAXVER], min;</span><br><span class="line">    <span class="type">int</span> i, j, k;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;  <span class="comment">//初始化相关数组</span></span><br><span class="line">        minweight[i] = weights[src][i];  <span class="comment">//将src顶点与之有边的权值存入数组</span></span><br><span class="line">        <span class="comment">//采用邻接矩阵，不存在的边采用无穷大存取； </span></span><br><span class="line">        edges[i] = src;  <span class="comment">//初始时所有顶点的前序顶点设为src，(src,i）//edge数组其实就是在保存最小生成树的结构； </span></span><br><span class="line">    &#125;</span><br><span class="line">    minweight[src] = <span class="number">0</span>;   <span class="comment">//将第一个顶点src顶点加入生成树</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        min = INFINITY;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>, k = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            <span class="keyword">if</span> (minweight[j] != <span class="number">0</span> &amp;&amp; minweight[j] &lt; min) &#123;  <span class="comment">//在数组中找最小值，其下标为k</span></span><br><span class="line">                <span class="comment">//找距离最小生成树最近的结点，就是最小权值 </span></span><br><span class="line">                min = minweight[j];</span><br><span class="line">                k = j;</span><br><span class="line">            &#125;</span><br><span class="line">        minweight[k] = <span class="number">0</span>;  <span class="comment">//找到最小树的一个顶点，</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            <span class="keyword">if</span> (minweight[j] != <span class="number">0</span> &amp;&amp; weights[k][j] &lt; minweight[j]) &#123;  <span class="comment">//根据最新加入的点k去更新minweight数组； </span></span><br><span class="line">                minweight[j] = weights[k][j];    <span class="comment">//将小于当前权值的边(k,j)权值加入数组中</span></span><br><span class="line">                edges[j] = k;   <span class="comment">//将边(j,k)信息存入边数组中</span></span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//kruskal算法 </span></span><br></pre></td></tr></table></figure><h1>动态规划</h1><h2 id="01背包">01背包</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> max_num 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> max_weight 200</span></span><br><span class="line"><span class="type">int</span> weight[<span class="number">202</span>], value[<span class="number">202</span>];</span><br><span class="line"><span class="type">int</span> dp[max_num][max_weight];<span class="comment">//dp[i][j]表示考虑前i件商品，有j的容量能取到的最大价值 </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> n, m;<span class="comment">//m就是定义的最大容量 </span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;weight[i], &amp;value[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &lt; weight[i])dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = max(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - weight[i]] + value[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//考虑第i件物品时，当前容量j，商品weight[i]</span></span><br><span class="line"><span class="comment">//如果j能够装下第i件商品，dp[i][j]=dp[i-1][j-weight[i]]+value[i],这是拿下该商品的价值</span></span><br><span class="line"><span class="comment">//如果能装下，但是不买，dp[i][j]=dp[i-1][j],等价于考虑前i-1件商品的情况j容量</span></span><br><span class="line"><span class="comment">//对于内外层循环的参数选择，以及从大到小，或者从小到大的顺序选择,</span></span><br><span class="line"><span class="comment">//以设置的二维dp数组的第一个参数作为行，第二个作为列，画出二维对应图表</span></span><br><span class="line"><span class="comment">//那么dp[i][j]的数值与dp[i-1][j]或者dp[i-1][j-weight[i]]有关，也就是上一行有关，</span></span><br><span class="line"><span class="comment">//而j的取值与j或者j-weight[i]有关，所以确定循环方式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//超级优化：一维滚动数组，详细参考csdn文章 </span></span><br><span class="line"><span class="comment">/*int dp[max_weight];</span></span><br><span class="line"><span class="comment">    for(int i=1;i&lt;=n;i++)&#123;</span></span><br><span class="line"><span class="comment">        for(int j=m;j&gt;=weight[i];j--)&#123;</span></span><br><span class="line"><span class="comment">            dp[j]=max(dp[j],dp[j-weight[i]]+value[i]);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br></pre></td></tr></table></figure><h2 id="多重背包-二进制优化">多重背包(二进制优化)</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> max_num 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> max_weight 200</span></span><br><span class="line"><span class="type">int</span> weight[<span class="number">202</span>], value[<span class="number">202</span>];</span><br><span class="line"><span class="type">int</span> dp[max_num][max_weight];<span class="comment">//dp[i][j]表示考虑前i件商品，有j的容量能取到的最大价值 </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="type">int</span> v, w, num;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;v, &amp;w, &amp;num);</span><br><span class="line">        <span class="comment">//对num进行2进制拆解，1，2，4，8，16 .........以及一个无法继续取到的余数</span></span><br><span class="line">        <span class="comment">//10=1,2,4,3</span></span><br><span class="line">        <span class="comment">//58=1,2,4,8,16,27,</span></span><br><span class="line">        <span class="type">int</span> k = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (k &lt;= num) &#123;</span><br><span class="line">            value[cnt] = v * k;</span><br><span class="line">            weight[cnt++] = w * k;</span><br><span class="line">            num -= k;</span><br><span class="line">            k &lt;&lt;= <span class="number">1</span>;<span class="comment">//k乘以2 </span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            value[cnt] = v * num;</span><br><span class="line">            weight[cnt++] = w * num;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//那么就是前cnt件商品</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= cnt - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &lt; weight[i])dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = max(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - weight[i]] + value[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对于n件商品，最大容量是m，每件商品价值value，对应weight，</span></span><br><span class="line"><span class="comment">//(与01背包不同点，每件商品数量是x件，把x件全部拆解开，转换成01背包问题 </span></span><br><span class="line"><span class="comment">//拆解之后，对于数组容量需要适当进行扩大 </span></span><br></pre></td></tr></table></figure><h2 id="分组背包">分组背包</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> max_num 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> max_weight 200</span></span><br><span class="line"><span class="type">int</span> weight[<span class="number">100</span>][max_weight], value[<span class="number">100</span>][max_num];</span><br><span class="line"><span class="type">int</span> s[<span class="number">100</span>];<span class="comment">//表示每一组有多少个物品</span></span><br><span class="line"><span class="type">int</span> dp[<span class="number">100</span>][max_weight];<span class="comment">//前i组，最大价值 </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;s[i]);<span class="comment">//有很多个组，每个组最多只能选择一个物品 </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= s[i]; j++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;value[i][j], &amp;weight[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            dp[i][j] = dp[i - <span class="number">1</span>][j];<span class="comment">//不选第i组，从前i-1组里面选择</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= s[i]; k++) &#123;<span class="comment">//遍历第i组的所有物品 </span></span><br><span class="line">                <span class="keyword">if</span> (j &gt;= weight[i][k])</span><br><span class="line">                    dp[i][j] = max(dp[i][j], dp[i - <span class="number">1</span>][j - weight[i][k]] + value[i][k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//滚动数组优化，一维</span></span><br><span class="line"><span class="comment">//滚动数组逆向枚举，具体思想还是得画出二维表格进行推导</span></span><br><span class="line"><span class="comment">/*int f[100];</span></span><br><span class="line"><span class="comment">            for(int i=1;i&lt;=n;i++)&#123;</span></span><br><span class="line"><span class="comment">                for(int j=m;j&gt;=0;j--)&#123;</span></span><br><span class="line"><span class="comment">                    for(int k=1;k&lt;=s[i];k++)&#123;</span></span><br><span class="line"><span class="comment">                        if(j&gt;=weight[i][k])f[j]=max(f[j],f[j-weight[i][k]]+value[i][k]);</span></span><br><span class="line"><span class="comment">                    &#125;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            &#125; */</span> </span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="完全背包">完全背包</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> max_num 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> max_weight 200</span></span><br><span class="line"><span class="type">int</span> weight[<span class="number">202</span>], value[<span class="number">202</span>];</span><br><span class="line"><span class="type">int</span> dp[<span class="number">100</span>][<span class="number">200</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &lt; weight[i])dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = max(dp[i - <span class="number">1</span>][j], dp[i][j - weight[i]] + value[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*分析完全背包问题，每个物品有无限个，求最大价值</span></span><br><span class="line"><span class="comment">1.暴力解法</span></span><br><span class="line"><span class="comment">for(int i=1;i&lt;=n;i++)&#123;</span></span><br><span class="line"><span class="comment">for(int j=0;j&lt;=max_weight;j++)&#123;</span></span><br><span class="line"><span class="comment">for(int k=0;k*weight[i]&lt;=j;k++)&#123;</span></span><br><span class="line"><span class="comment">dp[i][j]=max(dp[i][j],dp[i-1][j-k*weight[i]]+k*value[i]);</span></span><br><span class="line"><span class="comment">&#125;//去遍历对于每件商品的所有取值情况，取最大的价值的情况作为结果 </span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="comment">/*分析：dp[i][j]=max(dp[i-1][j],dp[i-1][j-k*weight[i]]+value[i]*k);</span></span><br><span class="line"><span class="comment">        其中k取很多很多值，这里只是一个缩写,这里把j替换一下，可以实现递归整体替换 </span></span><br><span class="line"><span class="comment">        dp[i][j-weight[i]]=max(dp[i-1][j-weight[i]],dp[i-1][j-weight[i]*k]+k*value[i]);</span></span><br><span class="line"><span class="comment">        把两个式子整合在一起</span></span><br><span class="line"><span class="comment">        dp[i][j]=max(dp[i-1][j],dp[i][j-weight[i]]);</span></span><br><span class="line"><span class="comment">        只要循环的时候j从小到大遍历就行</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">    优化1：</span></span><br><span class="line"><span class="comment">    for(int i=1;i&lt;=n;i++)&#123;</span></span><br><span class="line"><span class="comment">        for(int j=0;j&lt;=max_weight;j++)&#123;</span></span><br><span class="line"><span class="comment">            if(j&lt;weight[i])dp[i][j]=dp[i-1][j];</span></span><br><span class="line"><span class="comment">            else&#123;</span></span><br><span class="line"><span class="comment">                dp[i][j]=max(dp[i-1][j],dp[i][j-weight[i]]+value[i]);</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    超级优化,滚动数组：详细参考csdn文章 </span></span><br><span class="line"><span class="comment">        for(int i=1;i&lt;=n;i++)&#123;</span></span><br><span class="line"><span class="comment">            for(int j=weight[i];j&lt;=max_weight;j++)&#123;</span></span><br><span class="line"><span class="comment">                f[j]=max(f[j],f[j-weight[i]]+value[i]);</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            直接优化成为一维了*/</span></span><br></pre></td></tr></table></figure><h1>排序</h1><h2 id="二路归并">二路归并</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//归并排序 非递归版本</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MergeSortNonR</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> *tmp = (<span class="type">int</span> *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * n);</span><br><span class="line">    <span class="keyword">if</span> (tmp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;申请空间失败\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> gap = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (gap &lt; n) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i += <span class="number">2</span> * gap) &#123; <span class="comment">//每次跨越两组</span></span><br><span class="line">            <span class="type">int</span> begin1 = i, end1 = i + gap - <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> begin2 = i + gap, end2 = i + <span class="number">2</span> * gap - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (end1 &gt;= n || begin2 &gt;= n) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (end2 &gt;= n) &#123;</span><br><span class="line">                end2 = n - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//归并</span></span><br><span class="line">            <span class="type">int</span> j = begin1;</span><br><span class="line">            <span class="type">int</span> m = end2 - begin1 + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (begin1 &lt;= end1 &amp;&amp; begin2 &lt;= end2) &#123;</span><br><span class="line">                <span class="keyword">if</span> (a[begin1] &lt;= a[begin2]) &#123;</span><br><span class="line">                    tmp[j++] = a[begin1++];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    tmp[j++] = a[begin2++];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (begin1 &lt;= end1) &#123;</span><br><span class="line">                tmp[j++] = a[begin1++];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (begin2 &lt;= end2) &#123;</span><br><span class="line">                tmp[j++] = a[begin2++];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">memcpy</span>(a + i, tmp + i, <span class="keyword">sizeof</span>(<span class="type">int</span>) * m);<span class="comment">//局部复制，end2 - begin1 + 1</span></span><br><span class="line">        &#125;</span><br><span class="line">        gap *= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(tmp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//归并排序的递归///////数据不能太大，不然会爆栈</span></span><br><span class="line"><span class="comment">//////////////////////////</span></span><br><span class="line"><span class="comment">//辅助归并排序递归的子函数</span></span><br><span class="line"><span class="type">void</span> _MergeSort(<span class="type">int</span> *a, <span class="type">int</span> *tmp, <span class="type">int</span> begin, <span class="type">int</span> end) &#123;</span><br><span class="line">    <span class="keyword">if</span> (begin &gt;= end)</span><br><span class="line">        <span class="keyword">return</span>;<span class="comment">//单个或者不存在其区间就结束递归</span></span><br><span class="line">    <span class="comment">//类似于后序：</span></span><br><span class="line">    <span class="type">int</span> middle = (begin + end) / <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> begin1 = begin;</span><br><span class="line">    <span class="type">int</span> end1 = middle;</span><br><span class="line">    <span class="type">int</span> begin2 = middle + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> end2 = end;</span><br><span class="line">    _MergeSort(a, tmp, begin1, end1);</span><br><span class="line">    _MergeSort(a, tmp, begin2, end2);</span><br><span class="line">    <span class="comment">//此时认为 [begin1, end1] 和 [begin2, end2]两段区间上有序</span></span><br><span class="line">    <span class="comment">//归并算法</span></span><br><span class="line">    <span class="type">int</span> i = begin;</span><br><span class="line">    <span class="keyword">while</span> (begin1 &lt;= end1 &amp;&amp; begin2 &lt;= end2) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[begin1] &lt;= a[begin2]) &#123;</span><br><span class="line">            tmp[i++] = a[begin1++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tmp[i++] = a[begin2++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (begin1 &lt;= end1) &#123;</span><br><span class="line">        tmp[i++] = a[begin1++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (begin2 &lt;= end2) &#123;</span><br><span class="line">        tmp[i++] = a[begin2++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memcpy</span>(a + begin, tmp + begin, <span class="keyword">sizeof</span>(<span class="type">int</span>) * (end - begin + <span class="number">1</span>));<span class="comment">//内存操作函数，可以将整个数组的数复制过去</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//归并排序 递归版本</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MergeSort</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> *tmp = (<span class="type">int</span> *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * n);<span class="comment">//首先malloc一个数组</span></span><br><span class="line">    <span class="keyword">if</span> (tmp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;未能申请到内存\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//第一次传入 0 和 n - 1 传入闭区间</span></span><br><span class="line">    _MergeSort(a, tmp, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">free</span>(tmp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="手写快排">手写快排</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE 6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//快速排序</span></span><br><span class="line"><span class="comment">//升序排列，tmp=num[low]</span></span><br><span class="line"><span class="comment">//降序排列，tmp=num[high] </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">quick_sort</span><span class="params">(<span class="type">int</span> num[], <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i, j, temp;</span><br><span class="line">    <span class="type">int</span> tmp;</span><br><span class="line">    i = low;</span><br><span class="line">    j = high;<span class="comment">//快排区间； </span></span><br><span class="line">    tmp = num[low];   <span class="comment">//任命为中间分界线，左边比他小，右边比他大,通常第一个元素是基准数</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt; j) &#123;  <span class="comment">//如果下标i大于下标j，函数结束运行</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i != j) &#123;</span><br><span class="line">        <span class="keyword">while</span> (num[j] &gt;= tmp &amp;&amp; j &gt; i) &#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (num[i] &lt;= tmp &amp;&amp; j &gt; i) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j &gt; i) &#123;</span><br><span class="line">            temp = num[j];</span><br><span class="line">            num[j] = num[i];</span><br><span class="line">            num[i] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">//调整完基准数，分为三分区域，i，比i小的，比i大的； 如果有特数需求，可以只排某位后面的，或者前面的； </span></span><br><span class="line">    num[low] = num[i];</span><br><span class="line">    num[i] = tmp;</span><br><span class="line">    quick_sort(num, low, i - <span class="number">1</span>);</span><br><span class="line">    quick_sort(num, i + <span class="number">1</span>, high);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>其它</h1><h2 id="KMP">KMP</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">getnext</span><span class="params">(<span class="type">char</span> T[], <span class="type">int</span> next[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">-1</span>;</span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (T[i] != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">-1</span> || T[i] == T[j]) &#123;</span><br><span class="line">            <span class="comment">// i为后缀位置；j为前缀位置</span></span><br><span class="line">            <span class="comment">//如果新的位置匹配成功，那么说明next[k+1]= j+1;</span></span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            j = next[j]; <span class="comment">//若字符不同，则j值回溯</span></span><br><span class="line">        <span class="comment">//这里的回溯是在前j项里面找最大前后缀，而原串在j位置已经匹配了最大前后缀，所以</span></span><br><span class="line">        <span class="comment">//在前缀里面找最大前后缀，等价于找整个原串的新最大前后缀（类似于递归） </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">KMPindex</span><span class="params">(<span class="type">char</span> S[], <span class="type">char</span> T[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, *next;</span><br><span class="line">    next = (<span class="type">int</span> *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * (<span class="built_in">strlen</span>(T) + <span class="number">1</span>));</span><br><span class="line">    getnext(T, next); <span class="comment">//求next</span></span><br><span class="line">    <span class="keyword">while</span> (S[i] != <span class="string">&#x27;\0&#x27;</span> &amp;&amp; T[j] != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (S[i] == T[j]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line"><span class="comment">//j回退到相应位置开始匹配，i不变</span></span><br><span class="line">            (j == <span class="number">0</span>) ? i++ : (j = next[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(next);</span><br><span class="line">    <span class="keyword">if</span> (T[j] == <span class="string">&#x27;\0&#x27;</span>) <span class="comment">//匹配成功，返回匹配位置</span></span><br><span class="line">        <span class="keyword">return</span> i - j;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="快速幂">快速幂</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> <span class="title function_">low_mul</span><span class="params">(<span class="type">long</span> <span class="type">long</span> x, <span class="type">long</span> <span class="type">long</span> y, <span class="type">long</span> <span class="type">long</span> mod)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (y) &#123;</span><br><span class="line">        <span class="keyword">if</span> (y &amp; <span class="number">1</span>)</span><br><span class="line">            sum = (sum + x) % mod;</span><br><span class="line">        x = (x + x) % mod;</span><br><span class="line">        y &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对x*y拆分成为x+x+x。。。。，进行一个加速的取模，</span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> <span class="title function_">quick_mul</span><span class="params">(<span class="type">long</span> <span class="type">long</span> base, <span class="type">long</span> <span class="type">long</span> power, <span class="type">long</span> <span class="type">long</span> p)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> result = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld%lld&quot;</span>, &amp;base, &amp;power, &amp;p);</span><br><span class="line">    <span class="keyword">while</span> (power) &#123;</span><br><span class="line">        <span class="keyword">if</span> (power &amp; <span class="number">1</span>)<span class="comment">//power%2==1</span></span><br><span class="line">            result = (low_mul(result, base, p)) % p;</span><br><span class="line">        base = low_mul(base, base, p) % p;</span><br><span class="line">        power &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//base是底数，power是幂次，p是模数 </span></span><br></pre></td></tr></table></figure><h2 id="欧拉筛">欧拉筛</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> not_prime[<span class="number">1005</span>], prime[<span class="number">1005</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= max_num; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!not_prime[i])</span><br><span class="line">            prime[++cnt] = i;</span><br><span class="line">        <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= cnt &amp;&amp; prime[j] &lt;= max_num / i; j++) &#123;</span><br><span class="line">            not_prime[i * prime[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % prime[j] == <span class="number">0</span>)<span class="comment">//注意</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="简易计算器-单位数">简易计算器(单位数)</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 205</span></span><br><span class="line"><span class="type">char</span> stack_ch[MAXSIZE];</span><br><span class="line"><span class="type">char</span> stack_later[MAXSIZE];</span><br><span class="line"><span class="type">char</span> s[MAXSIZE];</span><br><span class="line"><span class="type">int</span> stack_cal[MAXSIZE];</span><br><span class="line"><span class="type">int</span> top_ch = <span class="number">-1</span>, top_la = <span class="number">-1</span>, top_cal = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">priority</span><span class="params">(<span class="type">char</span> c)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="string">&#x27;^&#x27;</span>)<span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;*&#x27;</span> || c == <span class="string">&#x27;/&#x27;</span> || c == <span class="string">&#x27;%&#x27;</span>)<span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;+&#x27;</span> || c == <span class="string">&#x27;-&#x27;</span>)<span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;(&#x27;</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;#&#x27;</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">isEmpty</span><span class="params">(<span class="type">int</span> top)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (top == <span class="number">-1</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">push</span><span class="params">(<span class="type">char</span> <span class="built_in">stack</span>[], <span class="type">int</span> *top, <span class="type">char</span> item)</span> &#123;</span><br><span class="line">    <span class="built_in">stack</span>[++(*top)] = item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">push_int</span><span class="params">(<span class="type">int</span> <span class="built_in">stack</span>[], <span class="type">int</span> *top, <span class="type">int</span> item)</span> &#123;</span><br><span class="line">    <span class="built_in">stack</span>[++(*top)] = item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> <span class="title function_">pop</span><span class="params">(<span class="type">char</span> <span class="built_in">stack</span>[], <span class="type">int</span> *top)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(*top)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error!&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">stack</span>[(*top)--];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pop_int</span><span class="params">(<span class="type">int</span> <span class="built_in">stack</span>[], <span class="type">int</span> *top)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(*top)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error!&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">stack</span>[(*top)--];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">my_power</span><span class="params">(<span class="type">int</span> base, <span class="type">int</span> power)</span> &#123;</span><br><span class="line">    <span class="type">int</span> k = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; power; i++) &#123;</span><br><span class="line">        k *= base;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s);<span class="comment">//读取中缀表达式；</span></span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    top_ch++;</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line"></span><br><span class="line">    stack_ch[top_ch] = <span class="string">&#x27;#&#x27;</span>;<span class="comment">//作为结束符； </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&#x27;0&#x27;</span> &lt;= s[i] &amp;&amp; s[i] &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">            push(stack_later, &amp;top_la, s[i]);<span class="comment">//数字直接入栈； </span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//操作符 </span></span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;(&#x27;</span>) &#123;<span class="comment">//入栈； </span></span><br><span class="line">                push(stack_ch, &amp;top_ch, s[i]);<span class="comment">//左括号直接入栈； </span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;)&#x27;</span>) &#123;<span class="comment">//依次弹出直到&#x27;(&#x27;,而且删除左括号； </span></span><br><span class="line">                ch = pop(stack_ch, &amp;top_ch);<span class="comment">//从符号栈弹出 </span></span><br><span class="line">                <span class="keyword">while</span> (ch != <span class="string">&#x27;(&#x27;</span> &amp;&amp; ch != <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">                    push(stack_later, &amp;top_la, ch);<span class="comment">//进入后缀栈； </span></span><br><span class="line">                    ch = pop(stack_ch, &amp;top_ch);<span class="comment">//当它是左括号时退出，top_ch指向左括号前面一个位置 </span></span><br><span class="line">                &#125;</span><br><span class="line">                stack_ch[top_ch + <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;<span class="comment">//删除左括号（不知道这样需不需要） </span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;^&#x27;</span>) &#123;<span class="comment">//幂直接入符号栈 </span></span><br><span class="line">                push(stack_ch, &amp;top_ch, s[i]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//最难部分，各种不同优先级操作字符； </span></span><br><span class="line">                <span class="keyword">if</span> (priority(s[i]) &gt; priority(stack_ch[top_ch])) &#123;<span class="comment">//新操作符优先级高于栈顶，直接入栈； </span></span><br><span class="line">                    push(stack_ch, &amp;top_ch, s[i]);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;<span class="comment">//否则依次弹出，直至优先级比它低，或者左括号；然后再进栈； </span></span><br><span class="line">                    ch = pop(stack_ch, &amp;top_ch);</span><br><span class="line">                    <span class="keyword">while</span> (priority(ch) &gt;= priority(s[i]) || ch != <span class="string">&#x27;(&#x27;</span>) &#123;<span class="comment">//低，或者左括号作为退出条件； </span></span><br><span class="line">                        push(stack_later, &amp;top_la, ch);</span><br><span class="line">                        ch = stack_ch[top_ch];</span><br><span class="line">                        <span class="keyword">if</span> (ch == <span class="string">&#x27;(&#x27;</span>) &#123;<span class="comment">//；入栈新操作符，然后跳出 </span></span><br><span class="line">                            push(stack_ch, &amp;top_ch, s[i]);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (priority(ch) &lt; priority(s[i])) &#123;</span><br><span class="line">                            push(stack_ch, &amp;top_ch, s[i]);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;<span class="comment">//说明无法跳出； </span></span><br><span class="line">                            ch = pop(stack_ch, &amp;top_ch);<span class="comment">//继续弹出操作符； </span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (stack_ch[top_ch] != <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">        ch = pop(stack_ch, &amp;top_ch);</span><br><span class="line">        push(stack_later, &amp;top_la, ch);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">///到这里就是后缀表达式； </span></span><br><span class="line">    <span class="comment">//printf(&quot;%s&quot;,stack_later);</span></span><br><span class="line">    <span class="comment">//遍历一遍后缀表达式 </span></span><br><span class="line">    <span class="type">int</span> len_la = <span class="built_in">strlen</span>(stack_later);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len_la; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&#x27;0&#x27;</span> &lt;= stack_later[i] &amp;&amp; stack_later[i] &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;<span class="comment">//是数字，入数字栈 </span></span><br><span class="line">            push_int(stack_cal, &amp;top_cal, stack_later[i] - <span class="string">&#x27;0&#x27;</span>);<span class="comment">//入栈 </span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//遇到操作符，第二个出栈数字   操作。。。 第一个出栈数字 </span></span><br><span class="line">            <span class="type">int</span> num1 = pop_int(stack_cal, &amp;top_cal);</span><br><span class="line">            <span class="type">int</span> num2 = pop_int(stack_cal, &amp;top_cal);<span class="comment">//弹出两个数字； </span></span><br><span class="line">            <span class="keyword">switch</span> (stack_later[i]) &#123;<span class="comment">//计算结果入栈 </span></span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                    push_int(stack_cal, &amp;top_cal, num2 + num1);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                    push_int(stack_cal, &amp;top_cal, num2 - num1);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                    push_int(stack_cal, &amp;top_cal, num2 * num1);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">                    push_int(stack_cal, &amp;top_cal, num2 / num1);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;%&#x27;</span>:</span><br><span class="line">                    push_int(stack_cal, &amp;top_cal, num2 % num1);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;^&#x27;</span>:</span><br><span class="line">                    push_int(stack_cal, &amp;top_cal, my_power(num2, num1));</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, stack_cal[top_cal]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="简易计算器-多位数">简易计算器(多位数)</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 205</span></span><br><span class="line"><span class="type">char</span> stack_ch[MAXSIZE];<span class="comment">//操作符临时栈 </span></span><br><span class="line"><span class="type">char</span> stack_later[MAXSIZE];<span class="comment">//操作符号最终栈； </span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> stack_num[MAXSIZE];<span class="comment">//数字栈； </span></span><br><span class="line"><span class="type">char</span> s[MAXSIZE];<span class="comment">//初始读取数组； </span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> stack_cal[MAXSIZE];<span class="comment">//计算栈；</span></span><br><span class="line"><span class="type">int</span> flag_sign[MAXSIZE];<span class="comment">//记录顺序数组，1表示这里使用数字栈，2表示使用符号栈 </span></span><br><span class="line"><span class="type">int</span> top_ch = <span class="number">-1</span>, top_num = <span class="number">-1</span>, top_cal = <span class="number">-1</span>, top_la = <span class="number">-1</span>;</span><br><span class="line"><span class="type">int</span> cnt_sign = <span class="number">0</span>;<span class="comment">//记录对应使用的栈的种类； </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">priority</span><span class="params">(<span class="type">char</span> c)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="string">&#x27;^&#x27;</span>)<span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;*&#x27;</span> || c == <span class="string">&#x27;/&#x27;</span> || c == <span class="string">&#x27;%&#x27;</span>)<span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;+&#x27;</span> || c == <span class="string">&#x27;-&#x27;</span>)<span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;(&#x27;</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;#&#x27;</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">isEmpty</span><span class="params">(<span class="type">int</span> top)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (top == <span class="number">-1</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">push_ch</span><span class="params">(<span class="type">char</span> <span class="built_in">stack</span>[], <span class="type">int</span> *top, <span class="type">char</span> item)</span> &#123;<span class="comment">//入字符栈 </span></span><br><span class="line">    <span class="built_in">stack</span>[++(*top)] = item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">push_num</span><span class="params">(<span class="type">long</span> <span class="type">long</span> <span class="built_in">stack</span>[], <span class="type">int</span> *top, <span class="type">long</span> <span class="type">long</span> item)</span> &#123;<span class="comment">//入数字栈 </span></span><br><span class="line">    <span class="built_in">stack</span>[++(*top)] = item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> <span class="title function_">pop_ch</span><span class="params">(<span class="type">char</span> <span class="built_in">stack</span>[], <span class="type">int</span> *top)</span> &#123;<span class="comment">//弹出符号栈 </span></span><br><span class="line">    <span class="keyword">if</span> (isEmpty(*top)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error!&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">stack</span>[(*top)--];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> <span class="title function_">pop_num</span><span class="params">(<span class="type">long</span> <span class="type">long</span> <span class="built_in">stack</span>[], <span class="type">int</span> *top)</span> &#123;<span class="comment">//弹出数字栈 </span></span><br><span class="line">    <span class="keyword">if</span> (isEmpty(*top)) &#123;</span><br><span class="line">        <span class="comment">//printf(&quot;error!&quot;);</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//解决负号问题； </span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">stack</span>[(*top)--];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">my_power</span><span class="params">(<span class="type">long</span> <span class="type">long</span> base, <span class="type">long</span> <span class="type">long</span> power)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> k = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; power; i++) &#123;</span><br><span class="line">        k *= base;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s);<span class="comment">//读取中缀表达式；//此处不修改 </span></span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    top_ch++;</span><br><span class="line">    stack_ch[top_ch] = <span class="string">&#x27;#&#x27;</span>;<span class="comment">//作为结束符；//不修改 </span></span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> tmp = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> flag_num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;<span class="comment">//b遍历所有输入的字符； </span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&#x27;0&#x27;</span> &lt;= s[i] &amp;&amp; s[i] &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;<span class="comment">//读取到数字，准备转换这个字符，变成多位（单位）数字； </span></span><br><span class="line">            tmp *= <span class="number">10</span>;</span><br><span class="line">            tmp += s[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            flag_num = <span class="number">1</span>; <span class="comment">//标记数字； </span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//操作符</span></span><br><span class="line">            <span class="comment">//说明要中断数字读取</span></span><br><span class="line">            <span class="keyword">if</span> (flag_num == <span class="number">1</span>) &#123;<span class="comment">//标记成功，之前有数字需要转换； </span></span><br><span class="line">                push_num(stack_num, &amp;top_num, tmp); <span class="comment">//入数字栈，并且清除各种标记；</span></span><br><span class="line">                flag_num = <span class="number">0</span>;</span><br><span class="line">                tmp = <span class="number">0</span>;</span><br><span class="line">                flag_sign[cnt_sign++] = <span class="number">1</span>;<span class="comment">//是数字标记 </span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;(&#x27;</span>) &#123;<span class="comment">//入临时符号栈 </span></span><br><span class="line">                push_ch(stack_ch, &amp;top_ch, s[i]);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;)&#x27;</span>) &#123;<span class="comment">//依次弹出直到&#x27;(&#x27;,而且删除左括号； </span></span><br><span class="line">                ch = pop_ch(stack_ch, &amp;top_ch);<span class="comment">//从临时符号栈弹出， </span></span><br><span class="line">                <span class="keyword">while</span> (ch != <span class="string">&#x27;(&#x27;</span> &amp;&amp; ch != <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">                    push_ch(stack_later, &amp;top_la, ch);<span class="comment">//进入最终栈；</span></span><br><span class="line">                    flag_sign[cnt_sign++] = <span class="number">2</span>;<span class="comment">//是操作符标记  </span></span><br><span class="line">                    ch = pop_ch(stack_ch, &amp;top_ch);<span class="comment">//当它是左括号时退出，top_ch指向左括号前面一个位置 </span></span><br><span class="line">                &#125;</span><br><span class="line">                stack_ch[top_ch + <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;<span class="comment">//删除左括号（不知道这样需不需要） </span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;^&#x27;</span>) &#123;<span class="comment">//幂直接入临时符号栈 </span></span><br><span class="line">                push_ch(stack_ch, &amp;top_ch, s[i]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//最难部分，各种不同优先级操作字符； </span></span><br><span class="line">                <span class="keyword">if</span> (priority(s[i]) &gt; priority(stack_ch[top_ch])) &#123;<span class="comment">//新操作符优先级高于临时栈栈顶，直接入临时栈； </span></span><br><span class="line">                    push_ch(stack_ch, &amp;top_ch, s[i]);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;<span class="comment">//否则依次弹出到最终栈，直至优先级比它低，或者左括号；然后再进临时栈； </span></span><br><span class="line">                    ch = pop_ch(stack_ch, &amp;top_ch);</span><br><span class="line">                    <span class="keyword">while</span> (priority(ch) &gt;= priority(s[i]) || ch != <span class="string">&#x27;(&#x27;</span>) &#123;<span class="comment">//低，或者左括号作为退出条件； </span></span><br><span class="line">                        push_ch(stack_later, &amp;top_la, ch);</span><br><span class="line">                        flag_sign[cnt_sign++] = <span class="number">2</span>;<span class="comment">//是操作符标记 </span></span><br><span class="line">                        ch = stack_ch[top_ch];</span><br><span class="line">                        <span class="keyword">if</span> (ch == <span class="string">&#x27;(&#x27;</span>) &#123;<span class="comment">//；入栈新操作符，然后跳出 </span></span><br><span class="line">                            push_ch(stack_ch, &amp;top_ch, s[i]);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (priority(ch) &lt; priority(s[i])) &#123;</span><br><span class="line">                            push_ch(stack_ch, &amp;top_ch, s[i]);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;<span class="comment">//说明无法跳出； </span></span><br><span class="line">                            ch = pop_ch(stack_ch, &amp;top_ch);<span class="comment">//继续弹出操作符； </span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//可能有末尾数字没录进去，</span></span><br><span class="line">    <span class="keyword">if</span> (flag_num == <span class="number">1</span>) &#123;</span><br><span class="line">        push_num(stack_num, &amp;top_num, tmp);</span><br><span class="line">        flag_sign[cnt_sign++] = <span class="number">1</span>;<span class="comment">//是数字标记 </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (stack_ch[top_ch] != <span class="string">&#x27;#&#x27;</span>) &#123;<span class="comment">//临时字符栈里面全部弹出到最终栈，并且标记顺序； </span></span><br><span class="line">        ch = pop_ch(stack_ch, &amp;top_ch);</span><br><span class="line">        push_ch(stack_later, &amp;top_la, ch);</span><br><span class="line">        flag_sign[cnt_sign++] = <span class="number">2</span>;<span class="comment">//是操作符标记 </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//到这里所有操作符都在stack_la里面，所有数字都在stack_num里面，有flag_sign数组存取各个操作符应该出现的顺序 </span></span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>, k = <span class="number">0</span>;<span class="comment">//j代表数字栈的下标，k代表符号栈的下标； </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; cnt_sign; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (flag_sign[i] == <span class="number">1</span>) &#123;<span class="comment">//是数字，入数字栈 </span></span><br><span class="line">            push_num(stack_cal, &amp;top_cal, stack_num[j++]);<span class="comment">//入计算栈 </span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (flag_sign[i] == <span class="number">2</span>) &#123;<span class="comment">//遇到操作符，第二个出栈数字   操作。。。 第一个出栈数字 </span></span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> num1 = pop_num(stack_cal, &amp;top_cal);</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> num2 = pop_num(stack_cal, &amp;top_cal);<span class="comment">//弹出两个数字； </span></span><br><span class="line">            <span class="keyword">switch</span> (stack_later[k++]) &#123;<span class="comment">//计算结果入栈 </span></span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                    push_num(stack_cal, &amp;top_cal, num2 + num1);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                    push_num(stack_cal, &amp;top_cal, num2 - num1);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                    push_num(stack_cal, &amp;top_cal, num2 * num1);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">                    push_num(stack_cal, &amp;top_cal, num2 / num1);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;%&#x27;</span>:</span><br><span class="line">                    push_num(stack_cal, &amp;top_cal, num2 % num1);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;^&#x27;</span>:</span><br><span class="line">                    push_num(stack_cal, &amp;top_cal, my_power(num2, num1));</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>, stack_cal[top_cal]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> c语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c语言 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
